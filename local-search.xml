<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python多线程编程入门指南：初步了解并行处理</title>
    <link href="/2020/05/01/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/"/>
    <url>/2020/05/01/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Python多线程编程入门指南：初步了解并行处理"><a href="#Python多线程编程入门指南：初步了解并行处理" class="headerlink" title="Python多线程编程入门指南：初步了解并行处理"></a>Python多线程编程入门指南：初步了解并行处理</h1><h2 id="python的引用计数机制"><a href="#python的引用计数机制" class="headerlink" title="python的引用计数机制"></a>python的引用计数机制</h2><p>Python中的引用计数机制是Python用于管理内存的一种方式，也是Python最关键的对象管理机制之一。每个Python对象都具有一个引用计数器，用于记录当前有多少个变量或者对象引用了该对象，当该计数器变为0时，Python会自动将该对象从内存中删除，以释放内存空间。</p><p>引用计数机制的优点是，当一个对象不再被引用时，Python可以立即将其从内存中删除，而不必等到垃圾回收器运行。这可以有效地减少内存的占用和释放的频率，提高程序的性能和效率。</p><p>在Python中，引用计数增加的情况有：</p><ol><li>创建对象，用变量接收：<code>name = &#39;123&#39;</code></li><li>对象被其他变量引用：<code>name2 = name</code></li><li>对象被其他对象引用（放入其他容器类型的数据中）：<code>li = [11, 22, name]</code></li><li>当作为函数参数传入函数中时：<code>def func(n):print(n)func(name)</code></li></ol><p>引用计数减少的情况包括：</p><ol><li>变量被显式销毁：<code>del name</code></li><li>引用对象的变量指向了其他对象（变量被重新赋了别的值）：<code>name2 = &#39;abc&#39;</code></li><li>从其他对象（容器类型数据中）移除：<code>li.pop()</code></li><li>函数执行完毕之后，内部作用域的变量会被销毁。</li></ol><p>除了引用计数机制，Python还使用了一些其他的机制来优化内存管理。例如，Python中有一个小整数池，其中包含了一些常用的整数（从-5到256）。如果程序中使用这些整数，Python会直接引用这些整数，而不是重新创建。此外，Python还有一个字符串驻留池机制，用于优化纯字符串的创建和管理，以及缓存机制，用于缓存常用的内置数据类型。这些机制都能够帮助Python有效地管理内存，提高程序的性能和效率。</p><h2 id="python中垃圾回收机制"><a href="#python中垃圾回收机制" class="headerlink" title="python中垃圾回收机制"></a>python中垃圾回收机制</h2><p>Python的垃圾回收机制主要分为三个部分：引用计数、标记清除和分代回收。</p><p>引用计数是Python最基础也是最重要的垃圾回收机制。在Python中，每个对象都会维护一个引用计数，当这个对象被创建时，引用计数为1；每当有一个新的变量引用这个对象，它的引用计数就会加1；当一个变量不再引用这个对象时，它的引用计数就会减1。当一个对象的引用计数为0时，说明没有任何变量引用它了，这时Python就会把它当作垃圾进行回收。通过引用计数机制，Python可以快速地回收不再使用的对象，释放内存。</p><p>然而，引用计数机制可能会遇到循环引用的问题，即两个或多个对象之间互相引用，导致它们的引用计数不为0。为了解决这个问题，Python引入了标记清除机制。标记清除的原理是，从所有的根对象开始，遍历整个对象图，对所有可以访问到的对象进行标记，标记完成后，所有未标记的对象就是垃圾，可以被回收。标记清除虽然可以解决循环引用问题，但是它的效率不如引用计数高。</p><p>为了兼顾引用计数的高效和标记清除的完整性，Python还引入了分代回收机制。分代回收的思想是，把所有对象分成三代，新创建的对象放在第一代，经过一定时间或经过一定次数的垃圾回收后依然存活的对象升级到第二代，以此类推。不同的代采用不同的垃圾回收策略，第一代使用引用计数和简单标记清除，第二代使用更复杂的标记清除和分代回收，第三代使用更复杂的标记清除和完整的分代回收。这样做的好处是，大多数对象都是短命的，只在第一代中存活，只有少数对象能够升级到第二代或第三代，这样就大大减少了垃圾回收的频率，提高了Python的性能。</p><p>除了引用计数机制和垃圾回收机制外，Python还实现了一些优化机制，如小整数池和字符串驻留池。</p><p>小整数池是Python对于范围在[-5, 256]的整数做了一个缓存，这些整数在程序中多次出现时，不会重新创建，而是直接引用缓存中的对象。这样可以节省内存空间，也能提高程序的执行效率。</p><p>字符串驻留池则是对于纯字符组成的字符串做了一个缓存，这些字符串在程序中多次出现时，也不会重新创建，而是直接引用缓存中的对象。字符串驻留池的实现方式是，当程序中定义了一个字符串后，如果这个字符串是由一系列字符组成的，并且这个字符串的长度在一定范围内，Python会把这个字符串缓存起来，以便在程序中的其他位置引用相同的字符串时直接使用缓存中的对象。这种方式同样可以节省内存空间，提高程序的执行效率。</p><p>此外，Python还实现了其他一些优化机制，如迭代器、生成器、装饰器等，这些机制可以使程序更加简洁、高效、易于维护。例如，迭代器可以让程序处理大量数据时不必一次性把数据全部加载到内存中，而是可以在需要时逐个取出数据，避免了内存占用过大的问题；生成器可以使程序更加高效地生成大量数据，减少内存的使用；装饰器可以让程序的功能更加灵活、可扩展，便于维护和管理。</p><h2 id="并发编程和多任务"><a href="#并发编程和多任务" class="headerlink" title="并发编程和多任务"></a>并发编程和多任务</h2><p>在Python中，多任务、并发和并行是三个重要的概念。</p><p>多任务是指同时运行多个任务，任务可以是多个线程或进程。在多任务环境下，每个任务都是独立运行的，但它们共享计算机的资源。在Python中，我们可以通过多线程、多进程或协程来实现多任务。</p><p>并发是指同时处理多个任务，但是它并不是真正的同时执行。在并发模式下，任务会轮流进行，使得它们看起来像是同时执行。在Python中，我们可以使用多线程、协程或异步IO来实现并发。</p><p>并行是指同时执行多个任务，也就是说多个任务真正的同时执行。在并行模式下，每个任务都有自己的处理器，可以并行执行。在Python中，我们可以通过多进程、协程或异步IO来实现并行。</p><p>需要注意的是，并发和并行是不同的概念。并发可以在单核处理器上实现，通过不断地切换任务达到看似同时执行的效果。而并行则需要多核处理器的支持，可以真正地同时执行多个任务。</p><h2 id="认识多线程"><a href="#认识多线程" class="headerlink" title="认识多线程"></a>认识多线程</h2><ol><li><p>什么是多线程？</p><ul><li>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。</li><li>多线程就是在一个程序中同时运行多个线程完成不同的任务，每个线程都可以独立运行，并且共享程序的内存空间。</li></ul></li><li><p>为什么需要多线程？</p><ul><li>多线程可以提高程序的运行效率，特别是在多核 CPU 的计算机上。</li><li>多线程可以实现并发编程，使得程序能够同时处理多个任务，提高了程序的响应速度。</li></ul></li><li><p>Python 中如何实现多线程？ </p><ul><li><p>Python 中可以使用内置的 threading 模块来实现多线程。</p></li><li><p>创建线程：通过 Thread 类来创建线程对象。</p></li><li><p>启动线程：通过 start() 方法来启动线程。</p></li><li><p>在子线程中执行任务：通过将需要执行的任务封装成一个函数，并将函数名作为 target 参数传入 Thread 类的构造函数中。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务1执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务2执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><span class="hljs-comment"># 创建线程</span><br>t1 = Thread(target=work1)<br>t2 = Thread(target=work2)<br><br><span class="hljs-comment"># 启动线程</span><br>t1.start()<br>t2.start()<br></code></pre></td></tr></table></figure></li><li><p>代码演示</p><ul><li>上述代码通过创建两个线程来模拟多任务的场景，其中 t1 线程执行 work1 函数，t2 线程执行 work2 函数。</li><li>在执行 t1.start() 和 t2.start() 之后，t1 和 t2 线程会同时启动，并且分别执行 work1 和 work2 函数中的代码。</li><li>由于 t1 和 t2 线程是并发执行的，因此在控制台中会看到两个函数的输出交替出现，这就实现了多任务的效果。</li></ul></li></ol><h2 id="线程模块的使用"><a href="#线程模块的使用" class="headerlink" title="线程模块的使用"></a>线程模块的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">import time</span><br><span class="hljs-string">from threading import Thread</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">def work1(name):</span><br><span class="hljs-string">    for i in range(1, 6):</span><br><span class="hljs-string">        time.sleep(1)</span><br><span class="hljs-string">        print(&quot;&#123;&#125;-任务1执行的第&#123;&#125;秒&quot;.format(name, i))</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">def work2(name):</span><br><span class="hljs-string">    for i in range(1, 7):</span><br><span class="hljs-string">        time.sleep(1)</span><br><span class="hljs-string">        print(&quot;&#123;&#125;-任务2执行的第&#123;&#125;秒&quot;.format(name, i))</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>Thread创建线程的参数：<br>    target：指定线程执行的任务函数<br>    daemon：是否设置为守护线程（默认是<span class="hljs-literal">False</span>）,【守护线程：主线程执行结束后，自动退出】<br>    name:设置线程名<br>    args：给任务函数传递位置参数（元组）<br>    kwargs:给任务函数传递关键字参数(字典)<br>    group：不需要传<br><br>线程对像的方法：<br>    start():启动线程的<br>    join()：设置主线程等待子线程执行的时间（默认等待执行完毕）<br>    run():线程中执行任务函数的方法<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">if __name__ == &#x27;__main__&#x27;:</span><br><span class="hljs-string">    s_time = time.time()</span><br><span class="hljs-string">    # 创建子线程</span><br><span class="hljs-string">    t1 = Thread(target=work1, args=(&#x27;张三&#x27;,))</span><br><span class="hljs-string">    t2 = Thread(target=work2, kwargs=&#123;&#x27;name&#x27;: &quot;李四&quot;&#125;)</span><br><span class="hljs-string">    # 启动线程</span><br><span class="hljs-string">    t1.start()</span><br><span class="hljs-string">    t2.start()</span><br><span class="hljs-string">    t1.run()</span><br><span class="hljs-string"></span><br><span class="hljs-string">    # 线程对象的join方法：设置主线程等待的时间</span><br><span class="hljs-string">    # t1.join(1)</span><br><span class="hljs-string">    # t2.join()</span><br><span class="hljs-string">    # 注意点：默认情况下，主线程不会等待子线程</span><br><span class="hljs-string">    e_time = time.time()</span><br><span class="hljs-string">    print(&quot;两个任务执行的总时间:&quot;, e_time - s_time)</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h2 id="自定义线程类"><a href="#自定义线程类" class="headerlink" title="自定义线程类"></a>自定义线程类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">自定义线程类的适用场景：</span><br><span class="hljs-string">    创建一个或多个执行特定任务的线程，可以再自定义线程类的run方法中，写任务执行的逻辑代码</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTread</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;用来生成测试数据&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;-任务执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(self.name, i))<br><br><br>t = MyTread(name=<span class="hljs-string">&#x27;musen&#x27;</span>)<br>t.start()<br><br>t2 = MyTread(name=<span class="hljs-string">&#x27;yuze&#x27;</span>)<br>t2.start()<br><br>t.run()<br><br>t2.run()<br></code></pre></td></tr></table></figure><h2 id="多线程之间资源竞争的问题"><a href="#多线程之间资源竞争的问题" class="headerlink" title="多线程之间资源竞争的问题"></a>多线程之间资源竞争的问题</h2><p>python中多线程是共享全局变量的（会出现资源竞争）</p><p>Cpython解释器中由于全局解释器锁(GIL)的存在，在同一时间，多个线程无法真正的一起执行(不可能出现并行)</p><p>python的GIL锁：<br>    1、线程只有获取全局解释器锁才能执行，执行到【线程切换的情况】会释放全局解释器锁<br>    线程切换的两种情况：<br>        1、线程执行遇到耗时等待（IO[input output]操作）<br>        2、执行时间达到指定的阈值(0.005秒)<br>            import sys<br>            print(sys.getswitchinterval())</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        number += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work1：&quot;</span>, number)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        number += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work2：&quot;</span>, number)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br>    <span class="hljs-comment"># 创建线程</span><br>    t1 = Thread(target=work1)<br>    t2 = Thread(target=work2)<br><br>    <span class="hljs-comment"># 启动线程</span><br>    t1.start()<br>    t2.start()<br><br>    <span class="hljs-comment"># 等待子线程执行完毕</span><br>    t1.join()<br>    t2.join()<br><br>    <span class="hljs-comment"># 输出结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程：&quot;</span>, number)<br></code></pre></td></tr></table></figure><p>这段代码演示了Python多线程中全局变量的问题。在两个线程<code>work1</code>和<code>work2</code>中都对全局变量<code>number</code>进行了100000次的加1操作。当主线程在两个子线程执行完毕后打印全局变量<code>number</code>时，由于两个子线程同时修改了<code>number</code>变量，所以可能得到意料之外的结果。</p><p>为了解决这个问题，可以使用锁机制来保证同一时间只有一个线程能够修改<code>number</code>变量。Python中提供了一个内置的<code>Lock</code>对象，可以使用它来实现线程同步，保证线程安全。下面是一份使用<code>Lock</code>对象解决上述问题的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-number">0</span><br>lock = Lock()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        <span class="hljs-keyword">with</span> lock:<br>            number += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work1：&quot;</span>, number)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        <span class="hljs-keyword">with</span> lock:<br>            number += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work2：&quot;</span>, number)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Lock<br><br>    <span class="hljs-comment"># 创建线程</span><br>    t1 = Thread(target=work1)<br>    t2 = Thread(target=work2)<br><br>    <span class="hljs-comment"># 启动线程</span><br>    t1.start()<br>    t2.start()<br><br>    <span class="hljs-comment"># 等待子线程执行完毕</span><br>    t1.join()<br>    t2.join()<br><br>    <span class="hljs-comment"># 输出结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程：&quot;</span>, number)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们首先创建了一个<code>Lock</code>对象，并在<code>work1</code>和<code>work2</code>函数中使用了<code>with lock</code>语句块，确保每次只有一个线程能够执行对<code>number</code>变量的修改。这样，当两个子线程完成了对<code>number</code>的所有修改后，主线程打印<code>number</code>的值就能得到正确的结果。</p><p>需要注意的是，在使用锁的过程中，需要避免死锁问题的发生，即两个线程相互等待对方释放锁而无法继续执行的情况。因此，在使用锁时需要遵循一些规则，如尽量避免使用嵌套锁、避免长时间持有锁等。</p><h2 id="线程模块中的Luck"><a href="#线程模块中的Luck" class="headerlink" title="线程模块中的Luck"></a>线程模块中的Luck</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Lock, Thread<br><br>number = <span class="hljs-number">0</span><br><br>使用Lock创建一把锁：锁的两种状态（上锁，未上锁）<br><br>loc = Lock()<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">注意点：</span><br><span class="hljs-string">    为了解决多线程操作共同的全局变量，出现资源竞争的情况，可以通过锁把</span><br><span class="hljs-string">    关键的代码【对全局资源修改的代码】锁起来，确保同一时间只有一个线程执行【对全局资源修改的代码】</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500000</span>):<br>        <span class="hljs-comment"># 上锁</span><br>        loc.acquire()<br>        number += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 释放锁</span><br>        loc.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work1：&quot;</span>, number)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500000</span>):<br>        <span class="hljs-comment"># 上锁</span><br>        loc.acquire()<br>        number += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 释放锁</span><br>        loc.release()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work2：&quot;</span>, number)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>创建线程<br><br>​    t1 = Thread(target=work1)<br>​    t2 = Thread(target=work2)<br><br>启动线程<br><br>​    t1.start()<br>​    t2.start()<br>​    t1.join()<br>​    t2.join()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程：&quot;</span>, number)<br></code></pre></td></tr></table></figure><p>本段代码演示了在多线程程序中如何使用 Lock（锁） 解决共享全局变量出现资源竞争的问题。</p><p>首先，通过 from threading import Lock 引入了 Lock 类。然后，创建了一把锁：loc &#x3D; Lock()。</p><p>在 work1 和 work2 函数中对全局变量 number 进行了 500000 次的自增操作。为了避免出现资源竞争，上锁和释放锁的操作必须要成对出现，保证同一时间只有一个线程执行修改共享全局变量的代码段。具体来说，在执行 number +&#x3D; 1 前，先调用 loc.acquire() 上锁；在执行完后，再调用 loc.release() 释放锁。这样可以保证多线程修改同一个全局变量时，不会出现数据错误。</p><p>最后，在主线程中输出了全局变量 number 的值。</p><p>在使用 Lock 的时候，需要注意以下几点：</p><ol><li>Lock 对象创建后处于未上锁状态，即 Lock.acquire() 返回值为 True。</li><li>多个线程可以同时调用 Lock.acquire() 上锁，但只有一个线程可以成功获取锁，其他线程会阻塞直到锁被释放。</li><li>可以通过调用 Lock.release() 释放锁，使其他线程可以获取到锁。</li><li>上锁和释放锁的操作必须要成对出现，否则会出现死锁等问题。</li><li>锁的过度使用会降低程序的性能。因此，在多线程编程时，应该尽量减少锁的使用。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python元类</title>
    <link href="/2020/04/23/%E8%AE%A4%E8%AF%86%E5%85%83%E7%B1%BB/"/>
    <url>/2020/04/23/%E8%AE%A4%E8%AF%86%E5%85%83%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Python元类"><a href="#Python元类" class="headerlink" title="Python元类"></a>Python元类</h1><h2 id="认识元类"><a href="#认识元类" class="headerlink" title="认识元类"></a>认识元类</h2><p>Python中的元类是一种高级语言特性，是Python中面向对象编程的重要组成部分之一。元类用于创建类，就像类用于创建对象一样。元类可以控制类的创建过程，可以修改类的属性、方法等等，同时也可以控制类的实例化过程。</p><p>在Python中，所有的东西都是对象，包括类。Python中的类是一个对象，是由元类创建出来的。元类实际上就是一个类的类，用于创建类对象。</p><p>在Python中，可以使用type()函数动态地创建类。type()函数的参数分别是类名、基类、类的属性（字典类型）。这种动态创建类的方式，实际上就是使用了元类。</p><p>下面通过示例代码来详细介绍下Python中元类的使用。</p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>        <span class="hljs-comment"># 控制类的创建过程</span><br>        attrs[<span class="hljs-string">&#x27;version&#x27;</span>] = <span class="hljs-string">&#x27;1.0&#x27;</span><br>        attrs[<span class="hljs-string">&#x27;info&#x27;</span>] = <span class="hljs-keyword">lambda</span> self: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;This is a class created by MyMeta&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(metaclass=MyMeta):<br>    <span class="hljs-comment"># 控制类的属性</span><br>    name = <span class="hljs-string">&#x27;MyClass&#x27;</span><br>    age = <span class="hljs-number">18</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, gender</span>):<br>        self.gender = gender<br><br>    <span class="hljs-comment"># 控制类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, I am&#x27;</span>, self.gender)<br><br><span class="hljs-comment"># 控制类的实例化过程</span><br>m = MyClass(<span class="hljs-string">&#x27;male&#x27;</span>)<br>m.say_hello()<br>m.info()<br><span class="hljs-built_in">print</span>(m.version)<br></code></pre></td></tr></table></figure><p>在这段代码中，我们定义了一个名为MyMeta的元类，继承自type类。在元类的<code>__new__()</code>方法中，我们通过修改attrs参数来控制了类的属性和方法，并返回一个新的类对象。</p><p>我们还定义了一个名为MyClass的类，并将元类设置为MyMeta。在MyClass中，我们设置了两个属性（name和age），以及一个方法（say_hello）和一个构造函数。我们还通过实例化一个MyClass对象来演示了元类对类实例化过程的控制。</p><p>通过这个例子，我们可以看到元类的用法和效果。元类是一个高级特性，掌握了元类的用法，可以更加灵活地控制类的创建过程、属性、方法以及实例化过程。在实际开发中，可以根据需要使用元类来实现更加灵活的编程。</p><h2 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h2><p>元类是 Python 中比较高级的概念，它用于控制类的创建。在 Python 中内置的元类是 <code>type</code>，它用于创建类。</p><p>通过自定义元类可以干涉类的创建过程，可以在类创建之前或之后添加、修改、删除属性等操作。自定义元类必须继承于 <code>type</code> 类，并实现 <code>__new__</code> 方法。</p><p><code>__new__</code> 方法用于在创建类时被调用，接收的参数有 <code>cls</code>、<code>name</code>、<code>bases</code>、<code>attrs</code>、<code>*args</code> 和 <code>**kwargs</code>。其中，<code>cls</code> 代表元类本身，<code>name</code> 代表要创建的类的名称，<code>bases</code> 代表要创建的类的父类，<code>attrs</code> 代表要创建的类的属性。</p><p>下面是一个简单的示例代码，演示如何使用自定义元类 <code>MyMateClass</code> 动态创建一个名为 <code>Demo</code> 的类，其中 <code>CaseData</code> 是类的属性之一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMateClass</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name&quot;</span>, name)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;bases&quot;</span>, bases)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;attrs&quot;</span>, attrs)<br>        <span class="hljs-comment"># 调用父类的new方法创建一个类，并返回</span><br>        new_cls = <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs, )<br>        <span class="hljs-keyword">return</span> new_cls<br><br><span class="hljs-comment"># 使用元类动态创建类</span><br>Demo = MyMateClass(<span class="hljs-string">&#x27;Demo&#x27;</span>, (<span class="hljs-built_in">object</span>,), &#123;<span class="hljs-string">&#x27;CaseData&#x27;</span>: [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>]&#125;)<br><span class="hljs-built_in">print</span>(Demo)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个自定义元类 <code>MyMateClass</code>，并在 <code>__new__</code> 方法中打印了类名、父类和属性信息。然后使用 <code>MyMateClass</code> 动态创建了一个名为 <code>Demo</code> 的类，并将 <code>CaseData</code> 设置为该类的一个属性。</p><p>总结一下，元类是一种高级的 Python 概念，可以用于控制类的创建过程。通过自定义元类，我们可以在类创建之前或之后对类进行干涉操作。在自定义元类中，必须实现 <code>__new__</code> 方法，并继承于 <code>type</code> 类。</p><h2 id="class定义类时指定元类"><a href="#class定义类时指定元类" class="headerlink" title="class定义类时指定元类"></a>class定义类时指定元类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义元类：必须要继承type类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMateClass</span>(<span class="hljs-title class_ inherited__">type</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name&quot;</span>, name)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;bases&quot;</span>, bases)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;attrs&quot;</span>, attrs)<br>        <span class="hljs-comment"># 调用父类的new方法创建一个类，并返回</span><br>        new_cls = <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs, )<br>        <span class="hljs-keyword">return</span> new_cls<br><br><br><span class="hljs-comment"># 定义类时，使用指定的元类去创建类(在类名后面的括号中通过metaclass指定元类)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoTest</span>(<span class="hljs-built_in">object</span>, metaclass=MyMateClass):<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(DemoTest))<br></code></pre></td></tr></table></figure><p>在 Python 中，元类是用于创建类的类，也就是说元类是类的类。在 Python 中，内置的元类是 type。当我们使用 class 关键字定义一个类时，实际上是使用了 type 类的一个实例去创建这个类的。</p><p>自定义元类可以干涉类创建的过程，也就是说可以在类创建的过程中做一些自定义的操作。元类必须要继承自 type 类，并且实现 <strong>new</strong> 方法。在 <strong>new</strong> 方法中，可以对类进行一些操作并返回一个新的类。创建类时，可以通过在类名后面的括号中通过 metaclass 参数指定元类。</p><p>示例代码中，自定义了一个元类 MyMateClass，并重写了它的 <strong>new</strong> 方法，在该方法中打印了传入的类名、基类和属性。然后定义了一个类 DemoTest，在类名后面的括号中通过 metaclass 参数指定元类为 MyMateClass。最后通过 type 函数获取 DemoTest 的类型，并输出其类型。</p><p>运行代码，可以看到输出了传入元类 <strong>new</strong> 方法的类名、基类和属性，并且输出了 DemoTest 的类型为 MyMateClass。</p><p>元类是 Python 中高级语法，通常在开发中较少使用。掌握元类有助于理解 Python 类的底层实现。</p><h2 id="通过元类实现DDT这个模块生成用例的公共能"><a href="#通过元类实现DDT这个模块生成用例的公共能" class="headerlink" title="通过元类实现DDT这个模块生成用例的公共能"></a>通过元类实现DDT这个模块生成用例的公共能</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_test_method</span>(<span class="hljs-params">func, params</span>):<br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> func(self, params)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-comment"># 自定义元类：必须要继承type类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMateClass</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs, *args, **kwargs</span>):<br>        new_cls = <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br>        <span class="hljs-comment"># 获取测试类中定义的测试数据</span><br>        <span class="hljs-comment"># 遍历测试数据，动态的给测试类添加用例(test开头的方法)</span><br>        <span class="hljs-keyword">for</span> index, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(attrs[<span class="hljs-string">&#x27;Cases&#x27;</span>]):<br>            <span class="hljs-comment"># 定义一个测试方法名</span><br>            new_func_name = <span class="hljs-string">&#x27;test_&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, index)<br>            <span class="hljs-comment"># 获取测试类中定义的方法</span><br>            method = update_test_method(attrs[<span class="hljs-string">&#x27;porform&#x27;</span>], item)<br>            <span class="hljs-comment"># 动态给测试类添加方法</span><br>            <span class="hljs-built_in">setattr</span>(new_cls, new_func_name, method)<br>        <span class="hljs-keyword">return</span> new_cls<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseTest</span>(unittest.TestCase, metaclass=TestMateClass):<br>    Cases = [<br>        &#123;<span class="hljs-string">&#x27;case_id&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;case_title&#x27;</span>: <span class="hljs-string">&#x27;用例1&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.baudi.com&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;001&#x27;</span>, <span class="hljs-string">&#x27;excepted&#x27;</span>: <span class="hljs-string">&#x27;ok&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;case_id&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;case_title&#x27;</span>: <span class="hljs-string">&#x27;用例4&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.baudi.com&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;002&#x27;</span>, <span class="hljs-string">&#x27;excepted&#x27;</span>: <span class="hljs-string">&#x27;ok&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;case_id&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;case_title&#x27;</span>: <span class="hljs-string">&#x27;用例2&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.baudi.com&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;002&#x27;</span>, <span class="hljs-string">&#x27;excepted&#x27;</span>: <span class="hljs-string">&#x27;ok&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;case_id&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;case_title&#x27;</span>: <span class="hljs-string">&#x27;用例3&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.baudi.com&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;002&#x27;</span>, <span class="hljs-string">&#x27;excepted&#x27;</span>: <span class="hljs-string">&#x27;ok&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;case_id&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;case_title&#x27;</span>: <span class="hljs-string">&#x27;用例5&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.baudi.com&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;002&#x27;</span>, <span class="hljs-string">&#x27;excepted&#x27;</span>: <span class="hljs-string">&#x27;ok&#x27;</span>&#125;<br>    ]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">porform</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试用例接收到测试数据&quot;</span>, item)<br>        <span class="hljs-comment"># 第一步：处理测试数据</span><br>        self.__handle_data()<br>        <span class="hljs-comment"># 第二步：发送请求</span><br>        self.__request_api()<br>        <span class="hljs-comment"># 第三步：提交接口返回的数据（上下接口有参数依赖的）</span><br>        self.__response_handle()<br>        <span class="hljs-comment"># 第四步：预期结果和实际结果断言</span><br>        self.__assertion()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__handle_data</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__request_api</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__response_handle</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__assertion</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python面向对象编程的三大特征</title>
    <link href="/2020/04/17/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/"/>
    <url>/2020/04/17/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Python面向对象编程的三大特征"><a href="#Python面向对象编程的三大特征" class="headerlink" title="Python面向对象编程的三大特征"></a>Python面向对象编程的三大特征</h1><p>Python是一种面向对象的编程语言，它支持面向对象的编程范式，拥有面向对象编程的三大特征：封装、继承和多态。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是指将数据和行为组合在一个类中，并对外部使用者隐藏其内部实现的细节。数据封装可以通过类的属性和方法来实现，可以将数据的可见性限制在类的内部，外部用户无法访问类的内部数据。这可以帮助保护数据的完整性和安全性，并且使得代码更易于维护。</p><p>以下是一个简单的封装示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.name<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.age<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_name</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):<br>        self.age = age<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个类<code>MyClass</code>，该类有<code>name</code>和<code>age</code>属性，同时有获取和设置属性的方法。这里，我们将数据封装在类中，并对外部使用者隐藏其内部实现细节。外部用户只能通过类的公共接口来访问和修改数据，这样可以保证数据的安全性。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是指通过一个已有的类来派生出一个新的类，新的类具有已有类的所有属性和方法，并可以添加新的属性和方法。继承可以帮助我们实现代码的复用和扩展，同时也使得代码更加简洁易读。</p><p>以下是一个简单的继承示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello, my name is <span class="hljs-subst">&#123;self.name&#125;</span> and I&#x27;m <span class="hljs-subst">&#123;self.age&#125;</span> years old.&quot;</span>)<br>        <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, grade</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name, age)<br>        self.grade = grade<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">study</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> is studying in grade <span class="hljs-subst">&#123;self.grade&#125;</span>.&quot;</span>)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个父类<code>Person</code>和一个子类<code>Student</code>。<code>Person</code>类有<code>name</code>和<code>age</code>属性，并有一个<code>say_hello</code>方法，用于打招呼。<code>Student</code>类继承了<code>Person</code>类，并添加了一个<code>grade</code>属性和一个<code>study</code>方法。我们可以看到，在<code>Student</code>类中，我们使用<code>super().__init__(name, age)</code>来调用父类的构造方法，并且在子类中添加了新的属性和方法。这样，我们就可以复用<code>Person</code>类的属性和方法，并且可以根据需要扩展代码。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指不同对象对同一消息做出不同的响应，也就是说，同一种方法可以有不同的表现形式，这个特性可以使代码更加灵活。多态有两种表现形式：重载和重写。</p><p>重载（overloading）是指在一个类中定义多个同名的方法，它们具有不同的参数个数、类型或者顺序，但是它们的方法名相同。Python不支持方法重载，因为Python中的方法是以方法名为索引的字典。</p><p>重写（overriding）是指在子类中定义与父类中同名的方法，这样子类对象就可以使用子类自己的方法了。Python中方法的重写使用和继承一样的方式实现。</p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多态示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">&quot;汪汪汪&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">&quot;喵喵喵&quot;</span>)<br><br><span class="hljs-comment"># 测试</span><br>animals = [Dog(<span class="hljs-string">&quot;旺财&quot;</span>), Cat(<span class="hljs-string">&quot;小黑&quot;</span>)]<br><span class="hljs-keyword">for</span> animal <span class="hljs-keyword">in</span> animals:<br>    animal.sound()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python属性管理和多态</title>
    <link href="/2020/04/12/Python%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <url>/2020/04/12/Python%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E5%92%8C%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Python属性管理和多态"><a href="#Python属性管理和多态" class="headerlink" title="Python属性管理和多态"></a>Python属性管理和多态</h1><h2 id="1-私有属性和属性字典"><a href="#1-私有属性和属性字典" class="headerlink" title="1.私有属性和属性字典"></a>1.私有属性和属性字典</h2><h3 id="1-1私有属性"><a href="#1-1私有属性" class="headerlink" title="1.1私有属性"></a>1.1私有属性</h3><p>Python中，私有属性指的是在类定义中以双下划线（“__”）开头的属性，这样的属性在类外部不能直接访问。Python并没有真正的私有属性，实际上它是通过一种名为“name mangling”的机制来实现的，即将属性名进行修改，以避免被意外访问。</p><p>当Python解释器遇到类定义中的以双下划线开头的属性时，会自动将属性名进行修改，使其变成“_classname__attribute”的形式。例如，在类定义中定义了一个私有属性“__private”，它的实际名称将变为“_classname__private”。这样，我们就可以在类的方法中访问这个属性，但在类外部无法直接访问。</p><p>下面是一个示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.__age = age<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__age<br><br>p = Person(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">25</span>)<br><span class="hljs-built_in">print</span>(p.name)   <span class="hljs-comment"># Output: Alice</span><br><span class="hljs-built_in">print</span>(p.get_age())   <span class="hljs-comment"># Output: 25</span><br><span class="hljs-built_in">print</span>(p.__age)   <span class="hljs-comment"># Output: AttributeError: &#x27;Person&#x27; object has no attribute &#x27;__age&#x27;</span><br><span class="hljs-built_in">print</span>(p._Person__age)   <span class="hljs-comment"># Output: 25</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个Person类，其中定义了一个私有属性“__age”。在类的构造函数中，我们初始化了这个属性。我们还定义了一个名为“get_age”的方法，它可以返回私有属性“__age”的值。</p><p>在主程序中，我们创建了一个Person类的实例p，并尝试访问它的“name”和“__age”属性。由于“name”属性不是私有属性，因此我们可以直接访问它。但是，由于“__age”是私有属性，我们不能直接访问它。如果我们尝试这样做，Python会引发AttributeError异常。但是，我们可以使用“_Person__age”这样的名称来访问它。</p><p>需要注意的是，尽管我们可以通过这种方式访问私有属性，但是这并不是Python语言官方建议的做法。在Python中，一般情况下应该尽量避免访问私有属性，而是通过公共接口访问属性值，这样可以使代码更加健壮和易于维护。</p><h3 id="1-2-属性字典"><a href="#1-2-属性字典" class="headerlink" title="1.2 属性字典"></a>1.2 属性字典</h3><p>在Python中，每个对象都有一个字典，记录了它的属性和对应的值。这个字典被称为属性字典（<code>__dict__</code>），可以通过它来获取对象的属性。</p><p>对于类来说，类的属性字典记录了类定义中的所有属性，包括类变量和方法。对于对象来说，属性字典记录了对象实例中定义的所有属性，包括实例变量和方法。属性字典是一个键值对的集合，键是属性名，值是属性值。</p><p>在Python中，私有属性是指以双下划线开头但不以双下划线结尾的属性。Python中的私有属性并不是真正的私有，它们只是在属性名前面添加了一个下划线，告诉其他程序员这个属性不应该被直接访问。但是，Python中的属性字典可以访问到这些私有属性。</p><p>下面是一个示例代码，演示如何使用属性字典获取类和对象的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    __private_attribute = <span class="hljs-string">&#x27;private&#x27;</span><br>    public_attribute = <span class="hljs-string">&#x27;public&#x27;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.instance_attribute = <span class="hljs-string">&#x27;instance&#x27;</span><br>        <br>m = MyClass()<br><span class="hljs-built_in">print</span>(MyClass.__dict__)  <span class="hljs-comment"># 获取类的属性字典</span><br><span class="hljs-comment"># 输出：&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;_MyClass__private_attribute&#x27;: &#x27;private&#x27;, </span><br><span class="hljs-comment">#        &#x27;public_attribute&#x27;: &#x27;public&#x27;, &#x27;__init__&#x27;: &lt;function MyClass.__init__ at 0x7f9df32d4a60&gt;, </span><br><span class="hljs-comment">#        &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;MyClass&#x27; objects&gt;, &#x27;__weakref__&#x27;: </span><br><span class="hljs-comment">#        &lt;attribute &#x27;__weakref__&#x27; of &#x27;MyClass&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span><br><br><span class="hljs-built_in">print</span>(m.__dict__)  <span class="hljs-comment"># 获取对象的属性字典</span><br><span class="hljs-comment"># 输出：&#123;&#x27;instance_attribute&#x27;: &#x27;instance&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>从输出结果可以看出，属性字典中包含了类的所有属性，包括私有属性。同时，属性字典也可以用于获取对象实例中定义的属性。</p><h2 id="2-限制类创建对象的实例属性"><a href="#2-限制类创建对象的实例属性" class="headerlink" title="2.限制类创建对象的实例属性"></a>2.限制类创建对象的实例属性</h2><p>Python中的__slots__属性可以用于限制对象的属性，使对象只能添加在__slots__列表中声明过的实例属性。它的作用主要有两个：</p><ol><li>阻止给对象创建属性字典__dict__，从而节省内存。</li><li>限制对象的属性，避免程序员在不经意间给对象添加新的属性，从而增强程序的安全性和可维护性。</li></ol><p>在使用__slots__时，可以将它声明在类中，其值是一个包含字符串的列表，每个字符串代表一个属性名。在类的实例化过程中，只能为类中__slots__列表中声明的属性名赋值，否则会报AttributeError错误。下面是一个简单的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    __slots__ = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass2</span>:<br>    __slots__ = []<br><br>m = MyClass(<span class="hljs-string">&#x27;musen&#x27;</span>, <span class="hljs-number">18</span>)<br>m2 = MyClass(<span class="hljs-string">&#x27;musen1&#x27;</span>, <span class="hljs-number">118</span>)<br>mm = MyClass2()<br></code></pre></td></tr></table></figure><p>在这个例子中，类<code>MyClass</code>中声明了<code>__slots__</code>属性，包含了两个属性名<code>name</code>和<code>age</code>。类<code>MyClass2</code>中声明了一个空的<code>__slots__</code>属性。在实例化<code>MyClass</code>时，只能为<code>name</code>和<code>age</code>属性赋值。而在实例化<code>MyClass2</code>时，则不受任何限制。</p><p>需要注意的是，<code>__slots__</code>属性只对当前类有效，不会影响父类或子类。另外，使用<code>__slots__</code>可能会对代码的扩展性和维护性带来一些影响，因为类的属性必须在<code>__slots__</code>中声明，所以如果需要添加新的属性，需要修改类的定义。</p><h2 id="3-python中属性访问机制"><a href="#3-python中属性访问机制" class="headerlink" title="3.python中属性访问机制"></a>3.python中属性访问机制</h2><ol><li>Python 中有四个魔术方法与对象的属性相关，分别是 <strong>getattribute</strong>、<strong>setattr</strong>、<strong>delattr</strong> 和 <strong>getattr</strong>；<br>getattribute、setattr、delattr 和 getattr；</li><li><strong>getattribute</strong> 方法在对象访问属性时触发，它能够返回属性的值；</li><li><strong>setattr</strong> 方法在对象设置属性时触发，它能够设置属性的值；</li><li><strong>delattr</strong> 方法在删除对象属性时触发，它能够删除属性；</li><li><strong>getattr</strong> 方法在对象获取不存在的属性时触发，它能够处理不存在的属性。</li></ol><p>以上这些魔术方法都可以重写，以实现对对象属性的特定操作。例如，在 <strong>setattr</strong> 方法中，可以对设置的属性值进行检查和过滤。</p><p>代码中的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        对象访问属性触发的魔术方法</span><br><span class="hljs-string">        :param item: 属性名</span><br><span class="hljs-string">        :return: 属性值</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__getattribute__(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        对象设置属性触发的魔术方法</span><br><span class="hljs-string">        :param key: 属性名</span><br><span class="hljs-string">        :param value: 属性值</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-built_in">super</span>().__setattr__(key, value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        删除对象属性触发的魔术方法</span><br><span class="hljs-string">        :param item: 要删除的属性名</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-built_in">super</span>().__delattr__(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        对象获取属性，属性不存在时触发的魔术方法</span><br><span class="hljs-string">        :param item:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span><br><br>m = MyTest(<span class="hljs-string">&#x27;musen&#x27;</span>, <span class="hljs-number">18</span>)<br><br><span class="hljs-comment"># 动态设置属性</span><br><span class="hljs-built_in">setattr</span>(m, <span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-number">100</span>)<br><span class="hljs-built_in">setattr</span>(m, <span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-number">200</span>)<br><span class="hljs-built_in">print</span>(m.__dict__)<br><br><span class="hljs-comment"># 访问属性</span><br><span class="hljs-built_in">print</span>(m.name)  <span class="hljs-comment"># m.name  ===&gt; m.__getattribute__(&#x27;name&#x27;)</span><br><br><span class="hljs-comment"># 删除属性</span><br><span class="hljs-keyword">del</span> m.name<br><span class="hljs-built_in">print</span>(m.__dict__)<br><br><span class="hljs-comment"># 获取不存在的属性</span><br><span class="hljs-built_in">print</span>(m.py)<br></code></pre></td></tr></table></figure><h2 id="4-属性管理的案例"><a href="#4-属性管理的案例" class="headerlink" title="4.属性管理的案例"></a>4.属性管理的案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDemo</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> key == <span class="hljs-string">&#x27;id&#x27;</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">and</span> value &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">super</span>().__setattr__(key, value)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">&#x27;id属性只能设置为int类型，并且值大于0&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-string">&#x27;datas&#x27;</span>:<br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-string">&#x27;name&#x27;</span>:<br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">super</span>().__setattr__(key, value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">or</span> item == <span class="hljs-string">&#x27;datas&#x27;</span>:<br>            <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">&#x27;属性&#123;&#125;不能删除&#x27;</span>.<span class="hljs-built_in">format</span>(item))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">super</span>().__delattr__(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;name&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;新用例&#x27;</span><br>        <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">&#x27;对象没有&#123;&#125;属性&#x27;</span>.<span class="hljs-built_in">format</span>(item))<br><br><br>m2 = MyDemo()<br><br>m2.<span class="hljs-built_in">id</span> = <span class="hljs-number">999</span><br>m2.datas = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><br><span class="hljs-built_in">print</span>(m2.__dict__)<br><span class="hljs-built_in">print</span>(m2.name)<br></code></pre></td></tr></table></figure><p>在Python中，我们可以使用__setattr__、__getattr__和__delattr__魔术方法来自定义类的属性设置、获取和删除操作。</p><p>在上面的代码中，我们定义了一个MyDemo类，该类具有id、datas和name三个属性。在__setattr__方法中，我们对id属性的值进行了类型和值范围的限制，并且对datas和name属性不做限制。对于其他属性，我们调用了父类的__setattr__方法进行默认处理。</p><p>在__delattr__方法中，我们限制了对id和datas属性的删除，并对其他属性调用了父类的__delattr__方法。</p><p>在__getattr__方法中，如果获取的是name属性并且该属性没有值，则返回’新用例’，否则抛出AttributeError异常。</p><p>总之，使用这些魔术方法，我们可以对类的属性进行更加精细的控制，从而确保数据的完整性和安全性</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入了解Python中的魔术方法</title>
    <link href="/2020/04/05/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
    <url>/2020/04/05/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="深入了解Python中的魔术方法"><a href="#深入了解Python中的魔术方法" class="headerlink" title="深入了解Python中的魔术方法"></a>深入了解Python中的魔术方法</h1><h2 id="1-魔术方法介绍"><a href="#1-魔术方法介绍" class="headerlink" title="1.魔术方法介绍"></a>1.魔术方法介绍</h2><p>在Python中，魔术方法（Magic Methods），也称为双下划线方法（dunder methods），是一种特殊的方法，用于在类定义中实现特殊的行为。这些方法的名称都以两个下划线（__）开头和结尾，比如 <code>__init__</code>、<code>__str__</code>、<code>__repr__</code> 等等。</p><p>Python的魔术方法可以实现类似于操作符重载、属性访问控制、对象创建与销毁等特殊功能，以及一些高级编程技巧，比如上下文管理器、迭代器等。</p><p>当我们在类中定义了某个魔术方法时，Python会在特定的时机自动调用该方法，从而实现预期的功能。例如，在创建对象时，Python会自动调用 <code>__init__</code> 方法来初始化对象；在使用 <code>print</code> 函数打印对象时，Python会自动调用 <code>__str__</code> 方法来返回字符串表示。</p><p>总之，Python的魔术方法是一种非常强大的功能，可以大大增强类的灵活性和可定制性，也是 Python 面向对象编程的重要基础</p><h2 id="2-new方法"><a href="#2-new方法" class="headerlink" title="2.new方法"></a>2.new方法</h2><p>Python 中，每个类都有一个名为 <strong>new</strong> 的特殊方法。在创建一个新的实例时，<strong>new</strong> 方法会被首先调用，用于创建并返回实例对象。然后，<strong>init</strong> 方法会被调用，用于对新创建的对象进行初始化。在这篇博客中，我们将详细介绍 <strong>new</strong> 方法的使用。</p><h3 id="什么是-new-方法？"><a href="#什么是-new-方法？" class="headerlink" title="什么是 new 方法？"></a>什么是 <strong>new</strong> 方法？</h3><p><strong>new</strong> 方法是 Python 中的一个特殊方法，用于创建类的实例对象。与常规的实例方法不同，<strong>new</strong> 方法是一个类方法，因此应该接收类作为第一个参数。</p><p><strong>new</strong> 方法通常被用于一下几种情况：</p><ul><li>控制实例的创建过程</li><li>返回已有对象的引用</li><li>子类化不可变类型</li></ul><h3 id="如何使用-new-方法"><a href="#如何使用-new-方法" class="headerlink" title="如何使用 new 方法"></a>如何使用 <strong>new</strong> 方法</h3><p><strong>new</strong> 方法必须返回一个实例对象。如果 <strong>new</strong> 方法返回的是其他类型的对象，那么该方法会被忽略，直接调用 <strong>init</strong> 方法进行初始化。如果 <strong>new</strong> 方法返回的是类的实例对象，那么该对象会被传递给 <strong>init</strong> 方法进行初始化。</p><p>下面是一个简单的例子，演示如何在 <strong>new</strong> 方法中创建实例对象：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby">pythonCopy code<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        instance = <span class="hljs-variable language_">super</span>().__new__(cls)<br>        instance.value = args[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> instance<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>obj = <span class="hljs-title class_">MyClass</span>(<span class="hljs-number">123</span>)<br>print(obj.value)  <span class="hljs-comment"># 123</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们重写了 <strong>new</strong> 方法，在创建新的实例对象时，将传入的参数 value 赋值给实例对象的属性。然后，在 <strong>init</strong> 方法中，我们再次将 value 赋值给实例对象的属性。最终，实例对象的 value 属性的值应该是 123。</p><h3 id="new-方法与-init-方法的区别"><a href="#new-方法与-init-方法的区别" class="headerlink" title="new 方法与 init 方法的区别"></a><strong>new</strong> 方法与 <strong>init</strong> 方法的区别</h3><p>Python 中每个类都有两个特殊的方法：<strong>new</strong> 和 <strong>init</strong>。这两个方法都是用于创建类的实例对象。但是，它们在实现细节和用途上有所不同。</p><p><strong>new</strong> 方法是一个类方法，用于创建并返回实例对象。它的主要作用是控制实例对象的创建过程。通常情况下，我们不需要自己实现 <strong>new</strong> 方法，因为 Python 提供的默认实现已经足够满足大多数需求。</p><p><strong>init</strong> 方法是一个实例方法，用于对新创建的对象进行初始化。它的主要作用是设置实例对象的属性。通常情况下，我们需要重写 <strong>init</strong> 方法，以便在对象创建时初始化一些属性。</p><h2 id="3-new方法的使用场景和单例模式"><a href="#3-new方法的使用场景和单例模式" class="headerlink" title="3.new方法的使用场景和单例模式"></a>3.new方法的使用场景和单例模式</h2><p>在Python中，<code>__new__</code>方法是一个特殊的方法，用于创建类的新实例。它在<code>__init__</code>方法之前被调用，用于创建对象并返回该对象的实例。<code>__new__</code>方法通常用于控制对象的创建过程，比如单例模式，对象池等场景。</p><p>单例模式是一种常用的设计模式，它确保类只有一个实例，并提供了对该实例的全局访问点。在Python中，可以使用<code>__new__</code>方法来实现单例模式。具体做法是，在<code>__new__</code>方法中，判断类是否已经创建过实例对象，如果没有，创建一个新的实例对象，并把该实例对象保存在类属性中，以后再创建对象时，直接返回保存的实例对象即可。</p><p>以下是使用<code>__new__</code>方法实现单例模式的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __instance = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls.__instance:<br>            cls.__instance = <span class="hljs-built_in">super</span>().__new__(cls, *args, **kwargs)<br>        <span class="hljs-keyword">return</span> cls.__instance<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Singleton</code>类只有一个实例对象。当第一次调用<code>Singleton()</code>时，<code>__new__</code>方法被调用，创建一个新的实例对象，并将它保存在类属性<code>__instance</code>中。以后再调用<code>Singleton()</code>时，直接返回保存的实例对象即可。</p><p>总结一下，<code>__new__</code>方法是Python中一个非常重要的特殊方法，用于创建类的新实例。它可以用于控制对象的创建过程，例如实现单例模式，对象池等场景。</p><p>4.call方法<br><code>__call__</code> 方法是 Python 中的一个魔术方法，用于让实例对象能够像函数一样被调用。如果一个类实现了 <code>__call__</code> 方法，那么这个类的实例对象可以被当做函数来使用，通过在对象后面加括号的方式调用，就会自动触发 <code>__call__</code> 方法。</p><p>下面是 <code>__call__</code> 方法的代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCreateFunction</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----call方法执行了----&quot;</span>)<br><br><br>musen = MyCreateFunction()<br>musen()<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个 <code>MyCreateFunction</code> 类，然后在这个类中实现了 <code>__call__</code> 方法，当 <code>musen()</code> 被调用时，实际上是触发了 <code>musen</code> 实例对象的 <code>__call__</code> 方法，于是我们就可以在 <code>__call__</code> 方法中实现任何我们希望对象被调用时执行的逻辑。注意，在这里我们使用 <code>callable()</code> 函数检查了函数和对象是否可调用。</p><p>总的来说，<code>__call__</code> 方法可以让我们把一个类的实例对象像函数一样使用，这对于一些特定的场景（如函数装饰器）非常有用。</p><h2 id="4-call方法应用的类实现装饰器"><a href="#4-call方法应用的类实现装饰器" class="headerlink" title="4.call方法应用的类实现装饰器"></a>4.call方法应用的类实现装饰器</h2><p>当我们想要在函数执行前后添加一些额外的功能，或者对函数进行修改时，我们通常会使用装饰器。装饰器是一种函数或类，它可以接受一个函数作为参数，并返回一个新的函数或类，新的函数或类具有扩展的功能或者对原函数进行修改。</p><p>类装饰器是一种使用类来实现装饰器的方法。类装饰器使用了类的 <strong>call</strong> 方法。当我们将一个类作为装饰器时，Python 会自动调用这个类的 <strong>call</strong> 方法。这个方法将被用来装饰一个函数，然后返回一个新的函数。这个新的函数将会替换原来的函数。</p><p>下面，我们将会展示两个使用类装饰器的例子，一个是用来实现装饰器的类的例子，另一个是用来实现数据驱动测试的例子。</p><h4 id="示例1：装饰器类的使用"><a href="#示例1：装饰器类的使用" class="headerlink" title="示例1：装饰器类的使用"></a>示例1：装饰器类的使用</h4><p>我们可以定义一个类，将需要装饰的函数作为参数传递给这个类，然后在这个类的 <strong>call</strong> 方法中添加额外的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---装饰器扩展的功能代码1---&quot;</span>)<br>        res = self.func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---装饰器扩展的功能代码2---&quot;</span>)<br>        <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-meta">@Decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----功能函数work--------&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">9999</span><br><br><br>res = work()<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个类 Decorator，它接收一个函数作为参数，然后在 <strong>call</strong> 方法中添加了额外的功能。我们将这个类应用到函数 work 上，使用 @Decorator 装饰器来实现。当我们调用 work() 函数时，它将会先执行 <strong>call</strong> 方法中的代码，然后再执行原函数。</p><h4 id="示例2：数据驱动测试的实现"><a href="#示例2：数据驱动测试的实现" class="headerlink" title="示例2：数据驱动测试的实现"></a>示例2：数据驱动测试的实现</h4><p>我们可以定义一个类，将需要装饰的函数作为参数传递给这个类，然后在这个类的 <strong>call</strong> 方法中添加数据驱动测试的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args</span>):<br>        self.data = args<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, func, *args, **kwargs</span>):<br>        func.DATA = self.data<br>        <span class="hljs-keyword">return</span> func<br><br><br><span class="hljs-meta">@Data(<span class="hljs-params"><span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----功能函数work--------&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">9999</span><br><br><br><span class="hljs-built_in">print</span>(work.DATA)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个类 Data，它接收一个数据列表作为参数，然后在 <strong>call</strong> 方法中将这个数据列表附加到函数对象上。我们将这个类应用到函数 work 上，使用 @Data 装饰器来实现。当我们调用 work() 函数时，它将会输出数据列表。</p><h2 id="5-上下文管理器协议"><a href="#5-上下文管理器协议" class="headerlink" title="5.上下文管理器协议"></a>5.上下文管理器协议</h2><p>Python的上下文管理协议(Context Management Protocol)是一种用于在资源分配和释放时，自动执行特定代码的协议。在Python中，上下文管理器（Context Manager）是一个对象，它定义了在进入和退出代码块时要执行的操作。上下文管理器可以使用Python的with语句来使用，以确保资源被正确分配和释放。在with语句块结束时，Python会自动调用上下文管理器的__exit__方法。</p><p>上下文管理器必须实现__enter__和__exit__两个方法。__enter__方法在进入with语句块时调用，并返回一个可供使用的对象，__exit__方法在with语句块执行结束后自动调用，用于释放资源。</p><p>以下是一个使用上下文管理器的简单示例，实现了打开和关闭文件的自动化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenFile</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, file_name, mode</span>):<br>        self.file_name = file_name<br>        self.mode = mode<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        self.file = <span class="hljs-built_in">open</span>(self.file_name, self.mode)<br>        <span class="hljs-keyword">return</span> self.file<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):<br>        self.file.close()<br><br><br><span class="hljs-keyword">with</span> OpenFile(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，OpenFile是一个上下文管理器，__enter__方法打开文件并返回一个文件对象，__exit__方法关闭文件。</p><p>使用with语句调用OpenFile时，会执行以下操作：</p><ol><li>调用OpenFile的__enter__方法，打开文件并返回文件对象。</li><li>with语句块中使用文件对象写入数据。</li><li>with语句块执行完毕后，调用OpenFile的__exit__方法，关闭文件。</li></ol><p>如果在with语句块中发生异常，Python会自动调用__exit__方法，用于释放资源。</p><p>上下文管理器可以大大简化资源管理的过程，特别是在使用文件、网络连接等需要手动释放的资源时。使用with语句管理资源时，可以避免遗漏释放资源的情况，也可以提高代码的可读性和可维护性。</p><p>除了自定义上下文管理器外，Python还提供了一些内置的上下文管理器，比如在文件操作时使用的open函数，使用with语句块自动关闭文件。另外，Python的标准库中还有一些模块，如contextlib和threading等，提供了许多有用的上下文管理器。</p><p>6.str方法魔术方法 <code>__str__</code> 是一个用于自定义对象在转换为字符串时的输出形式的方法。在使用 <code>print</code> 函数或是将对象转换为字符串时，Python 解释器会自动调用该方法并将其返回值作为字符串输出。</p><p>以下是一个示例代码，其中定义了一个 <code>Person</code> 类，并在其 <code>__str__</code> 方法中自定义了输出的字符串形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Person(name=<span class="hljs-subst">&#123;self.name&#125;</span>, age=<span class="hljs-subst">&#123;self.age&#125;</span>)&quot;</span><br><br><br>p = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>)<br><span class="hljs-built_in">print</span>(p)  <span class="hljs-comment"># 输出：Person(name=Alice, age=30)</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>__str__</code> 方法中返回了一个格式化字符串，其中包含了该对象的两个属性 <code>name</code> 和 <code>age</code>。在调用 <code>print</code> 函数时，Python 解释器会自动调用 <code>p</code> 对象的 <code>__str__</code> 方法并将其返回值输出。</p><p>需要注意的是，<code>__str__</code> 方法返回的字符串应该尽量简洁清晰，并且不应包含任何详细的实现细节，因为它的主要作用是为了方便开发者调试和输出信息。</p><p>另外，如果一个对象同时定义了 <code>__str__</code> 和 <code>__repr__</code> 方法，那么在使用 <code>print</code> 函数时将会调用 <code>__str__</code> 方法，而在使用 <code>repr</code> 函数时将会调用 <code>__repr__</code> 方法。</p><h2 id="6-运算符对应的魔术方法"><a href="#6-运算符对应的魔术方法" class="headerlink" title="6.运算符对应的魔术方法"></a>6.运算符对应的魔术方法</h2><p>在 Python 中，运算符都有对应的魔术方法（Magic Methods），这些方法以双下划线 __ 开头和结尾。这些方法可以用于自定义对象的行为，使其支持各种运算符操作。</p><p>以下是常用运算符和对应的魔术方法：</p><ul><li>算术运算符：<ul><li>加法 (+)：<strong>add</strong></li><li>减法 (-)：<strong>sub</strong></li><li>乘法 (<em>)：*<em>mul</em></em></li><li>除法 (&#x2F;)：<strong>truediv</strong></li><li>取整除 (&#x2F;&#x2F;)：<strong>floordiv</strong></li><li>模运算 (%)：<strong>mod</strong></li><li>幂运算 (**): <strong>pow</strong></li></ul></li><li>比较运算符：<ul><li>等于 (&#x3D;&#x3D;)：<strong>eq</strong></li><li>不等于 (!&#x3D;)：<strong>ne</strong></li><li>大于 (&gt;)：<strong>gt</strong></li><li>小于 (&lt;)：<strong>lt</strong></li><li>大于等于 (&gt;&#x3D;)：<strong>ge</strong></li><li>小于等于 (&lt;&#x3D;)：<strong>le</strong></li></ul></li><li>位运算符：<ul><li>按位与 (&amp;)：<strong>and</strong></li><li>按位或 (|)：<strong>or</strong></li><li>按位异或 (^)：<strong>xor</strong></li><li>按位取反 (~)：<strong>invert</strong></li><li>左移 (&lt;&lt;)：<strong>lshift</strong></li><li>右移 (&gt;&gt;)：<strong>rshift</strong></li></ul></li><li>布尔运算符：<ul><li>与 (and)：<strong>and</strong></li><li>或 (or)：<strong>or</strong></li><li>非 (not)：<strong>not</strong></li></ul></li></ul><p>以下是一些示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个自定义的向量类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x<br>        self.y = y<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.x + other.x, self.y + other.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__sub__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.x - other.x, self.y - other.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self, scalar</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.x * scalar, self.y * scalar)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.x == other.x <span class="hljs-keyword">and</span> self.y == other.y<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;(<span class="hljs-subst">&#123;self.x&#125;</span>, <span class="hljs-subst">&#123;self.y&#125;</span>)&quot;</span><br><br><span class="hljs-comment"># 测试向量类的运算符方法</span><br>v1 = Vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>v2 = Vector(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>v3 = v1 + v2<br>v4 = v2 - v1<br>v5 = v1 * <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(v3)  <span class="hljs-comment"># 输出 (4, 6)</span><br><span class="hljs-built_in">print</span>(v4)  <span class="hljs-comment"># 输出 (2, 2)</span><br><span class="hljs-built_in">print</span>(v5)  <span class="hljs-comment"># 输出 (2, 4)</span><br><span class="hljs-built_in">print</span>(v1 == Vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 输出 True</span><br><span class="hljs-built_in">print</span>(v1 == Vector(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 输出 False</span><br></code></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个自定义的向量类 Vector，实现了加法、减法、乘法、相等和字符串表示等运算符的魔术方法。这些方法使得我们可以像使用内置类型一样使用自定义对象，实现了更自然的语法和行为。</p><p>7.容器相关的魔术方法</p><p>Python中的容器是指可以包含其他对象的对象，例如列表、元组、集合和字典等。这些容器可以使用一些特殊的魔术方法来实现其行为。下面我们将介绍一些与容器相关的魔术方法以及它们的作用。</p><ol><li><code>__len__(self)</code>: 返回容器中元素的数量。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items)<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_list))  <span class="hljs-comment"># 输出：4</span><br></code></pre></td></tr></table></figure><ol><li><code>__getitem__(self, index)</code>: 获取容器中指定位置的元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-keyword">return</span> self.items[index]<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(my_list[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 输出：1</span><br></code></pre></td></tr></table></figure><ol><li><code>__setitem__(self, index, value)</code>: 设置容器中指定位置的元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, index, value</span>):<br>        self.items[index] = value<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>my_list[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(my_list[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 输出：5</span><br></code></pre></td></tr></table></figure><ol><li><code>__delitem__(self, index)</code>: 删除容器中指定位置的元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-keyword">del</span> self.items[index]<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-keyword">del</span> my_list[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(my_list[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 输出：2</span><br></code></pre></td></tr></table></figure><ol><li><code>__contains__(self, item)</code>: 判断容器中是否包含指定元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> item <span class="hljs-keyword">in</span> self.items<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> my_list)  <span class="hljs-comment"># 输出：True</span><br></code></pre></td></tr></table></figure><ol><li><code>__iter__(self)</code>: 返回一个迭代器对象。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self.items)<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(item)  <span class="hljs-comment"># 输出：1 2 3 4</span><br></code></pre></td></tr></table></figure><ol><li><code>__reversed__(self)</code>: 返回一个反向迭代器对象。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reversed__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reversed</span>(self.items)<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(my_list):<br>    <span class="hljs-built_in">print</span>(item)  <span class="hljs-comment"># 输出：4 3 2 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python类属性的动态管理</title>
    <link href="/2020/03/31/Python%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <url>/2020/03/31/Python%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Python类属性的动态管理"><a href="#Python类属性的动态管理" class="headerlink" title="Python类属性的动态管理"></a>Python类属性的动态管理</h1><p>Python 是一门支持动态语言特性的语言，其中类属性动态管理是其中的一种。Python 允许在运行时对类和对象的属性进行动态的增加、删除和修改，这样可以增强代码的灵活性，使程序可以更好地适应不同的需求。</p><p>在 Python 中，动态管理类属性的方法包括：<code>delattr()</code>、<code>getattr()</code>、<code>hasattr()</code> 和 <code>setattr()</code>。</p><p><code>delattr()</code> 方法可以删除类的某个属性。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">delattr</span>(MyClass, <span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-comment"># 删除 MyClass 类的属性 a</span><br></code></pre></td></tr></table></figure><p><code>getattr()</code> 方法可以获取类的某个属性。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">attr = <span class="hljs-built_in">getattr</span>(MyClass, <span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-comment"># 获取 MyClass 类的属性 a</span><br></code></pre></td></tr></table></figure><p><code>hasattr()</code> 方法可以判断类是否有某个属性。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;a&#x27;</span>):  <span class="hljs-comment"># 判断 MyClass 类是否有属性 a</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MyClass has attribute a&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>setattr()</code> 方法可以动态地为类添加属性。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">setattr</span>(MyClass, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">300</span>)  <span class="hljs-comment"># 为 MyClass 类添加属性 c</span><br></code></pre></td></tr></table></figure><p>除了对类属性进行动态管理，我们还可以对类的方法进行动态管理。方法也是类的属性，只不过是可调用的属性。例如，我们可以在运行时为一个类添加一个方法，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">setattr</span>(MyClass, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-keyword">lambda</span> self: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>))<br></code></pre></td></tr></table></figure><p>然后我们可以在对象上调用这个新添加的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = MyClass()<br>obj.test()  <span class="hljs-comment"># 输出 &quot;Hello, world!&quot;</span><br></code></pre></td></tr></table></figure><p>类属性的动态管理使得 Python 代码具有了更高的灵活性，可以更好地适应各种需求。但是，这种灵活性也容易导致代码的可读性和可维护性下降，因此在使用时需要慎重考虑。</p><p>四、setattr()方法</p><p><code>setattr()</code>方法用于给类添加属性或方法，其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">setattr</span>(<span class="hljs-built_in">object</span>, name, value)<br></code></pre></td></tr></table></figure><ul><li>object：必选参数，表示要添加属性或方法的类。</li><li>name：必选参数，表示要添加的属性或方法名。 姓名：</li><li>value：必选参数，表示要添加的属性或方法值。 价值：</li></ul><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 给类动态添加属性</span><br><span class="hljs-built_in">setattr</span>(MyClass, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>)<br><span class="hljs-built_in">setattr</span>(MyClass, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 给类动态添加方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br><span class="hljs-built_in">setattr</span>(MyClass, <span class="hljs-string">&#x27;say_hello&#x27;</span>, func)<br><br><span class="hljs-comment"># 测试</span><br>m = MyClass()<br><span class="hljs-built_in">print</span>(m.name, m.age)  <span class="hljs-comment"># 输出 &#x27;Tom 20&#x27;</span><br>m.say_hello()  <span class="hljs-comment"># 输出 &#x27;hello world&#x27;</span><br></code></pre></td></tr></table></figure><p>五、delattr()方法</p><p><code>delattr()</code>方法用于删除类的属性或方法，其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">delattr</span>(<span class="hljs-built_in">object</span>, name)<br></code></pre></td></tr></table></figure><ul><li>object：必选参数，表示要删除属性或方法的类。 对象：必</li><li>name：必选参数，表示要删除的属性或方法名。 姓名：</li></ul><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除类属性</span><br><span class="hljs-built_in">delattr</span>(MyClass, <span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-built_in">print</span>(MyClass.__dict__)<br><br><span class="hljs-comment"># 删除类方法</span><br><span class="hljs-built_in">delattr</span>(MyClass, <span class="hljs-string">&#x27;demo&#x27;</span>)<br><span class="hljs-built_in">print</span>(MyClass.__dict__)<br></code></pre></td></tr></table></figure><p>六、hasattr()方法</p><p><code>hasattr()</code>方法用于判断类是否拥有某个属性或方法，其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">hasattr</span>(<span class="hljs-built_in">object</span>, name)<br></code></pre></td></tr></table></figure><ul><li>object：必选参数，表示要检查属性或方法的类。 目的：</li><li>name：必选参数，表示要检查的属性或方法名。 姓名：必</li></ul><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 判断类是否拥有某个属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;a&#x27;</span>))  <span class="hljs-comment"># 输出 False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;name&#x27;</span>))  <span class="hljs-comment"># 输出 True</span><br><br><span class="hljs-comment"># 判断类是否拥有某个方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;demo&#x27;</span>))  <span class="hljs-comment"># 输出 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;test_01&#x27;</span>))  <span class="hljs-comment"># 输出 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;say_hello&#x27;</span>))  <span class="hljs-comment"># 输出 True</span><br></code></pre></td></tr></table></figure><p>七、总结</p><p>类属性的动态管理可以让我们在运行时动态地修改类的属性和方法，这样就可以让代码更加灵活和可扩展。通过<code>setattr()</code>方法和<code>delattr()</code>方法，我们可以方便地添加或删除类的属性或方法。通过<code>getattr()</code>方法和<code>hasattr()</code>方法，我们可以判断类是否拥有某个属性或方法，并动态地获取该属性或方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级Python编程技巧之装饰器：让你的代码更灵活、更强大(二)</title>
    <link href="/2020/03/26/%E9%AB%98%E7%BA%A7Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E3%80%81%E6%9B%B4%E5%BC%BA%E5%A4%A7(%E4%BA%8C)/"/>
    <url>/2020/03/26/%E9%AB%98%E7%BA%A7Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E3%80%81%E6%9B%B4%E5%BC%BA%E5%A4%A7(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="高级Python编程技巧之装饰器：让你的代码更灵活、更强大-二"><a href="#高级Python编程技巧之装饰器：让你的代码更灵活、更强大-二" class="headerlink" title="高级Python编程技巧之装饰器：让你的代码更灵活、更强大(二)"></a>高级Python编程技巧之装饰器：让你的代码更灵活、更强大(二)</h1><h2 id="1-装饰器装饰类"><a href="#1-装饰器装饰类" class="headerlink" title="1.装饰器装饰类"></a>1.装饰器装饰类</h2><p>Python中，我们可以使用装饰器来对类进行装饰，以扩展类的功能或改变类的行为。下面是详细介绍Python如何用装饰器装饰类的步骤：</p><p>1.定义装饰器函数</p><p>我们首先需要定义一个装饰器函数，该函数接收一个类对象作为参数，并返回一个新的类对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">cls</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-comment"># 扩展代码</span><br>        res = cls(*args, **kwargs)<br>        <span class="hljs-comment"># 扩展代码</span><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>上述代码中，我们定义了一个装饰器函数<code>decorator</code>，它的作用是在类的构造函数执行前后加入一些扩展代码，并返回一个新的类对象。其中，<code>wrapper</code>函数作为装饰器的内部函数，用于执行扩展代码，并返回原类的实例对象。</p><p>2.使用装饰器修饰类</p><p>接下来，我们需要使用装饰器语法来修饰目标类，使其受到装饰器函数的影响。具体来说，我们可以使用<code>@</code>符号来修饰类，并将装饰器函数作为参数传入。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>上述代码中，我们使用装饰器<code>decorator</code>对<code>MyClass</code>类进行装饰。当我们实例化<code>MyClass</code>的对象时，实际上会执行装饰器函数<code>decorator</code>，并返回一个新的类对象。</p><p>3.使用装饰后的类</p><p>最后，我们可以使用装饰后的类来创建对象，并使用其中的方法和属性。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_obj = MyClass()<br>my_obj.some_method()<br></code></pre></td></tr></table></figure><p>上述代码中，我们创建了一个<code>MyClass</code>类的实例对象<code>my_obj</code>，并调用其中的方法<code>some_method()</code>。当调用该方法时，实际上会执行经过装饰器函数<code>decorator</code>扩展后的新类对象的方法。</p><p>总结：</p><p>使用装饰器对类进行装饰是Python中一种常见的编程技巧，它可以在不改变原有代码的基础上，对类的功能和行为进行扩展和改变。在实际开发中，我们可以利用装饰器对类进行扩展，使得代码更加简洁、灵活和易于维护。</p><h2 id="2-普通函数作为装饰器"><a href="#2-普通函数作为装饰器" class="headerlink" title="2.普通函数作为装饰器"></a>2.普通函数作为装饰器</h2><p>装饰器定义的常见形式：<br>    一、闭包实现的装饰器：<br>       适用场景：一般用于在原功能函数&#x2F;类的基础上做功能扩展</p><p>二、普通的函数实现的装饰器：<br>    适用场景：一般用于给被装饰的函数&#x2F;类，动态去添加或修改属性</p><p>三、类实现的装饰器(下次课讲)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    func.name = <span class="hljs-string">&#x27;musen&#x27;</span><br>    <span class="hljs-keyword">return</span> func`<br><br><br><span class="hljs-meta">@decorator  </span><span class="hljs-comment"># work = decorator(work)`</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------work---------&quot;</span>)<br><br><span class="hljs-built_in">print</span>(work.name)<br></code></pre></td></tr></table></figure><h2 id="3-functools模块中内置的装饰器"><a href="#3-functools模块中内置的装饰器" class="headerlink" title="3.functools模块中内置的装饰器"></a>3.functools模块中内置的装饰器</h2><p><code>functools</code> 模块是 Python 标准库中的一个模块，主要提供一些高阶函数（higher-order functions）和操作函数对象（callable objects）的工具。其中包含一些内置的装饰器，可以帮助我们实现一些常用的功能，例如缓存函数、包装函数等。</p><p>下面是 <code>functools</code> 模块中常用的内置装饰器的介绍：</p><ol><li><code>lru_cache()</code>：该装饰器用于缓存函数的结果，避免重复计算。该装饰器会创建一个 LRU（Least Recently Used）缓存，将函数的参数和结果作为键值对存储起来，当函数被再次调用时，如果参数在缓存中已经有对应的结果，则直接返回缓存中的结果，否则计算新结果并将其存入缓存中。该装饰器的一个常见应用场景是加速递归函数，将其转换为迭代函数。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-meta">@functools.lru_cache(<span class="hljs-params">maxsize=<span class="hljs-number">128</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><ol><li><code>wraps()</code>：该装饰器用于将被装饰函数的元信息（比如函数名、参数列表、文档字符串等）复制到装饰器函数中，避免因装饰器而改变函数的元信息。该装饰器通常与其他装饰器一起使用。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Before the function is called.&quot;</span>)<br>        func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After the function is called.&quot;</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;A simple function that greets the user.&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span>)<br>    <br><span class="hljs-built_in">print</span>(say_hello.__name__)  <span class="hljs-comment"># 输出：&#x27;say_hello&#x27;</span><br><span class="hljs-built_in">print</span>(say_hello.__doc__)   <span class="hljs-comment"># 输出：&#x27;A simple function that greets the user.&#x27;</span><br></code></pre></td></tr></table></figure><ol><li><code>partial()</code>：该函数用于部分应用（partial application）一个函数的参数，返回一个新的函数对象。部分应用是指将一个函数的某些参数固定下来，返回一个新的函数对象，这个新函数对象调用时不再需要提供那些已经被固定的参数，而是只需要提供剩余的参数。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x * y<br><br><span class="hljs-comment"># 固定第一个参数为2</span><br>double = functools.partial(multiply, <span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">print</span>(double(<span class="hljs-number">3</span>))   <span class="hljs-comment"># 输出：6</span><br><span class="hljs-built_in">print</span>(double(<span class="hljs-number">4</span>))   <span class="hljs-comment"># 输出：8</span><br></code></pre></td></tr></table></figure><p>以上是 <code>functools</code> 模块中常用的内置装饰器的介绍，它们提供了很多有用的功能，可以让我们更方便地编写 Python 函数。</p><h2 id="4-多个装饰器装饰一个函数"><a href="#4-多个装饰器装饰一个函数" class="headerlink" title="4.多个装饰器装饰一个函数"></a>4.多个装饰器装饰一个函数</h2><p>Python中允许我们通过在函数定义之前使用<code>@decorator</code>语法来应用装饰器。当函数被调用时，它们将被装饰器所包装。但是，有时候我们可能需要多个装饰器来装饰一个函数。在这种情况下，多个装饰器会按照装饰器的顺序一层一层地包装函数，从而实现多个装饰器的效果。</p><p>以下是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--demo----&#x27;</span>)<br>    <span class="hljs-keyword">return</span> func<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">musen</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------musen--------&quot;</span>)<br>    <span class="hljs-keyword">return</span> func<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lemon</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---------lemon-----&quot;</span>)<br>    <span class="hljs-keyword">return</span> func<br><br><br><span class="hljs-meta">@demo</span><br><span class="hljs-meta">@lemon</span><br><span class="hljs-meta">@musen  </span><span class="hljs-comment"># work = demo(lemon(musen(work)))</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----work--------&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    work()<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>work</code>函数被<code>@demo</code>、<code>@lemon</code>和<code>@musen</code>三个装饰器装饰。这些装饰器是按照从上到下的顺序执行的。这意味着首先执行<code>musen</code>装饰器，然后是<code>lemon</code>装饰器，最后是<code>demo</code>装饰器。这个顺序是非常重要的，因为装饰器是按照它们的顺序被执行的。</p><p>当<code>work</code>函数被调用时，它会被<code>musen</code>装饰器所包装，然后被<code>lemon</code>装饰器所包装，最后被<code>demo</code>装饰器所包装。这就意味着，当<code>work</code>函数被调用时，它将打印出所有三个装饰器的输出，然后再执行函数本身。</p><p>多个装饰器的顺序是非常重要的，因为它们的执行顺序会影响最终的结果。此外，不同的装饰器可能会有不同的作用，因此要仔细考虑它们的顺序。在使用多个装饰器时，最好使用一些注释来解释它们的作用和顺序，以便更好地理解代码。</p><h2 id="5-装饰器小节总结"><a href="#5-装饰器小节总结" class="headerlink" title="5.装饰器小节总结"></a>5.装饰器小节总结</h2><p>Python中的装饰器是一种高级语言特性，它可以对已有的函数或类进行功能扩展和修改，而无需改变原有函数或类的定义。装饰器本身是一个函数，它接受一个函数作为参数，并返回一个新的函数，通常新函数会在原函数前后执行一些额外的操作，比如记录日志、缓存结果、检查参数等。装饰器可以极大地提高代码的复用性和可维护性，让代码更加简洁、清晰。</p><p>Python中常用的装饰器有三种：</p><p>1.函数装饰器：用于修饰函数，可以在不改变函数定义的情况下增加功能，常见的函数装饰器包括 @property、@staticmethod、@classmethod、@wraps等。</p><p>2.类装饰器：用于修饰类，可以在不改变类定义的情况下增加功能，常见的类装饰器包括 @singleton、@contextmanager等。</p><p>3.方法装饰器：用于修饰类的方法，可以在不改变方法定义的情况下增加功能，常见的方法装饰器包括 @classmethod、@staticmethod、@property等。</p><p>Python标准库中提供了一个 functools 模块，其中包括一些内置的装饰器函数，如 lru_cache、singledispatch、wraps 等，这些装饰器函数可以帮助我们快速实现一些常见的装饰器功能，同时还可以提高代码的效率和可读性。</p><p>需要注意的是，装饰器虽然可以提高代码的可复用性和可维护性，但过多的装饰器也可能会导致代码过于复杂和难以理解，因此在使用装饰器时需要根据具体情况进行权衡。同时，在编写装饰器时也需要考虑异常处理、函数签名、函数元信息等方面的问题，以确保装饰器的正确性和可靠性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级Python编程技巧之装饰器：让你的代码更灵活、更强大(一)</title>
    <link href="/2020/03/22/%E9%AB%98%E7%BA%A7Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E3%80%81%E6%9B%B4%E5%BC%BA%E5%A4%A7(%E4%B8%80)/"/>
    <url>/2020/03/22/%E9%AB%98%E7%BA%A7Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E3%80%81%E6%9B%B4%E5%BC%BA%E5%A4%A7(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="高级Python编程技巧之装饰器：让你的代码更灵活、更强大-一"><a href="#高级Python编程技巧之装饰器：让你的代码更灵活、更强大-一" class="headerlink" title="高级Python编程技巧之装饰器：让你的代码更灵活、更强大(一)"></a>高级Python编程技巧之装饰器：让你的代码更灵活、更强大(一)</h1><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><p>开放封闭原则是面向对象设计中的一项重要原则，指的是软件实体（如类、模块、函数等）应该对扩展开放，对修改关闭。具体来说，开放封闭原则要求我们设计软件实体时，应该尽量避免修改已有的代码，而是应该通过扩展已有的代码来实现新的功能。</p><p>开放封闭原则的核心思想是通过抽象来实现扩展。在软件设计时，我们应该尽量使用抽象的方式来描述系统的功能和特性，而不是依赖于具体的实现细节。这样，当需要增加新的功能时，只需要增加新的抽象，而不需要修改已有的代码。</p><p>下面举一个简单的例子来说明开放封闭原则的应用。假设我们有一个计算器程序，该程序可以进行加、减、乘、除四种运算。如果我们使用开放封闭原则来设计这个程序，那么我们可以先定义一个抽象的运算接口，该接口包含一个计算方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>然后，我们可以针对每种运算定义一个具体的类，这些类都实现了运算接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 + num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subtract</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 - num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Multiply</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 * num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Divide</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 / num2<br></code></pre></td></tr></table></figure><p>这样，当需要增加新的运算时，只需要定义一个新的类，并实现运算接口即可。这个过程中，我们并没有修改已有的代码，而是通过扩展已有的代码来实现新的功能。</p><p>总之，开放封闭原则是面向对象设计中的一个非常重要的原则，它可以帮助我们设计出具有可扩展性和可维护性的软件系统。在实际应用中，我们应该尽可能地遵守这个原则，从而提高软件系统的可靠性和可用性。</p><h2 id="装饰器的介绍"><a href="#装饰器的介绍" class="headerlink" title="装饰器的介绍"></a>装饰器的介绍</h2><p>Python装饰器是一种特殊的语法，用于在不改变已有函数代码的情况下，为函数添加额外的功能或修改其行为。装饰器常常被用于日志记录、性能分析、输入合法性检查、缓存等场景。</p><h2 id="装饰器的示例代码"><a href="#装饰器的示例代码" class="headerlink" title="装饰器的示例代码"></a>装饰器的示例代码</h2><p>以下是一个简单的装饰器示例代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">def my_decorator(func):<br>    def <span class="hljs-keyword">wrapper</span>():<br>        print(&quot;Before the function is called.&quot;)<br>        func()<br>        print(&quot;After the function is called.&quot;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span><br><br>@my_decorator<br>def say_hello():<br>    print(&quot;Hello!&quot;)<br><br>say_hello()<br></code></pre></td></tr></table></figure><p>在这个示例代码中，我们定义了一个名为<code>my_decorator</code>的装饰器函数，它接受一个函数作为参数，并返回一个新的函数<code>wrapper</code>。这个新函数<code>wrapper</code>在调用原始函数之前和之后都执行了一些额外的代码。我们还使用装饰器语法<code>@my_decorator</code>来装饰<code>say_hello</code>函数，使得它在调用前后分别打印了”Before the function is called.”和”After the function is called.”。</p><h2 id="装饰器的装饰过程"><a href="#装饰器的装饰过程" class="headerlink" title="装饰器的装饰过程"></a>装饰器的装饰过程</h2><p>装饰器在Python中是通过函数或类实现的。在Python中，函数是一等公民，因此可以将函数作为参数传递给另一个函数，并返回一个函数。</p><p>当我们使用装饰器语法将一个函数装饰器应用于另一个函数时，Python会自动调用装饰器函数，并将被装饰函数作为参数传递给它。装饰器函数会在不修改原始函数代码的情况下，返回一个新的函数或类，用于替换原始函数或类。当我们调用经过装饰的函数时，实际上是调用了这个新的函数或类。</p><h2 id="装饰带参数的函数"><a href="#装饰带参数的函数" class="headerlink" title="装饰带参数的函数"></a>装饰带参数的函数</h2><p>在Python中，装饰带参数的函数需要在装饰器函数内部再定义一层函数，该函数用于接收原函数的参数并返回一个新的函数，新的函数才是真正被调用的函数。下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator start&quot;</span>)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator end&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>上述代码中，装饰器<code>decorator</code>定义了一个内部函数<code>wrapper</code>，<code>wrapper</code>接收原函数的参数<code>*args</code>和<code>**kwargs</code>，并在调用原函数前后输出一些信息。注意，在调用原函数时，需要使用<code>*args</code>和<code>**kwargs</code>将参数传递给原函数。在函数执行结束后，返回函数的执行结果。<code>add</code>函数被<code>@decorator</code>装饰，因此在执行<code>add</code>函数时会先执行<code>decorator</code>函数。</p><h2 id="装饰带返回值的函数"><a href="#装饰带返回值的函数" class="headerlink" title="装饰带返回值的函数"></a>装饰带返回值的函数</h2><p>要装饰带返回值的函数，需要在装饰器函数中定义一个内部函数，该函数调用原函数并返回执行结果。下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator start&quot;</span>)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator end&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>上述代码中，<code>add</code>函数返回<code>a + b</code>的结果，在执行完<code>add</code>函数后，将结果赋给变量<code>result</code>。在装饰器<code>decorator</code>中，将原函数执行的结果存储在变量<code>result</code>中，并在执行完装饰器函数后返回该结果。</p><h2 id="通用装饰器的定义"><a href="#通用装饰器的定义" class="headerlink" title="通用装饰器的定义"></a>通用装饰器的定义</h2><p>通用装饰器的定义通常采用闭包的形式，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-comment"># 执行一些前置操作</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Before the function is called.&quot;</span>)<br>        <span class="hljs-comment"># 调用函数或方法</span><br>        result = func(*args, **kwargs)<br>        <span class="hljs-comment"># 执行一些后置操作</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After the function is called.&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>my_decorator</code> 是一个通用装饰器函数，它的参数 <code>func</code> 是一个被装饰的函数或方法。<code>wrapper</code> 是一个内部函数，它接收任意数量的位置参数和关键字参数，然后在调用被装饰的函数前后执行一些操作。</p><p>当一个函数被装饰器装饰时，装饰器实际上会返回 <code>wrapper</code> 函数，而不是原来的函数。这意味着当我们调用被装饰的函数时，实际上是调用了 <code>wrapper</code> 函数，而且这个函数执行了前置操作、调用了原函数、执行了后置操作。</p><p>下面是一个使用通用装饰器的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + name)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;done&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个 <code>say_hello</code> 函数，并用 <code>my_decorator</code> 装饰了它。当我们调用 <code>say_hello</code> 函数时，实际上是调用了装饰器返回的 <code>wrapper</code> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">say_hello(<span class="hljs-string">&quot;Tom&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Before the function <span class="hljs-keyword">is</span> called.<br>Hello, Tom<br>After the function <span class="hljs-keyword">is</span> called.<br></code></pre></td></tr></table></figure><p>上述代码中，我们调用了 <code>say_hello</code> 函数，并将 “Tom” 作为参数传递给它。装饰器在调用 <code>say_hello</code> 函数前后分别打印了 “Before the function is called.” 和 “After the function is called.” 的信息，这说明装饰器在 <code>say_hello</code> 函数的前后执行了一些操作。最后，函数返回了 “done” 这个字符串。</p><p>总的来说，通用装饰器是非常实用的，因为它可以应用于任何函数或方法，而不需要为每个函数都写一个专门的装饰器。同时，通用装饰器也可以方便地扩展和修改，以满足不同的需求。</p><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>在Python中，装饰器也可以接受参数。这种装饰器被称为带参数的装饰器。带参数的装饰器的定义方法与普通的装饰器有所不同，需要再次包装一层。</p><p>下面我们通过示例来详细介绍下Python中的可以传递参数的装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator_with_args</span>(<span class="hljs-params">arg1, arg2, arg3</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decorator with arguments &#123;&#125;, &#123;&#125;, &#123;&#125; called&quot;</span>.<span class="hljs-built_in">format</span>(arg1, arg2, arg3))<br>            func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br></code></pre></td></tr></table></figure><p>上述代码定义了一个带有三个参数的装饰器<code>decorator_with_args</code>，该装饰器用于为函数添加额外的功能，包括在函数执行前后输出一些信息。</p><p>现在我们来使用这个带有参数的装饰器来装饰一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@decorator_with_args(<span class="hljs-params"><span class="hljs-string">&quot;arg1&quot;</span>, <span class="hljs-string">&quot;arg2&quot;</span>, <span class="hljs-string">&quot;arg3&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_function</span>(<span class="hljs-params">arg</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;my_function called with argument:&quot;</span>, arg)<br></code></pre></td></tr></table></figure><p>在这里，我们使用<code>@</code>符号将<code>my_function</code>函数应用到<code>decorator_with_args</code>装饰器上，并传入了三个参数：”arg1”、”arg2”和”arg3”。当我们调用<code>my_function</code>函数时，装饰器会先输出”Decorator with arguments arg1, arg2, arg3 called”，然后再执行函数体。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python内置函数扩展、偏函数和闭包函数</title>
    <link href="/2020/03/18/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E3%80%81%E5%81%8F%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0/"/>
    <url>/2020/03/18/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E3%80%81%E5%81%8F%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python内置函数扩展、偏函数和闭包函数"><a href="#Python内置函数扩展、偏函数和闭包函数" class="headerlink" title="Python内置函数扩展、偏函数和闭包函数"></a>Python内置函数扩展、偏函数和闭包函数</h1><h4 id="1-1、匿名函数"><a href="#1-1、匿名函数" class="headerlink" title="1.1、匿名函数"></a>1.1、匿名函数</h4><p>python中有一种特殊的函数，不需要使用def去事定义，也不用给函数起名字，用过lamda表达式来定义，这种函<br>数叫匿名函数<br>匿名函数格式<br>lambda 参数：表达式（返回值）<br>问题需求:将以下函数改成匿名函数<br>#普通函数<br>def fun1(varl):<br>        return var1<em>2<br>#匿名函数定义后也可以用变量接收保存，但是一般不这样做<br>fun1 &#x3D; lambda var1 : var1</em>2<br>匿名函数的实际应用：匿名函数一般用来定义在表达式简单的函数，使用匿名函数可以简化代码，像上面的map,<br>filter等函数的使用。应用参数：通常用于函数传参时传递函数的场景</p><p>#问题需求一：对下面的列表进行排序（规则：根据列表中每个元素的第二个值的大小进行排序）<br>li &#x3D;[[1, 10,32]，[3， 22,99]，[2, 7,77]]<br>#问题需求二：对下面的列表进行排序（规则：根据元素的name字段的值的大小进行排序）<br>li2 &#x3D;[{‘id’: 1,”name”: 100},{‘id’： 7,”name”: 9},{‘id’: 3,”name”: 1}]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">add2 = <span class="hljs-keyword">lambda</span> a, b: a + b<br>res2 = add2(<span class="hljs-number">33</span>, <span class="hljs-number">44</span>)<br><span class="hljs-built_in">print</span>(res2)<br></code></pre></td></tr></table></figure><p>应用参数：通常用于函数传参是传递函数的场景</p><p>filter过滤器</p><p>map:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># li = [11,3,43,54,5]</span><br><span class="hljs-comment"># li.sort()</span><br><br><span class="hljs-comment"># li = [[11, 2], [1, 21], [93, 7], [87, 0], [23, 6]]</span><br>li = [<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">155</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">178</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">175</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">185</span>&#125;,<br>]<br><span class="hljs-comment"># 根据列表中每个数据的age值大小进行排序</span><br>li.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;height&#x27;</span>])<br><span class="hljs-built_in">print</span>(li)<br></code></pre></td></tr></table></figure><p>eval：</p><p><code>eval()</code>函数是Python的一个内置函数，它可以执行一段字符串形式的Python代码，并返回执行结果。其基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">eval</span>(expression[, <span class="hljs-built_in">globals</span>[, <span class="hljs-built_in">locals</span>]])<br></code></pre></td></tr></table></figure><p>其中，<code>expression</code>是需要执行的Python代码，可以是字符串或者代码对象；<code>globals</code>和<code>locals</code>是可选参数，分别代表全局命名空间和局部命名空间。</p><p><code>eval()</code>函数的作用主要是将字符串形式的Python代码转换成可执行的代码并执行，可以实现一些动态性较强的操作。例如，可以用<code>eval()</code>函数计算一个字符串形式的数学表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">expression = <span class="hljs-string">&quot;2 + 3 * 4&quot;</span><br>result = <span class="hljs-built_in">eval</span>(expression)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出14</span><br></code></pre></td></tr></table></figure><p>还可以通过<code>eval()</code>函数来动态创建Python对象，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">expression = <span class="hljs-string">&quot;&#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;&quot;</span><br>person = <span class="hljs-built_in">eval</span>(expression)<br><span class="hljs-built_in">print</span>(person)  <span class="hljs-comment"># 输出&#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，由于<code>eval()</code>函数可以执行任意字符串形式的Python代码，因此也存在一定的安全风险。如果执行的代码来自于不可信的来源，可能会导致程序受到攻击或者损坏。因此，在使用<code>eval()</code>函数时需要谨慎，尽量避免执行来自不可信的源代码。</p><p>all：</p><p>在Python中，<code>all()</code> 是一个内置函数，用于判断一个可迭代对象中的所有元素是否都为 True。如果是，则返回 True；否则返回 False。</p><p><code>all()</code> 的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">all</span>(iterable)<br></code></pre></td></tr></table></figure><p>其中，<code>iterable</code> 表示一个可迭代对象，如列表、元组、字典、集合等。</p><p><code>all()</code> 的返回值类型为布尔型。</p><p>下面是一个例子，演示如何使用 <code>all()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">lst1 = [<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]<br>lst2 = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br>lst3 = []<br>lst4 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst1)) <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst2)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst3)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst4)) <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p>在上述例子中，<code>all()</code> 分别对四个列表进行判断。<code>lst1</code> 中有一个元素为 False，因此 <code>all(lst1)</code> 的返回值为 False；<code>lst2</code> 中的所有元素都为非零值，因此 <code>all(lst2)</code> 的返回值为 True；<code>lst3</code> 为空列表，因此 <code>all(lst3)</code> 的返回值为 True；<code>lst4</code> 中有一个元素为 0，因此 <code>all(lst4)</code> 的返回值为 False。</p><p>总之，<code>all()</code> 可以判断一个可迭代对象中的所有元素是否都为 True，是编写 Python 程序中很常用的函数之一。</p><p>any:</p><p>在Python中，<code>any()</code>函数是一个内置函数，它用于检查给定可迭代对象中是否至少有一个元素为真值（True），如果至少有一个元素为真，则返回True，否则返回False。</p><p><code>any()</code>函数的语法如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">any</span><span class="hljs-params">(iterable)</span></span><br></code></pre></td></tr></table></figure><p>其中，<code>iterable</code>是一个可迭代对象，比如列表、元组、集合等。</p><p>下面是一个使用<code>any()</code>函数的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(my_list):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;至少有一个元素为True&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;所有元素都为False&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">至少有一个元素为<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>any()</code>函数检查了<code>my_list</code>列表中的所有元素，发现有一个元素为<code>True</code>，于是返回了<code>True</code>。</p><p><code>any()</code>函数非常适合用于检查可迭代对象中是否存在某个条件的元素，它可以帮助我们编写更加简洁和优雅的代码。</p><p>zip:</p><p><code>zip</code>是Python内置的一个函数，它接受任意多个（包括0个和1个）序列作为参数，返回一个由各个序列中的相同位置的元素组成的元组的迭代器。可以将多个序列进行配对，并同时迭代处理，这个过程类似于拉链的作用，因此也常被称为“拉链函数”。</p><p><code>zip</code>函数的基本语法格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">zip</span>(*iterables)<br></code></pre></td></tr></table></figure><p>其中，<code>*iterables</code>表示传入任意多个序列。</p><p>举例来说，如果有两个列表a和b，想要将它们对应的元素配对在一起，可以使用<code>zip</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>c = <span class="hljs-built_in">zip</span>(a, b)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(c))<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>可以看到，<code>zip</code>函数将a和b两个列表的相同位置的元素进行了配对，并返回了一个包含这些元素的元组列表。</p><p>除了基本用法之外，<code>zip</code>函数还可以和其他函数或语句进行组合使用，例如结合列表推导式或<code>filter</code>函数等，以实现更加复杂的数据处理逻辑。</p><h4 id="1-2偏函数"><a href="#1-2偏函数" class="headerlink" title="1.2偏函数"></a>1.2偏函数</h4><p>问题一：什么是偏函数?<br>在Python的内置模块functools 提供了很多有用的功能，其中一个就是偏函数（partial）。<br>问题二：偏函数有什么用?<br>当函数的参数个数太多，需要简化时，使用 functools.partial可以创建一个新的函数，这个新函数可以固定住<br>原函数的部分参数，从而在调用时更简单。<br>偏函数应用案列<br>#在我们之前学到的内置函数中filter中，调用的时候需要传入两个参数，第一个是函数，第二个是我们需要过滤的可迭<br>代类型的数据，<br>#我们可以通过传入不同的过滤条件去过滤出来我们需要的数据。<br>filter(lambda x:x&gt;3,1i1)<br>filter(lambda x:x&gt;10,1i1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><br><br><span class="hljs-comment"># 偏函数：固定函数的参数，简化函数调用时的参数传递</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">name, datas</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param name: 使用者的名字</span><br><span class="hljs-string">    :param datas: 传递进来的数据</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#125;-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, datas)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">res = work(<span class="hljs-string">&#x27;musen&#x27;</span>,<span class="hljs-string">&#x27;1212&#x27;</span>)<br>res2 = work(<span class="hljs-string">&#x27;musen&#x27;</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>)<br>res3 = work(<span class="hljs-string">&#x27;musen&#x27;</span>,<span class="hljs-string">&#x27;dddd&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(res2)<br><span class="hljs-built_in">print</span>(res3)<br><br>work2 = partial(work, datas=<span class="hljs-string">&#x27;musen&#x27;</span>)<br><br>r1 = work2(<span class="hljs-string">&#x27;222&#x27;</span>)<br>r2 = work2(<span class="hljs-number">333</span>)<br>r3 = work2(<span class="hljs-number">444</span>)<br>r4 = work2(<span class="hljs-number">5555</span>)<br><span class="hljs-built_in">print</span>(r1, r2, r3, r4)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work3</span>(<span class="hljs-params">datas</span>):<br>    work(<span class="hljs-string">&#x27;musen&#x27;</span>, datas)<br></code></pre></td></tr></table></figure><h4 id="1-3闭包函数"><a href="#1-3闭包函数" class="headerlink" title="1.3闭包函数"></a>1.3闭包函数</h4><p>在 Python 中，闭包是指一个函数对象，它引用了外部作用域中的一个或多个变量，即使这些变量在外部作用域已经不存在，它仍然可以访问并修改这些变量。简而言之，闭包是一种特殊的函数，它可以“记住”在创建它的时候所处的环境。</p><p>闭包函数可以用来实现许多有趣的功能，例如在 Python 中，常常使用闭包来实现装饰器。</p><p>闭包函数的基本格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer_func</span>(<span class="hljs-params">param</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner_func</span>():<br>        <span class="hljs-comment"># do something with param</span><br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> inner_func<br></code></pre></td></tr></table></figure><p>其中，<code>outer_func</code> 是外层函数，接受一个参数 <code>param</code>，返回一个内层函数 <code>inner_func</code>，内层函数可以访问外层函数的参数和变量，然后返回一个结果 <code>result</code>。</p><p>当我们调用 <code>outer_func(param)</code> 时，它会返回一个函数对象 <code>inner_func</code>，这个函数可以独立地被调用，但它仍然可以访问外层函数 <code>outer_func</code> 的作用域。这就是闭包的本质。</p><p>下面是一个具体的例子，演示了如何使用闭包来实现一个计数器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_counter</span>():<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">counter</span>():<br>        <span class="hljs-keyword">nonlocal</span> count<br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br>    <span class="hljs-keyword">return</span> counter<br><br>counter1 = make_counter()<br>counter2 = make_counter()<br><br><span class="hljs-built_in">print</span>(counter1())  <span class="hljs-comment"># 输出 1</span><br><span class="hljs-built_in">print</span>(counter1())  <span class="hljs-comment"># 输出 2</span><br><span class="hljs-built_in">print</span>(counter2())  <span class="hljs-comment"># 输出 1</span><br><span class="hljs-built_in">print</span>(counter1())  <span class="hljs-comment"># 输出 3</span><br><span class="hljs-built_in">print</span>(counter2())  <span class="hljs-comment"># 输出 2</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>make_counter</code> 函数，它返回了一个内层函数 <code>counter</code>。在 <code>counter</code> 函数中，我们定义了一个变量 <code>count</code>，并将其初始化为 0。每次调用 <code>counter</code> 函数时，它都会将 <code>count</code> 的值加 1，并返回新的值。</p><p>我们用 <code>make_counter</code> 函数分别创建了两个计数器 <code>counter1</code> 和 <code>counter2</code>，它们是两个独立的函数对象，它们各自维护着自己的 <code>count</code> 变量，彼此之间互不干扰。这正是闭包的特点所在。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python的迭代器和生成器</title>
    <link href="/2020/03/16/Python%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2020/03/16/Python%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Python的迭代器和生成器"><a href="#Python的迭代器和生成器" class="headerlink" title="Python的迭代器和生成器"></a>Python的迭代器和生成器</h1><h3 id="1、可迭代对象"><a href="#1、可迭代对象" class="headerlink" title="1、可迭代对象"></a>1、可迭代对象</h3><p>能够进行迭代逐一返回其成员项的对象称为可迭代对象。可迭代对象的例子包括<br>•所有序列类型：如 1ist、 str 和 tuple，range<br>•非序列类型： dict、set、文件对象:f &#x3D; open(xx，）<br>•实现了_iter_()方法的任意对象（可迭代协议)<br>•实现了序列语义的_getitem_()方法的任意对象。</p><p>1.1、迭代协议：<br>    对象定义了一个 <code>__iter__</code> 方法的，那么这个对象就实现了迭代协议，<code>__iter__</code>方法的返回值必须是一个迭代器</p><p>迭代器(Iterator)：<br>    1.2、迭代器协议<br>        迭代器协议由一个 <code>__iter__</code> 方法和<code>__next__</code>方法共同构成。实现了这两个方法的对象就实现了迭代器协议。<br>    1、对象实现了迭代协议的对象<br>    2、对象实现了<code>__next__</code>方法，<code>__next__</code>方法在迭代完所有数据之后，会抛出<code>StopIteration</code>的错误信息</p><p>迭代器和可迭代对象的操作</p><p>1、实现了迭代器协议的对象，就是一个迭代器<br>2、所有的可迭代对象 都可以通过内置函数iter()转换为迭代器：<br>3、迭代器对象能够使用 内置函数next 进行迭代操作<br>4、所有的迭代器都是可迭代对象，因为迭代器协议包含了迭代协议</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable, Iterator<br><br>st1 = <span class="hljs-string">&#x27;111m22m33&#x27;</span><br>li = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(st1,Iterable))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(li,Iterable))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(st1,Iterator))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(li,Iterator))<br>st1 = <span class="hljs-string">&#x27;abcd&#x27;</span><br>li = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><span class="hljs-comment"># 可迭代对象转换为迭代器:内置函数iter()</span><br>s = <span class="hljs-built_in">iter</span>(st1)   <span class="hljs-comment">#  st1.__iter__()</span><br><span class="hljs-comment"># 迭代器可以使用next进行迭代操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))  <span class="hljs-comment"># st1.__next__()</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br></code></pre></td></tr></table></figure><h5 id="5-自定义可迭代对象"><a href="#5-自定义可迭代对象" class="headerlink" title="5.自定义可迭代对象"></a>5.自定义可迭代对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass1</span>:<br><br>    <span class="hljs-comment"># 实现迭代协议</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>([<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>])<br><br><br>obj = MyClass1()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> obj:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass2</span>:<br>    value = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><br>    <span class="hljs-comment"># 实现序列语义</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> self.value[item]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">pass</span><br><br>obj = MyClass2()<br><br>res = obj[<span class="hljs-number">0</span>]   <span class="hljs-comment">#  obj.__getitem__(0)</span><br><br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h4 id="1-1创建生成器"><a href="#1-1创建生成器" class="headerlink" title="1.1创建生成器"></a>1.1创建生成器</h4><p>#方式一：生成器表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">g = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))<br><br><span class="hljs-built_in">print</span>(g)<br><span class="hljs-comment"># # 生成器能不能使用next进行迭代操作？？</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-comment"># # 注意点：生成器是一种特殊的迭代器，在使用next进行迭代时，数据迭代完之后，会抛出StopIteration异常</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br></code></pre></td></tr></table></figure><p>*方式二：生成器函数<br>注意点：<br>1、函数内部只要定义yield这个关键字，那么这个函数就是一个生成器函数<br>2、生成器函数调用是不会执行内部代码，而是直接返回一个生成器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----work函数----&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------1--&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">888</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----2------&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">777</span><br><br><br>g = work()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;g:&#x27;</span>, g)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;生成的数据为：&#x27;</span>, <span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;生成的数据为：&#x27;</span>, <span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;生成的数据为：&#x27;</span>, <span class="hljs-built_in">next</span>(g))<br></code></pre></td></tr></table></figure><p>#生成器内部不直接存储数据，只存储生成数据的计算表达式（在保存大规模数据时，可以节约内存消耗）。</p><h5 id="1-1生成器和列表对比"><a href="#1-1生成器和列表对比" class="headerlink" title="1.1生成器和列表对比"></a>1.1生成器和列表对比</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">li = [<span class="hljs-number">111</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br>dic = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">11</span>, <span class="hljs-number">2</span>: <span class="hljs-number">3333</span>&#125;<br><br><span class="hljs-comment"># 生成器内部不直接存储数据，只存储生成数据的计算表达式（在处理大规模的数据时，可以节约内层消耗）</span><br>g1 = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-built_in">print</span>(li)<br><span class="hljs-built_in">print</span>(dic)<br><span class="hljs-built_in">print</span>(g1)<br><br>li = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500000</span>)]<br>res = <span class="hljs-built_in">input</span>()<br><br>li = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000000</span>))<br>res = <span class="hljs-built_in">input</span>()<br></code></pre></td></tr></table></figure><h3 id="2-生成器函数"><a href="#2-生成器函数" class="headerlink" title="2 生成器函数"></a>2 生成器函数</h3><h4 id="2-1-生成器的close方法-关闭生成器"><a href="#2-1-生成器的close方法-关闭生成器" class="headerlink" title="2.1 生成器的close方法:关闭生成器"></a>2.1 生成器的close方法:关闭生成器</h4><p>print(next(g))</p><p>print(next(g))<br>print(next(g))<br>g.close()<br>print(next(g))</p><h4 id="2-2-send方法"><a href="#2-2-send方法" class="headerlink" title="2.2 send方法"></a>2.2 send方法</h4><p>给生成器传递参数(与生成器内部进行数据交互)<br>生成器的send方法必须在使用了一次next之后才能使用。</p><p>print(‘next方法执行的结果:’, next(g))</p><p>res &#x3D; g.send(‘musen’)</p><p>iprint(‘send方法执行的结果:’, res)<br>res &#x3D; g.send(‘999’)<br>print(‘send方法执行的结果:’, res)</p><p>res &#x3D; g.send(‘python’)</p><p>print(‘send方法执行的结果:’, res)</p><h4 id="2-3生成器根据send传递的参数来生成数据"><a href="#2-3生成器根据send传递的参数来生成数据" class="headerlink" title="2.3生成器根据send传递的参数来生成数据"></a>2.3生成器根据send传递的参数来生成数据</h4><p>如果要实现根据参数去生成数据的生成器：<br>1、使用send传递了参数<br>2、直接使用next 没有传参数<br>需求：根擀send方法传递的值类生成参数的2次方<br>def work()：<br>val &#x3D; None<br>for i in range(100):<br>if val:<br>val &#x3D; yield val ** 2<br>else:<br>val&#x3D; yield i+1<br>g&#x3D; work()<br>print(next(g))<br>print(g.send(11))<br>print(g.send(20))<br>print(next(g))<br>print(g.send(11))<br>print(g.send(20))<br>print(next(g))</p><h3 id="3、throw方法：在生成器内部抛出指定的异常"><a href="#3、throw方法：在生成器内部抛出指定的异常" class="headerlink" title="3、throw方法：在生成器内部抛出指定的异常"></a>3、throw方法：在生成器内部抛出指定的异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># raise ValueError</span><br>g.throw(ValueError)<br></code></pre></td></tr></table></figure><h3 id="4-根据参数生成数据的案例"><a href="#4-根据参数生成数据的案例" class="headerlink" title="4.根据参数生成数据的案例"></a>4.根据参数生成数据的案例</h3><p>生成器根据send传递的参数来生成数据:</p><p>如果要实现根据参数去生成数据的生成器,需要考虑下面这两种情况：<br>    1、使用send传递了参数<br>    2、直接使用next 没有传参数</p><p>#需求：根据send方法传递的值类生成 参数的2次方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    val = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        <span class="hljs-keyword">if</span> val:<br>            val = <span class="hljs-keyword">yield</span> val ** <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            val = <span class="hljs-keyword">yield</span> i + <span class="hljs-number">1</span><br><br><br>g = work()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">20</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">20</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">20</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br></code></pre></td></tr></table></figure><h3 id="5-pytest中利用生成器实现测试夹具的执行流程"><a href="#5-pytest中利用生成器实现测试夹具的执行流程" class="headerlink" title="5.pytest中利用生成器实现测试夹具的执行流程"></a>5.pytest中利用生成器实现测试夹具的执行流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-comment"># 用例前置执行</span><br>    <span class="hljs-comment"># 此处登录获取token</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;用例执行的前置脚本&quot;</span>)<br>    token = <span class="hljs-string">&#x27;asfsgyuajioghj&#x27;</span><br>    <span class="hljs-keyword">yield</span> token<br>    <span class="hljs-comment"># 用例后置执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;用例执行的后置脚本&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_01</span>(<span class="hljs-params">login</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---测试用例的执行代码----------&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;token的值：&quot;</span>, login)<br>    expected = <span class="hljs-string">&#x27;OK&#x27;</span><br>    res = <span class="hljs-string">&#x27;OK&#x27;</span><br>    <span class="hljs-keyword">assert</span> expected == res<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1、检查测试用例的是否有指定测试夹具</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 夹具本质是一个生成器函数  </span><br><span class="hljs-string">#  pytest测试夹具执行的流程：</span><br><span class="hljs-string"></span><br><span class="hljs-string">g = login()</span><br><span class="hljs-string">token = next(g)</span><br><span class="hljs-string"></span><br><span class="hljs-string">test_01(token)</span><br><span class="hljs-string"></span><br><span class="hljs-string">try:</span><br><span class="hljs-string">    next(g)</span><br><span class="hljs-string">expect:</span><br><span class="hljs-string">    pass</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>总结</p><p>在Python中，迭代器和生成器都是用来遍历数据序列的工具，但它们的实现方式和作用略有不同。</p><p>迭代器是一种对象，可以通过next()方法依次访问序列中的元素。Python内置的许多数据类型都支持迭代器，比如列表、元组、字符串等。通过迭代器，我们可以遍历整个序列，而无需将整个序列加载到内存中，从而节省内存空间。迭代器可以通过定义一个__iter__()方法来创建，并且通常需要定义一个__next__()方法来遍历序列中的元素。</p><p>生成器是一种特殊的迭代器，可以通过yield语句将结果生成到调用方。生成器函数在执行过程中可以挂起，并且在下次调用时可以从挂起的位置继续执行。与迭代器相比，生成器可以更加灵活地控制数据的生成和消耗，可以有效地处理大规模数据和无限序列的问题。生成器可以通过定义一个包含yield语句的函数来创建。</p><p>迭代器和生成器的作用主要有以下几个方面：</p><ol><li>节省内存空间：通过迭代器和生成器，我们可以逐个访问序列中的元素，而无需将整个序列加载到内存中，从而节省内存空间。</li><li>适用于大规模数据和无限序列：迭代器和生成器可以更加灵活地控制数据的生成和消耗，可以有效地处理大规模数据和无限序列的问题。</li><li>增加程序的可读性和可维护性：使用迭代器和生成器可以使代码更加简洁、清晰，提高代码的可读性和可维护性。</li><li>方便数据处理和转换：通过迭代器和生成器，我们可以方便地对序列进行处理和转换，例如对序列中的元素进行筛选、排序、合并等操作。</li></ol><p>总之，迭代器和生成器是Python中非常重要的语言特性，能够大大提高代码的效率和可读性，是Python程序员必须掌握的基本技能之一。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
      <tag>python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python推导式详解</title>
    <link href="/2020/03/12/Python%E6%8E%A8%E5%AF%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/03/12/Python%E6%8E%A8%E5%AF%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Python推导式详解"><a href="#Python推导式详解" class="headerlink" title="Python推导式详解"></a>Python推导式详解</h1><p>Python推导式（Comprehension）是一种简洁而强大的语言特性，用于快速创建序列、集合和字典等数据结构。它能够简化代码，使代码更加清晰易懂。</p><p>推导式的主要作用是通过一种紧凑的语法形式创建新的数据结构，可以在一个简单的表达式中完成复杂的操作，从而简化了代码的编写和阅读。</p><h4 id="1-推导式语法："><a href="#1-推导式语法：" class="headerlink" title="1.推导式语法："></a>1.推导式语法：</h4><p>作用：根据一些规律 迅速生成列表</p><p>li &#x3D; [ x for i in xxx ]</p><p>1.需求 如何快速生成 一个[data0 ,data1…data99]的列表？</p><p>#for循环 写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">li = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    li.append(<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><span class="hljs-built_in">print</span>(li)<br></code></pre></td></tr></table></figure><p>#列表推导式实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">li2 = [<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i)   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)]<br><br><span class="hljs-built_in">print</span>(li2)<br></code></pre></td></tr></table></figure><p>#推导式结合if 进行数据过滤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&#x27;data0&#x27;</span>, <span class="hljs-string">&#x27;data1&#x27;</span>, <span class="hljs-string">&#x27;data2&#x27;</span>, <span class="hljs-string">&#x27;data3&#x27;</span>, <span class="hljs-string">&#x27;data4&#x27;</span>, <span class="hljs-string">&#x27;data5&#x27;</span>, <span class="hljs-string">&#x27;data6&#x27;</span>, <span class="hljs-string">&#x27;data7&#x27;</span>, <span class="hljs-string">&#x27;data8&#x27;</span>, <span class="hljs-string">&#x27;data9&#x27;</span>, <span class="hljs-string">&#x27;data10&#x27;</span>, <span class="hljs-string">&#x27;data11&#x27;</span>,<br>       <span class="hljs-string">&#x27;data12&#x27;</span>, <span class="hljs-string">&#x27;data13&#x27;</span>, <span class="hljs-string">&#x27;data14&#x27;</span>, <span class="hljs-string">&#x27;data15&#x27;</span>, <span class="hljs-string">&#x27;data16&#x27;</span>, <span class="hljs-string">&#x27;data17&#x27;</span>, <span class="hljs-string">&#x27;data18&#x27;</span>, <span class="hljs-string">&#x27;data19&#x27;</span>, <span class="hljs-string">&#x27;data20&#x27;</span>, <span class="hljs-string">&#x27;data21&#x27;</span>, <span class="hljs-string">&#x27;data22&#x27;</span>,<br>       <span class="hljs-string">&#x27;data23&#x27;</span>, <span class="hljs-string">&#x27;data24&#x27;</span>, <span class="hljs-string">&#x27;data25&#x27;</span>, <span class="hljs-string">&#x27;data26&#x27;</span>, <span class="hljs-string">&#x27;data27&#x27;</span>, <span class="hljs-string">&#x27;data28&#x27;</span>, <span class="hljs-string">&#x27;data29&#x27;</span>, <span class="hljs-string">&#x27;data30&#x27;</span>, <span class="hljs-string">&#x27;data31&#x27;</span>, <span class="hljs-string">&#x27;data32&#x27;</span>, <span class="hljs-string">&#x27;data33&#x27;</span>,<br>       <span class="hljs-string">&#x27;data34&#x27;</span>, <span class="hljs-string">&#x27;data35&#x27;</span>, <span class="hljs-string">&#x27;data36&#x27;</span>, <span class="hljs-string">&#x27;data37&#x27;</span>, <span class="hljs-string">&#x27;data38&#x27;</span>, <span class="hljs-string">&#x27;data39&#x27;</span>, <span class="hljs-string">&#x27;data40&#x27;</span>, <span class="hljs-string">&#x27;data41&#x27;</span>, <span class="hljs-string">&#x27;data42&#x27;</span>, <span class="hljs-string">&#x27;data43&#x27;</span>, <span class="hljs-string">&#x27;data44&#x27;</span>,<br>       <span class="hljs-string">&#x27;data45&#x27;</span>, <span class="hljs-string">&#x27;data46&#x27;</span>, <span class="hljs-string">&#x27;data47&#x27;</span>, <span class="hljs-string">&#x27;data48&#x27;</span>, <span class="hljs-string">&#x27;data49&#x27;</span>, <span class="hljs-string">&#x27;data50&#x27;</span>, <span class="hljs-string">&#x27;data51&#x27;</span>, <span class="hljs-string">&#x27;data52&#x27;</span>, <span class="hljs-string">&#x27;data53&#x27;</span>, <span class="hljs-string">&#x27;data54&#x27;</span>, <span class="hljs-string">&#x27;data55&#x27;</span>,<br>       <span class="hljs-string">&#x27;data56&#x27;</span>, <span class="hljs-string">&#x27;data57&#x27;</span>, <span class="hljs-string">&#x27;data58&#x27;</span>, <span class="hljs-string">&#x27;data59&#x27;</span>, <span class="hljs-string">&#x27;data60&#x27;</span>, <span class="hljs-string">&#x27;data61&#x27;</span>, <span class="hljs-string">&#x27;data62&#x27;</span>, <span class="hljs-string">&#x27;data63&#x27;</span>, <span class="hljs-string">&#x27;data64&#x27;</span>, <span class="hljs-string">&#x27;data65&#x27;</span>, <span class="hljs-string">&#x27;data66&#x27;</span>,<br>       <span class="hljs-string">&#x27;data67&#x27;</span>, <span class="hljs-string">&#x27;data68&#x27;</span>, <span class="hljs-string">&#x27;data69&#x27;</span>, <span class="hljs-string">&#x27;data70&#x27;</span>, <span class="hljs-string">&#x27;data71&#x27;</span>, <span class="hljs-string">&#x27;data72&#x27;</span>, <span class="hljs-string">&#x27;data73&#x27;</span>, <span class="hljs-string">&#x27;data74&#x27;</span>, <span class="hljs-string">&#x27;data75&#x27;</span>, <span class="hljs-string">&#x27;data76&#x27;</span>, <span class="hljs-string">&#x27;data77&#x27;</span>,<br>       <span class="hljs-string">&#x27;data78&#x27;</span>, <span class="hljs-string">&#x27;data79&#x27;</span>, <span class="hljs-string">&#x27;data80&#x27;</span>, <span class="hljs-string">&#x27;data81&#x27;</span>, <span class="hljs-string">&#x27;data82&#x27;</span>, <span class="hljs-string">&#x27;data83&#x27;</span>, <span class="hljs-string">&#x27;data84&#x27;</span>, <span class="hljs-string">&#x27;data85&#x27;</span>, <span class="hljs-string">&#x27;data86&#x27;</span>, <span class="hljs-string">&#x27;data87&#x27;</span>, <span class="hljs-string">&#x27;data88&#x27;</span>,<br>       <span class="hljs-string">&#x27;data89&#x27;</span>, <span class="hljs-string">&#x27;data90&#x27;</span>, <span class="hljs-string">&#x27;data91&#x27;</span>, <span class="hljs-string">&#x27;data92&#x27;</span>, <span class="hljs-string">&#x27;data93&#x27;</span>, <span class="hljs-string">&#x27;data94&#x27;</span>, <span class="hljs-string">&#x27;data95&#x27;</span>, <span class="hljs-string">&#x27;data96&#x27;</span>, <span class="hljs-string">&#x27;data97&#x27;</span>, <span class="hljs-string">&#x27;data98&#x27;</span>, <span class="hljs-string">&#x27;data99&#x27;</span>]<br></code></pre></td></tr></table></figure><p>#把上述data为偶数的数据过滤掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [ <span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i)   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)  <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span> ]<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>#需求 ：生成一个[‘data0’,’musen1’,’data1’,’musen2’……’data98’,’musen99’,]</p><p>#常规语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">li = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br><br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        li.append(<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br>    <span class="hljs-keyword">else</span>:<br>        li.append(<span class="hljs-string">&quot;musen&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><span class="hljs-built_in">print</span>(li)<br></code></pre></td></tr></table></figure><h4 id="2-三元运算符"><a href="#2-三元运算符" class="headerlink" title="2.三元运算符"></a>2.三元运算符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n =<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个数字：&quot;</span>))<br><br>number = <span class="hljs-string">&quot;大于10&quot;</span><span class="hljs-keyword">if</span> <span class="hljs-number">10</span> &lt; n <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;小于10&quot;</span><br><br><span class="hljs-built_in">print</span>(number)<br></code></pre></td></tr></table></figure><h5 id="2-1推导式结合：三元运算符使用"><a href="#2-1推导式结合：三元运算符使用" class="headerlink" title="2.1推导式结合：三元运算符使用"></a>2.1推导式结合：三元运算符使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>  <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;musen&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)]<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h4 id="3-字典推导式"><a href="#3-字典推导式" class="headerlink" title="3.字典推导式"></a>3.字典推导式</h4><h5 id="3-1字典推导式语法"><a href="#3-1字典推导式语法" class="headerlink" title="3.1字典推导式语法"></a>3.1字典推导式语法</h5><p>#字典推导式基本语法</p><p><code>dic = &#123;k:v for x in xxx&#125;</code></p><p>#字典推导式结合 if 进行过滤</p><p><code>dic = &#123;k:v for x in xxx if xxx&#125;</code></p><p>#字典推导式结合 三元运算符 进行过滤</p><p><code>dic = &#123;k:v  if xx else xxx  for x in xxx &#125;</code></p><h5 id="3-2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据"><a href="#3-2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据" class="headerlink" title="3.2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据"></a>3.2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据</h5><p>li &#x3D; [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]</p><p>#之前for循环的做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1= &#123;&#125;<br><br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(li):<br><br>​dict1[i] = j<br><br><span class="hljs-built_in">print</span>(dict1)<br></code></pre></td></tr></table></figure><p>#字典推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;i:j  <span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(li) &#125;<br><br>​<span class="hljs-built_in">print</span>(dic)<br></code></pre></td></tr></table></figure><h5 id="3-3-使用字典推倒式将下面字符串格式的数据，改成字典类型的数据"><a href="#3-3-使用字典推倒式将下面字符串格式的数据，改成字典类型的数据" class="headerlink" title="3.3  使用字典推倒式将下面字符串格式的数据，改成字典类型的数据"></a>3.3  使用字典推倒式将下面字符串格式的数据，改成字典类型的数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">cookie = <span class="hljs-string">&#x27;BIDUPSID=D0727533D7147B7;PSTM=1530348042; BAIDUID=B1005C9BC2EB28; &#x27;</span> \<br>         <span class="hljs-string">&#x27;sugstore=0;__cfduid=d0a13458f8ac2a;BD_UPN=12314353;ispeed_lsm=2;&#x27;</span> \<br>         <span class="hljs-string">&#x27;BDORZ=B490B5EBF6F3CD402&#x27;</span><br><br>res = cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)<br>dic = &#123;&#125;<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> res:<br>     d = item.split(<span class="hljs-string">&#x27;=&#x27;</span>)<br>     key = d[<span class="hljs-number">0</span>]<br>     value = d[<span class="hljs-number">1</span>]<br>     dic[key] =value<br> <span class="hljs-built_in">print</span>(dic)<br></code></pre></td></tr></table></figure><h6 id="3-4-1字典推导式实现"><a href="#3-4-1字典推导式实现" class="headerlink" title="3.4.1字典推导式实现"></a>3.4.1字典推导式实现</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = &#123;item.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: item.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)&#125;<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h6 id="3-4-2推导式中双重for嵌套"><a href="#3-4-2推导式中双重for嵌套" class="headerlink" title="3.4.2推导式中双重for嵌套"></a>3.4.2推导式中双重for嵌套</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = &#123;k: v <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> [item.split(<span class="hljs-string">&#x27;=&#x27;</span>)]&#125;<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h6 id="3-4-3列表推导式集合字典推导式"><a href="#3-4-3列表推导式集合字典推导式" class="headerlink" title="3.4.3列表推导式集合字典推导式"></a>3.4.3列表推导式集合字典推导式</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [item.split(<span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)]<br><span class="hljs-comment"># print(res)</span><br>dic = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> res&#125;<br><span class="hljs-built_in">print</span>(dic)<br></code></pre></td></tr></table></figure><p>3.4.4列表推导式集合字典推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dic2 = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> [item.split(<span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)]&#125;<br><span class="hljs-built_in">print</span>(dic2)<br></code></pre></td></tr></table></figure><h5 id="3-5推导式中多重for嵌套"><a href="#3-5推导式中多重for嵌套" class="headerlink" title="3.5推导式中多重for嵌套"></a>3.5推导式中多重for嵌套</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">li =[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]:<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]:<br>        li.append(<span class="hljs-string">&#x27;&#123;&#125;-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i,v))<br><span class="hljs-built_in">print</span>(li)<br><br><br>li2 = [<span class="hljs-string">&#x27;&#123;&#125;-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i, v) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>] <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]]<br><span class="hljs-built_in">print</span>(li2)<br><br></code></pre></td></tr></table></figure><h4 id="4-集合推导式和生成器表达式"><a href="#4-集合推导式和生成器表达式" class="headerlink" title="4.集合推导式和生成器表达式"></a>4.集合推导式和生成器表达式</h4><p>列表推导式 : [ x for x in XXX ]<br>字典推导式 : { k:v  for x in XXX }</p><p>集合推导式  : { x for x in XXX }<br>生成器表达式 : ( x for x in XXX ) </p><h5 id="4-1集合推导式"><a href="#4-1集合推导式" class="headerlink" title="4.1集合推导式"></a>4.1集合推导式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">se = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)&#125;<br><span class="hljs-built_in">print</span>(se)<br></code></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的编码规范</title>
    <link href="/2020/03/10/pep8/"/>
    <url>/2020/03/10/pep8/</url>
    
    <content type="html"><![CDATA[<h1 id="python的编码规范"><a href="#python的编码规范" class="headerlink" title="python的编码规范"></a>python的编码规范</h1><h4 id="1-1-pep8规范"><a href="#1-1-pep8规范" class="headerlink" title="1.1 pep8规范"></a>1.1 pep8规范</h4><h5 id="1-缩进"><a href="#1-缩进" class="headerlink" title="1.缩进"></a>1.缩进</h5><p>*每一级缩进使用4个空格。</p><p>*续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐<a href="https://blog.csdn.net/ratsniper/article/details/78954852#fn:7">3</a>。当使用挂行缩进时，应该考虑到第一行不应该有参数，以及使用缩进以区分自己是续行。</p><h5 id="2-行的最大长度"><a href="#2-行的最大长度" class="headerlink" title="2.行的最大长度"></a>2.行的最大长度</h5><p>Ctrl+Alt+L (格式化代码快捷键 ——&gt;&gt; 代码会自动按照pep8规范格式化)</p><p>*所有行限制的最大字符数为79个.</p><p>*注释的限制最大字符数是72个</p><p>\ 表示隐式换行</p><p>*如果一个字符串过长，可以回车，pycharm会自动补一个\  隐式换行连接符。</p><h5 id="3-空行"><a href="#3-空行" class="headerlink" title="3.空行"></a>3.空行</h5><p>*顶层函数和类的定义，前后用两个空行隔开。</p><p>*类的方法定义用一个空行隔开</p><h5 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h5><p>与代码相矛盾的注释比没有注释还糟，当代码更改时，优先更新对应的注释！<br>注释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！)。<br>如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号。<br>在句尾结束的时候应该使用两个空格。<br>当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格。<br>在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读。</p><h6 id="1-块注释"><a href="#1-块注释" class="headerlink" title="1.块注释"></a>1.块注释</h6><p>块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。<br>块注释内部的段落通过只有一个#的空行分隔。</p><h6 id="2-行内注释"><a href="#2-行内注释" class="headerlink" title="2.行内注释"></a>2.行内注释</h6><p>有节制地使用行内注释。<br>行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始。<br>事实上，如果状态明显的话，行内注释是不必要的，反而会分散注意力。</p><h6 id="3-文档字符串注释"><a href="#3-文档字符串注释" class="headerlink" title="3.文档字符串注释"></a>3.文档字符串注释</h6><p>编写好的文档说明（也叫“docstrings”）的约定在<a href="http://legacy.python.org/dev/peps/pep-0257/">PEP 257</a>中永恒不变。</p><ul><li>要为所有的公共模块，函数，类以及方法编写文档说明。非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后。</li><li><a href="http://legacy.python.org/dev/peps/pep-0257/">PEP 257</a> 描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行</li></ul><p> <code>#__doc__ 属性：获取对象的文档字符串注释</code></p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests`<br><br>`<span class="hljs-built_in">print</span>(requests.__doc__)<br></code></pre></td></tr></table></figure><p>类中的文档字符串注释：</p><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Musen</span>:`<br><br>`<span class="hljs-string">&quot;&quot;&quot;`</span><br><span class="hljs-string"></span><br><span class="hljs-string">`mesen这个类的文档字符串注释`</span><br><span class="hljs-string"></span><br><span class="hljs-string">`详细的功能介绍`</span><br><span class="hljs-string"></span><br><span class="hljs-string">`&quot;&quot;&quot;</span>`<br><br>​<span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>(<span class="hljs-params">self,name :<span class="hljs-built_in">str</span>,age :<span class="hljs-built_in">int</span></span>)  -&gt; <span class="hljs-literal">None</span>:   <span class="hljs-comment">#name str类型 age int类型 方法返回值 为None </span><br><br>​<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">​work1这个方法的文档字符串注释</span><br><span class="hljs-string"></span><br><span class="hljs-string">​该方法功能的整体说明</span><br><span class="hljs-string"></span><br><span class="hljs-string">​param name：名字</span><br><span class="hljs-string"></span><br><span class="hljs-string">​param  age：年龄</span><br><span class="hljs-string"></span><br><span class="hljs-string">​&quot;&quot;&quot;</span><br><br>`<span class="hljs-built_in">print</span>(MuSen.__doc__)<br></code></pre></td></tr></table></figure><h5 id="5-命名的约定"><a href="#5-命名的约定" class="headerlink" title="5.命名的约定"></a>5.命名的约定</h5><h6 id="1-变量命名"><a href="#1-变量命名" class="headerlink" title="1.变量命名"></a>1.变量命名</h6><p>永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名。<br>在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替。</p><h6 id="2-函数命名"><a href="#2-函数命名" class="headerlink" title="2.函数命名"></a>2.函数命名</h6><p>函数名应该小写，如果想提高可读性可以用下划线分隔。<br>大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用（比如 threading.py），保持向后兼容性。</p><h6 id="3-类命名"><a href="#3-类命名" class="headerlink" title="3.类命名"></a>3.类命名</h6><p>类名一般使用首字母大写的约定。<br>在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替。<br>注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量。</p><p>4.类里面的函数和方法参数</p><p>始终要将 self 作为实例方法的的第一个参数。<br>始终要将 cls 作为类静态方法的第一个参数。<br>如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好。（也许最好用同义词来避免这种冲突）</p><p>参考资料:</p><p>pep8编码规范 <a href="https://blog.csdn.net/ratsniper/article/details/78954852">https://blog.csdn.net/ratsniper/article/details/78954852</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python基础</tag>
      
      <tag>Python编码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
