<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高级Python编程技巧之装饰器：让你的代码更灵活、更强大(一)</title>
    <link href="/2020/03/22/%E9%AB%98%E7%BA%A7Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E3%80%81%E6%9B%B4%E5%BC%BA%E5%A4%A7(%E4%B8%80)/"/>
    <url>/2020/03/22/%E9%AB%98%E7%BA%A7Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E3%80%81%E6%9B%B4%E5%BC%BA%E5%A4%A7(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="高级Python编程技巧之装饰器：让你的代码更灵活、更强大-一"><a href="#高级Python编程技巧之装饰器：让你的代码更灵活、更强大-一" class="headerlink" title="高级Python编程技巧之装饰器：让你的代码更灵活、更强大(一)"></a>高级Python编程技巧之装饰器：让你的代码更灵活、更强大(一)</h1><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><p>开放封闭原则是面向对象设计中的一项重要原则，指的是软件实体（如类、模块、函数等）应该对扩展开放，对修改关闭。具体来说，开放封闭原则要求我们设计软件实体时，应该尽量避免修改已有的代码，而是应该通过扩展已有的代码来实现新的功能。</p><p>开放封闭原则的核心思想是通过抽象来实现扩展。在软件设计时，我们应该尽量使用抽象的方式来描述系统的功能和特性，而不是依赖于具体的实现细节。这样，当需要增加新的功能时，只需要增加新的抽象，而不需要修改已有的代码。</p><p>下面举一个简单的例子来说明开放封闭原则的应用。假设我们有一个计算器程序，该程序可以进行加、减、乘、除四种运算。如果我们使用开放封闭原则来设计这个程序，那么我们可以先定义一个抽象的运算接口，该接口包含一个计算方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>然后，我们可以针对每种运算定义一个具体的类，这些类都实现了运算接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 + num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subtract</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 - num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Multiply</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 * num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Divide</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 / num2<br></code></pre></td></tr></table></figure><p>这样，当需要增加新的运算时，只需要定义一个新的类，并实现运算接口即可。这个过程中，我们并没有修改已有的代码，而是通过扩展已有的代码来实现新的功能。</p><p>总之，开放封闭原则是面向对象设计中的一个非常重要的原则，它可以帮助我们设计出具有可扩展性和可维护性的软件系统。在实际应用中，我们应该尽可能地遵守这个原则，从而提高软件系统的可靠性和可用性。</p><h2 id="装饰器的介绍"><a href="#装饰器的介绍" class="headerlink" title="装饰器的介绍"></a>装饰器的介绍</h2><p>Python装饰器是一种特殊的语法，用于在不改变已有函数代码的情况下，为函数添加额外的功能或修改其行为。装饰器常常被用于日志记录、性能分析、输入合法性检查、缓存等场景。</p><h2 id="装饰器的示例代码"><a href="#装饰器的示例代码" class="headerlink" title="装饰器的示例代码"></a>装饰器的示例代码</h2><p>以下是一个简单的装饰器示例代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pythonCopy code<br>def my_decorator(func):<br>    def <span class="hljs-keyword">wrapper</span>():<br>        print(&quot;Before the function is called.&quot;)<br>        func()<br>        print(&quot;After the function is called.&quot;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span><br><br>@my_decorator<br>def say_hello():<br>    print(&quot;Hello!&quot;)<br><br>say_hello()<br></code></pre></td></tr></table></figure><p>在这个示例代码中，我们定义了一个名为<code>my_decorator</code>的装饰器函数，它接受一个函数作为参数，并返回一个新的函数<code>wrapper</code>。这个新函数<code>wrapper</code>在调用原始函数之前和之后都执行了一些额外的代码。我们还使用装饰器语法<code>@my_decorator</code>来装饰<code>say_hello</code>函数，使得它在调用前后分别打印了”Before the function is called.”和”After the function is called.”。</p><h2 id="装饰器的装饰过程"><a href="#装饰器的装饰过程" class="headerlink" title="装饰器的装饰过程"></a>装饰器的装饰过程</h2><p>装饰器在Python中是通过函数或类实现的。在Python中，函数是一等公民，因此可以将函数作为参数传递给另一个函数，并返回一个函数。</p><p>当我们使用装饰器语法将一个函数装饰器应用于另一个函数时，Python会自动调用装饰器函数，并将被装饰函数作为参数传递给它。装饰器函数会在不修改原始函数代码的情况下，返回一个新的函数或类，用于替换原始函数或类。当我们调用经过装饰的函数时，实际上是调用了这个新的函数或类。</p><h2 id="装饰带参数的函数"><a href="#装饰带参数的函数" class="headerlink" title="装饰带参数的函数"></a>装饰带参数的函数</h2><p>在Python中，装饰带参数的函数需要在装饰器函数内部再定义一层函数，该函数用于接收原函数的参数并返回一个新的函数，新的函数才是真正被调用的函数。下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">pythonCopy code<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator start&quot;</span>)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator end&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>上述代码中，装饰器<code>decorator</code>定义了一个内部函数<code>wrapper</code>，<code>wrapper</code>接收原函数的参数<code>*args</code>和<code>**kwargs</code>，并在调用原函数前后输出一些信息。注意，在调用原函数时，需要使用<code>*args</code>和<code>**kwargs</code>将参数传递给原函数。在函数执行结束后，返回函数的执行结果。<code>add</code>函数被<code>@decorator</code>装饰，因此在执行<code>add</code>函数时会先执行<code>decorator</code>函数。</p><h2 id="装饰带返回值的函数"><a href="#装饰带返回值的函数" class="headerlink" title="装饰带返回值的函数"></a>装饰带返回值的函数</h2><p>要装饰带返回值的函数，需要在装饰器函数中定义一个内部函数，该函数调用原函数并返回执行结果。下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">pythonCopy code<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator start&quot;</span>)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator end&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>上述代码中，<code>add</code>函数返回<code>a + b</code>的结果，在执行完<code>add</code>函数后，将结果赋给变量<code>result</code>。在装饰器<code>decorator</code>中，将原函数执行的结果存储在变量<code>result</code>中，并在执行完装饰器函数后返回该结果。</p><h2 id="通用装饰器的定义"><a href="#通用装饰器的定义" class="headerlink" title="通用装饰器的定义"></a>通用装饰器的定义</h2><p>通用装饰器的定义通常采用闭包的形式，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-comment"># 执行一些前置操作</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Before the function is called.&quot;</span>)<br>        <span class="hljs-comment"># 调用函数或方法</span><br>        result = func(*args, **kwargs)<br>        <span class="hljs-comment"># 执行一些后置操作</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After the function is called.&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>my_decorator</code> 是一个通用装饰器函数，它的参数 <code>func</code> 是一个被装饰的函数或方法。<code>wrapper</code> 是一个内部函数，它接收任意数量的位置参数和关键字参数，然后在调用被装饰的函数前后执行一些操作。</p><p>当一个函数被装饰器装饰时，装饰器实际上会返回 <code>wrapper</code> 函数，而不是原来的函数。这意味着当我们调用被装饰的函数时，实际上是调用了 <code>wrapper</code> 函数，而且这个函数执行了前置操作、调用了原函数、执行了后置操作。</p><p>下面是一个使用通用装饰器的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + name)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;done&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个 <code>say_hello</code> 函数，并用 <code>my_decorator</code> 装饰了它。当我们调用 <code>say_hello</code> 函数时，实际上是调用了装饰器返回的 <code>wrapper</code> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">say_hello(<span class="hljs-string">&quot;Tom&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Before the function <span class="hljs-keyword">is</span> called.<br>Hello, Tom<br>After the function <span class="hljs-keyword">is</span> called.<br></code></pre></td></tr></table></figure><p>上述代码中，我们调用了 <code>say_hello</code> 函数，并将 “Tom” 作为参数传递给它。装饰器在调用 <code>say_hello</code> 函数前后分别打印了 “Before the function is called.” 和 “After the function is called.” 的信息，这说明装饰器在 <code>say_hello</code> 函数的前后执行了一些操作。最后，函数返回了 “done” 这个字符串。</p><p>总的来说，通用装饰器是非常实用的，因为它可以应用于任何函数或方法，而不需要为每个函数都写一个专门的装饰器。同时，通用装饰器也可以方便地扩展和修改，以满足不同的需求。</p><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>在Python中，装饰器也可以接受参数。这种装饰器被称为带参数的装饰器。带参数的装饰器的定义方法与普通的装饰器有所不同，需要再次包装一层。</p><p>下面我们通过示例来详细介绍下Python中的可以传递参数的装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator_with_args</span>(<span class="hljs-params">arg1, arg2, arg3</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decorator with arguments &#123;&#125;, &#123;&#125;, &#123;&#125; called&quot;</span>.<span class="hljs-built_in">format</span>(arg1, arg2, arg3))<br>            func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br></code></pre></td></tr></table></figure><p>上述代码定义了一个带有三个参数的装饰器<code>decorator_with_args</code>，该装饰器用于为函数添加额外的功能，包括在函数执行前后输出一些信息。</p><p>现在我们来使用这个带有参数的装饰器来装饰一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@decorator_with_args(<span class="hljs-params"><span class="hljs-string">&quot;arg1&quot;</span>, <span class="hljs-string">&quot;arg2&quot;</span>, <span class="hljs-string">&quot;arg3&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_function</span>(<span class="hljs-params">arg</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;my_function called with argument:&quot;</span>, arg)<br></code></pre></td></tr></table></figure><p>在这里，我们使用<code>@</code>符号将<code>my_function</code>函数应用到<code>decorator_with_args</code>装饰器上，并传入了三个参数：”arg1”、”arg2”和”arg3”。当我们调用<code>my_function</code>函数时，装饰器会先输出”Decorator with arguments arg1, arg2, arg3 called”，然后再执行函数体。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python内置函数扩展、偏函数和闭包函数</title>
    <link href="/2020/03/18/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E3%80%81%E5%81%8F%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0/"/>
    <url>/2020/03/18/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E3%80%81%E5%81%8F%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python内置函数扩展、偏函数和闭包函数"><a href="#Python内置函数扩展、偏函数和闭包函数" class="headerlink" title="Python内置函数扩展、偏函数和闭包函数"></a>Python内置函数扩展、偏函数和闭包函数</h1><h4 id="1-1、匿名函数"><a href="#1-1、匿名函数" class="headerlink" title="1.1、匿名函数"></a>1.1、匿名函数</h4><p>python中有一种特殊的函数，不需要使用def去事定义，也不用给函数起名字，用过lamda表达式来定义，这种函<br>数叫匿名函数<br>匿名函数格式<br>lambda 参数：表达式（返回值）<br>问题需求:将以下函数改成匿名函数<br>#普通函数<br>def fun1(varl):<br>        return var1<em>2<br>#匿名函数定义后也可以用变量接收保存，但是一般不这样做<br>fun1 &#x3D; lambda var1 : var1</em>2<br>匿名函数的实际应用：匿名函数一般用来定义在表达式简单的函数，使用匿名函数可以简化代码，像上面的map,<br>filter等函数的使用。应用参数：通常用于函数传参时传递函数的场景</p><p>#问题需求一：对下面的列表进行排序（规则：根据列表中每个元素的第二个值的大小进行排序）<br>li &#x3D;[[1, 10,32]，[3， 22,99]，[2, 7,77]]<br>#问题需求二：对下面的列表进行排序（规则：根据元素的name字段的值的大小进行排序）<br>li2 &#x3D;[{‘id’: 1,”name”: 100},{‘id’： 7,”name”: 9},{‘id’: 3,”name”: 1}]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">add2 = <span class="hljs-keyword">lambda</span> a, b: a + b<br>res2 = add2(<span class="hljs-number">33</span>, <span class="hljs-number">44</span>)<br><span class="hljs-built_in">print</span>(res2)<br></code></pre></td></tr></table></figure><p>应用参数：通常用于函数传参是传递函数的场景</p><p>filter过滤器</p><p>map:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># li = [11,3,43,54,5]</span><br><span class="hljs-comment"># li.sort()</span><br><br><span class="hljs-comment"># li = [[11, 2], [1, 21], [93, 7], [87, 0], [23, 6]]</span><br>li = [<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">155</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">178</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">175</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">185</span>&#125;,<br>]<br><span class="hljs-comment"># 根据列表中每个数据的age值大小进行排序</span><br>li.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;height&#x27;</span>])<br><span class="hljs-built_in">print</span>(li)<br></code></pre></td></tr></table></figure><p>eval：</p><p><code>eval()</code>函数是Python的一个内置函数，它可以执行一段字符串形式的Python代码，并返回执行结果。其基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">eval</span>(expression[, <span class="hljs-built_in">globals</span>[, <span class="hljs-built_in">locals</span>]])<br></code></pre></td></tr></table></figure><p>其中，<code>expression</code>是需要执行的Python代码，可以是字符串或者代码对象；<code>globals</code>和<code>locals</code>是可选参数，分别代表全局命名空间和局部命名空间。</p><p><code>eval()</code>函数的作用主要是将字符串形式的Python代码转换成可执行的代码并执行，可以实现一些动态性较强的操作。例如，可以用<code>eval()</code>函数计算一个字符串形式的数学表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">expression = <span class="hljs-string">&quot;2 + 3 * 4&quot;</span><br>result = <span class="hljs-built_in">eval</span>(expression)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出14</span><br></code></pre></td></tr></table></figure><p>还可以通过<code>eval()</code>函数来动态创建Python对象，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">expression = <span class="hljs-string">&quot;&#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;&quot;</span><br>person = <span class="hljs-built_in">eval</span>(expression)<br><span class="hljs-built_in">print</span>(person)  <span class="hljs-comment"># 输出&#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，由于<code>eval()</code>函数可以执行任意字符串形式的Python代码，因此也存在一定的安全风险。如果执行的代码来自于不可信的来源，可能会导致程序受到攻击或者损坏。因此，在使用<code>eval()</code>函数时需要谨慎，尽量避免执行来自不可信的源代码。</p><p>all：</p><p>在Python中，<code>all()</code> 是一个内置函数，用于判断一个可迭代对象中的所有元素是否都为 True。如果是，则返回 True；否则返回 False。</p><p><code>all()</code> 的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">all</span>(iterable)<br></code></pre></td></tr></table></figure><p>其中，<code>iterable</code> 表示一个可迭代对象，如列表、元组、字典、集合等。</p><p><code>all()</code> 的返回值类型为布尔型。</p><p>下面是一个例子，演示如何使用 <code>all()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">lst1 = [<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]<br>lst2 = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br>lst3 = []<br>lst4 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst1)) <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst2)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst3)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst4)) <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p>在上述例子中，<code>all()</code> 分别对四个列表进行判断。<code>lst1</code> 中有一个元素为 False，因此 <code>all(lst1)</code> 的返回值为 False；<code>lst2</code> 中的所有元素都为非零值，因此 <code>all(lst2)</code> 的返回值为 True；<code>lst3</code> 为空列表，因此 <code>all(lst3)</code> 的返回值为 True；<code>lst4</code> 中有一个元素为 0，因此 <code>all(lst4)</code> 的返回值为 False。</p><p>总之，<code>all()</code> 可以判断一个可迭代对象中的所有元素是否都为 True，是编写 Python 程序中很常用的函数之一。</p><p>any:</p><p>在Python中，<code>any()</code>函数是一个内置函数，它用于检查给定可迭代对象中是否至少有一个元素为真值（True），如果至少有一个元素为真，则返回True，否则返回False。</p><p><code>any()</code>函数的语法如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">any</span><span class="hljs-params">(iterable)</span></span><br></code></pre></td></tr></table></figure><p>其中，<code>iterable</code>是一个可迭代对象，比如列表、元组、集合等。</p><p>下面是一个使用<code>any()</code>函数的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(my_list):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;至少有一个元素为True&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;所有元素都为False&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">至少有一个元素为<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>any()</code>函数检查了<code>my_list</code>列表中的所有元素，发现有一个元素为<code>True</code>，于是返回了<code>True</code>。</p><p><code>any()</code>函数非常适合用于检查可迭代对象中是否存在某个条件的元素，它可以帮助我们编写更加简洁和优雅的代码。</p><p>zip:</p><p><code>zip</code>是Python内置的一个函数，它接受任意多个（包括0个和1个）序列作为参数，返回一个由各个序列中的相同位置的元素组成的元组的迭代器。可以将多个序列进行配对，并同时迭代处理，这个过程类似于拉链的作用，因此也常被称为“拉链函数”。</p><p><code>zip</code>函数的基本语法格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">zip</span>(*iterables)<br></code></pre></td></tr></table></figure><p>其中，<code>*iterables</code>表示传入任意多个序列。</p><p>举例来说，如果有两个列表a和b，想要将它们对应的元素配对在一起，可以使用<code>zip</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>c = <span class="hljs-built_in">zip</span>(a, b)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(c))<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>可以看到，<code>zip</code>函数将a和b两个列表的相同位置的元素进行了配对，并返回了一个包含这些元素的元组列表。</p><p>除了基本用法之外，<code>zip</code>函数还可以和其他函数或语句进行组合使用，例如结合列表推导式或<code>filter</code>函数等，以实现更加复杂的数据处理逻辑。</p><h4 id="1-2偏函数"><a href="#1-2偏函数" class="headerlink" title="1.2偏函数"></a>1.2偏函数</h4><p>问题一：什么是偏函数?<br>在Python的内置模块functools 提供了很多有用的功能，其中一个就是偏函数（partial）。<br>问题二：偏函数有什么用?<br>当函数的参数个数太多，需要简化时，使用 functools.partial可以创建一个新的函数，这个新函数可以固定住<br>原函数的部分参数，从而在调用时更简单。<br>偏函数应用案列<br>#在我们之前学到的内置函数中filter中，调用的时候需要传入两个参数，第一个是函数，第二个是我们需要过滤的可迭<br>代类型的数据，<br>#我们可以通过传入不同的过滤条件去过滤出来我们需要的数据。<br>filter(lambda x:x&gt;3,1i1)<br>filter(lambda x:x&gt;10,1i1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><br><br><span class="hljs-comment"># 偏函数：固定函数的参数，简化函数调用时的参数传递</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">name, datas</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param name: 使用者的名字</span><br><span class="hljs-string">    :param datas: 传递进来的数据</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#125;-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, datas)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">res = work(<span class="hljs-string">&#x27;musen&#x27;</span>,<span class="hljs-string">&#x27;1212&#x27;</span>)<br>res2 = work(<span class="hljs-string">&#x27;musen&#x27;</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>)<br>res3 = work(<span class="hljs-string">&#x27;musen&#x27;</span>,<span class="hljs-string">&#x27;dddd&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(res2)<br><span class="hljs-built_in">print</span>(res3)<br><br>work2 = partial(work, datas=<span class="hljs-string">&#x27;musen&#x27;</span>)<br><br>r1 = work2(<span class="hljs-string">&#x27;222&#x27;</span>)<br>r2 = work2(<span class="hljs-number">333</span>)<br>r3 = work2(<span class="hljs-number">444</span>)<br>r4 = work2(<span class="hljs-number">5555</span>)<br><span class="hljs-built_in">print</span>(r1, r2, r3, r4)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work3</span>(<span class="hljs-params">datas</span>):<br>    work(<span class="hljs-string">&#x27;musen&#x27;</span>, datas)<br></code></pre></td></tr></table></figure><h4 id="1-3闭包函数"><a href="#1-3闭包函数" class="headerlink" title="1.3闭包函数"></a>1.3闭包函数</h4><p>在 Python 中，闭包是指一个函数对象，它引用了外部作用域中的一个或多个变量，即使这些变量在外部作用域已经不存在，它仍然可以访问并修改这些变量。简而言之，闭包是一种特殊的函数，它可以“记住”在创建它的时候所处的环境。</p><p>闭包函数可以用来实现许多有趣的功能，例如在 Python 中，常常使用闭包来实现装饰器。</p><p>闭包函数的基本格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer_func</span>(<span class="hljs-params">param</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner_func</span>():<br>        <span class="hljs-comment"># do something with param</span><br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> inner_func<br></code></pre></td></tr></table></figure><p>其中，<code>outer_func</code> 是外层函数，接受一个参数 <code>param</code>，返回一个内层函数 <code>inner_func</code>，内层函数可以访问外层函数的参数和变量，然后返回一个结果 <code>result</code>。</p><p>当我们调用 <code>outer_func(param)</code> 时，它会返回一个函数对象 <code>inner_func</code>，这个函数可以独立地被调用，但它仍然可以访问外层函数 <code>outer_func</code> 的作用域。这就是闭包的本质。</p><p>下面是一个具体的例子，演示了如何使用闭包来实现一个计数器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_counter</span>():<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">counter</span>():<br>        <span class="hljs-keyword">nonlocal</span> count<br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br>    <span class="hljs-keyword">return</span> counter<br><br>counter1 = make_counter()<br>counter2 = make_counter()<br><br><span class="hljs-built_in">print</span>(counter1())  <span class="hljs-comment"># 输出 1</span><br><span class="hljs-built_in">print</span>(counter1())  <span class="hljs-comment"># 输出 2</span><br><span class="hljs-built_in">print</span>(counter2())  <span class="hljs-comment"># 输出 1</span><br><span class="hljs-built_in">print</span>(counter1())  <span class="hljs-comment"># 输出 3</span><br><span class="hljs-built_in">print</span>(counter2())  <span class="hljs-comment"># 输出 2</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>make_counter</code> 函数，它返回了一个内层函数 <code>counter</code>。在 <code>counter</code> 函数中，我们定义了一个变量 <code>count</code>，并将其初始化为 0。每次调用 <code>counter</code> 函数时，它都会将 <code>count</code> 的值加 1，并返回新的值。</p><p>我们用 <code>make_counter</code> 函数分别创建了两个计数器 <code>counter1</code> 和 <code>counter2</code>，它们是两个独立的函数对象，它们各自维护着自己的 <code>count</code> 变量，彼此之间互不干扰。这正是闭包的特点所在。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python的迭代器和生成器</title>
    <link href="/2020/03/16/Python%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2020/03/16/Python%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Python的迭代器和生成器"><a href="#Python的迭代器和生成器" class="headerlink" title="Python的迭代器和生成器"></a>Python的迭代器和生成器</h1><h3 id="1、可迭代对象"><a href="#1、可迭代对象" class="headerlink" title="1、可迭代对象"></a>1、可迭代对象</h3><p>能够进行迭代逐一返回其成员项的对象称为可迭代对象。可迭代对象的例子包括<br>•所有序列类型：如 1ist、 str 和 tuple，range<br>•非序列类型： dict、set、文件对象:f &#x3D; open(xx，）<br>•实现了_iter_()方法的任意对象（可迭代协议)<br>•实现了序列语义的_getitem_()方法的任意对象。</p><p>1.1、迭代协议：<br>    对象定义了一个 <code>__iter__</code> 方法的，那么这个对象就实现了迭代协议，<code>__iter__</code>方法的返回值必须是一个迭代器</p><p>迭代器(Iterator)：<br>    1.2、迭代器协议<br>        迭代器协议由一个 <code>__iter__</code> 方法和<code>__next__</code>方法共同构成。实现了这两个方法的对象就实现了迭代器协议。<br>    1、对象实现了迭代协议的对象<br>    2、对象实现了<code>__next__</code>方法，<code>__next__</code>方法在迭代完所有数据之后，会抛出<code>StopIteration</code>的错误信息</p><p>迭代器和可迭代对象的操作</p><p>1、实现了迭代器协议的对象，就是一个迭代器<br>2、所有的可迭代对象 都可以通过内置函数iter()转换为迭代器：<br>3、迭代器对象能够使用 内置函数next 进行迭代操作<br>4、所有的迭代器都是可迭代对象，因为迭代器协议包含了迭代协议</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable, Iterator<br><br>st1 = <span class="hljs-string">&#x27;111m22m33&#x27;</span><br>li = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(st1,Iterable))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(li,Iterable))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(st1,Iterator))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(li,Iterator))<br>st1 = <span class="hljs-string">&#x27;abcd&#x27;</span><br>li = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><span class="hljs-comment"># 可迭代对象转换为迭代器:内置函数iter()</span><br>s = <span class="hljs-built_in">iter</span>(st1)   <span class="hljs-comment">#  st1.__iter__()</span><br><span class="hljs-comment"># 迭代器可以使用next进行迭代操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))  <span class="hljs-comment"># st1.__next__()</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br></code></pre></td></tr></table></figure><h5 id="5-自定义可迭代对象"><a href="#5-自定义可迭代对象" class="headerlink" title="5.自定义可迭代对象"></a>5.自定义可迭代对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass1</span>:<br><br>    <span class="hljs-comment"># 实现迭代协议</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>([<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>])<br><br><br>obj = MyClass1()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> obj:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass2</span>:<br>    value = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><br>    <span class="hljs-comment"># 实现序列语义</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> self.value[item]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">pass</span><br><br>obj = MyClass2()<br><br>res = obj[<span class="hljs-number">0</span>]   <span class="hljs-comment">#  obj.__getitem__(0)</span><br><br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h4 id="1-1创建生成器"><a href="#1-1创建生成器" class="headerlink" title="1.1创建生成器"></a>1.1创建生成器</h4><p>#方式一：生成器表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">g = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))<br><br><span class="hljs-built_in">print</span>(g)<br><span class="hljs-comment"># # 生成器能不能使用next进行迭代操作？？</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-comment"># # 注意点：生成器是一种特殊的迭代器，在使用next进行迭代时，数据迭代完之后，会抛出StopIteration异常</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br></code></pre></td></tr></table></figure><p>*方式二：生成器函数<br>注意点：<br>1、函数内部只要定义yield这个关键字，那么这个函数就是一个生成器函数<br>2、生成器函数调用是不会执行内部代码，而是直接返回一个生成器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----work函数----&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------1--&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">888</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----2------&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">777</span><br><br><br>g = work()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;g:&#x27;</span>, g)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;生成的数据为：&#x27;</span>, <span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;生成的数据为：&#x27;</span>, <span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;生成的数据为：&#x27;</span>, <span class="hljs-built_in">next</span>(g))<br></code></pre></td></tr></table></figure><p>#生成器内部不直接存储数据，只存储生成数据的计算表达式（在保存大规模数据时，可以节约内存消耗）。</p><h5 id="1-1生成器和列表对比"><a href="#1-1生成器和列表对比" class="headerlink" title="1.1生成器和列表对比"></a>1.1生成器和列表对比</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">li = [<span class="hljs-number">111</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br>dic = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">11</span>, <span class="hljs-number">2</span>: <span class="hljs-number">3333</span>&#125;<br><br><span class="hljs-comment"># 生成器内部不直接存储数据，只存储生成数据的计算表达式（在处理大规模的数据时，可以节约内层消耗）</span><br>g1 = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-built_in">print</span>(li)<br><span class="hljs-built_in">print</span>(dic)<br><span class="hljs-built_in">print</span>(g1)<br><br>li = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500000</span>)]<br>res = <span class="hljs-built_in">input</span>()<br><br>li = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000000</span>))<br>res = <span class="hljs-built_in">input</span>()<br></code></pre></td></tr></table></figure><h3 id="2-生成器函数"><a href="#2-生成器函数" class="headerlink" title="2 生成器函数"></a>2 生成器函数</h3><h4 id="2-1-生成器的close方法-关闭生成器"><a href="#2-1-生成器的close方法-关闭生成器" class="headerlink" title="2.1 生成器的close方法:关闭生成器"></a>2.1 生成器的close方法:关闭生成器</h4><p>print(next(g))</p><p>print(next(g))<br>print(next(g))<br>g.close()<br>print(next(g))</p><h4 id="2-2-send方法"><a href="#2-2-send方法" class="headerlink" title="2.2 send方法"></a>2.2 send方法</h4><p>给生成器传递参数(与生成器内部进行数据交互)<br>生成器的send方法必须在使用了一次next之后才能使用。</p><p>print(‘next方法执行的结果:’, next(g))</p><p>res &#x3D; g.send(‘musen’)</p><p>iprint(‘send方法执行的结果:’, res)<br>res &#x3D; g.send(‘999’)<br>print(‘send方法执行的结果:’, res)</p><p>res &#x3D; g.send(‘python’)</p><p>print(‘send方法执行的结果:’, res)</p><h4 id="2-3生成器根据send传递的参数来生成数据"><a href="#2-3生成器根据send传递的参数来生成数据" class="headerlink" title="2.3生成器根据send传递的参数来生成数据"></a>2.3生成器根据send传递的参数来生成数据</h4><p>如果要实现根据参数去生成数据的生成器：<br>1、使用send传递了参数<br>2、直接使用next 没有传参数<br>需求：根擀send方法传递的值类生成参数的2次方<br>def work()：<br>val &#x3D; None<br>for i in range(100):<br>if val:<br>val &#x3D; yield val ** 2<br>else:<br>val&#x3D; yield i+1<br>g&#x3D; work()<br>print(next(g))<br>print(g.send(11))<br>print(g.send(20))<br>print(next(g))<br>print(g.send(11))<br>print(g.send(20))<br>print(next(g))</p><h3 id="3、throw方法：在生成器内部抛出指定的异常"><a href="#3、throw方法：在生成器内部抛出指定的异常" class="headerlink" title="3、throw方法：在生成器内部抛出指定的异常"></a>3、throw方法：在生成器内部抛出指定的异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># raise ValueError</span><br>g.throw(ValueError)<br></code></pre></td></tr></table></figure><h3 id="4-根据参数生成数据的案例"><a href="#4-根据参数生成数据的案例" class="headerlink" title="4.根据参数生成数据的案例"></a>4.根据参数生成数据的案例</h3><p>生成器根据send传递的参数来生成数据:</p><p>如果要实现根据参数去生成数据的生成器,需要考虑下面这两种情况：<br>    1、使用send传递了参数<br>    2、直接使用next 没有传参数</p><p>#需求：根据send方法传递的值类生成 参数的2次方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    val = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        <span class="hljs-keyword">if</span> val:<br>            val = <span class="hljs-keyword">yield</span> val ** <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            val = <span class="hljs-keyword">yield</span> i + <span class="hljs-number">1</span><br><br><br>g = work()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">20</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">20</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">20</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br></code></pre></td></tr></table></figure><h3 id="5-pytest中利用生成器实现测试夹具的执行流程"><a href="#5-pytest中利用生成器实现测试夹具的执行流程" class="headerlink" title="5.pytest中利用生成器实现测试夹具的执行流程"></a>5.pytest中利用生成器实现测试夹具的执行流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-comment"># 用例前置执行</span><br>    <span class="hljs-comment"># 此处登录获取token</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;用例执行的前置脚本&quot;</span>)<br>    token = <span class="hljs-string">&#x27;asfsgyuajioghj&#x27;</span><br>    <span class="hljs-keyword">yield</span> token<br>    <span class="hljs-comment"># 用例后置执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;用例执行的后置脚本&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_01</span>(<span class="hljs-params">login</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---测试用例的执行代码----------&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;token的值：&quot;</span>, login)<br>    expected = <span class="hljs-string">&#x27;OK&#x27;</span><br>    res = <span class="hljs-string">&#x27;OK&#x27;</span><br>    <span class="hljs-keyword">assert</span> expected == res<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1、检查测试用例的是否有指定测试夹具</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 夹具本质是一个生成器函数  </span><br><span class="hljs-string">#  pytest测试夹具执行的流程：</span><br><span class="hljs-string"></span><br><span class="hljs-string">g = login()</span><br><span class="hljs-string">token = next(g)</span><br><span class="hljs-string"></span><br><span class="hljs-string">test_01(token)</span><br><span class="hljs-string"></span><br><span class="hljs-string">try:</span><br><span class="hljs-string">    next(g)</span><br><span class="hljs-string">expect:</span><br><span class="hljs-string">    pass</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>总结</p><p>在Python中，迭代器和生成器都是用来遍历数据序列的工具，但它们的实现方式和作用略有不同。</p><p>迭代器是一种对象，可以通过next()方法依次访问序列中的元素。Python内置的许多数据类型都支持迭代器，比如列表、元组、字符串等。通过迭代器，我们可以遍历整个序列，而无需将整个序列加载到内存中，从而节省内存空间。迭代器可以通过定义一个__iter__()方法来创建，并且通常需要定义一个__next__()方法来遍历序列中的元素。</p><p>生成器是一种特殊的迭代器，可以通过yield语句将结果生成到调用方。生成器函数在执行过程中可以挂起，并且在下次调用时可以从挂起的位置继续执行。与迭代器相比，生成器可以更加灵活地控制数据的生成和消耗，可以有效地处理大规模数据和无限序列的问题。生成器可以通过定义一个包含yield语句的函数来创建。</p><p>迭代器和生成器的作用主要有以下几个方面：</p><ol><li>节省内存空间：通过迭代器和生成器，我们可以逐个访问序列中的元素，而无需将整个序列加载到内存中，从而节省内存空间。</li><li>适用于大规模数据和无限序列：迭代器和生成器可以更加灵活地控制数据的生成和消耗，可以有效地处理大规模数据和无限序列的问题。</li><li>增加程序的可读性和可维护性：使用迭代器和生成器可以使代码更加简洁、清晰，提高代码的可读性和可维护性。</li><li>方便数据处理和转换：通过迭代器和生成器，我们可以方便地对序列进行处理和转换，例如对序列中的元素进行筛选、排序、合并等操作。</li></ol><p>总之，迭代器和生成器是Python中非常重要的语言特性，能够大大提高代码的效率和可读性，是Python程序员必须掌握的基本技能之一。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python推导式详解</title>
    <link href="/2020/03/12/Python%E6%8E%A8%E5%AF%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/03/12/Python%E6%8E%A8%E5%AF%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Python推导式详解"><a href="#Python推导式详解" class="headerlink" title="Python推导式详解"></a>Python推导式详解</h1><p>Python推导式（Comprehension）是一种简洁而强大的语言特性，用于快速创建序列、集合和字典等数据结构。它能够简化代码，使代码更加清晰易懂。</p><p>推倒式的主要作用是通过一种紧凑的语法形式创建新的数据结构，可以在一个简单的表达式中完成复杂的操作，从而简化了代码的编写和阅读。</p><h4 id="1-推导式语法："><a href="#1-推导式语法：" class="headerlink" title="1.推导式语法："></a>1.推导式语法：</h4><p>作用：根据一些规律 迅速生成列表</p><p>li &#x3D; [ x for i in xxx ]</p><p>1.需求 如何快速生成 一个[data0 ,data1…data99]的列表？</p><p>#for循环 写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">li = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    li.append(<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><span class="hljs-built_in">print</span>(li)<br></code></pre></td></tr></table></figure><p>#列表推导式实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">li2 = [<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i)   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)]<br><br><span class="hljs-built_in">print</span>(li2)<br></code></pre></td></tr></table></figure><p>#推导式结合if 进行数据过滤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&#x27;data0&#x27;</span>, <span class="hljs-string">&#x27;data1&#x27;</span>, <span class="hljs-string">&#x27;data2&#x27;</span>, <span class="hljs-string">&#x27;data3&#x27;</span>, <span class="hljs-string">&#x27;data4&#x27;</span>, <span class="hljs-string">&#x27;data5&#x27;</span>, <span class="hljs-string">&#x27;data6&#x27;</span>, <span class="hljs-string">&#x27;data7&#x27;</span>, <span class="hljs-string">&#x27;data8&#x27;</span>, <span class="hljs-string">&#x27;data9&#x27;</span>, <span class="hljs-string">&#x27;data10&#x27;</span>, <span class="hljs-string">&#x27;data11&#x27;</span>,<br>       <span class="hljs-string">&#x27;data12&#x27;</span>, <span class="hljs-string">&#x27;data13&#x27;</span>, <span class="hljs-string">&#x27;data14&#x27;</span>, <span class="hljs-string">&#x27;data15&#x27;</span>, <span class="hljs-string">&#x27;data16&#x27;</span>, <span class="hljs-string">&#x27;data17&#x27;</span>, <span class="hljs-string">&#x27;data18&#x27;</span>, <span class="hljs-string">&#x27;data19&#x27;</span>, <span class="hljs-string">&#x27;data20&#x27;</span>, <span class="hljs-string">&#x27;data21&#x27;</span>, <span class="hljs-string">&#x27;data22&#x27;</span>,<br>       <span class="hljs-string">&#x27;data23&#x27;</span>, <span class="hljs-string">&#x27;data24&#x27;</span>, <span class="hljs-string">&#x27;data25&#x27;</span>, <span class="hljs-string">&#x27;data26&#x27;</span>, <span class="hljs-string">&#x27;data27&#x27;</span>, <span class="hljs-string">&#x27;data28&#x27;</span>, <span class="hljs-string">&#x27;data29&#x27;</span>, <span class="hljs-string">&#x27;data30&#x27;</span>, <span class="hljs-string">&#x27;data31&#x27;</span>, <span class="hljs-string">&#x27;data32&#x27;</span>, <span class="hljs-string">&#x27;data33&#x27;</span>,<br>       <span class="hljs-string">&#x27;data34&#x27;</span>, <span class="hljs-string">&#x27;data35&#x27;</span>, <span class="hljs-string">&#x27;data36&#x27;</span>, <span class="hljs-string">&#x27;data37&#x27;</span>, <span class="hljs-string">&#x27;data38&#x27;</span>, <span class="hljs-string">&#x27;data39&#x27;</span>, <span class="hljs-string">&#x27;data40&#x27;</span>, <span class="hljs-string">&#x27;data41&#x27;</span>, <span class="hljs-string">&#x27;data42&#x27;</span>, <span class="hljs-string">&#x27;data43&#x27;</span>, <span class="hljs-string">&#x27;data44&#x27;</span>,<br>       <span class="hljs-string">&#x27;data45&#x27;</span>, <span class="hljs-string">&#x27;data46&#x27;</span>, <span class="hljs-string">&#x27;data47&#x27;</span>, <span class="hljs-string">&#x27;data48&#x27;</span>, <span class="hljs-string">&#x27;data49&#x27;</span>, <span class="hljs-string">&#x27;data50&#x27;</span>, <span class="hljs-string">&#x27;data51&#x27;</span>, <span class="hljs-string">&#x27;data52&#x27;</span>, <span class="hljs-string">&#x27;data53&#x27;</span>, <span class="hljs-string">&#x27;data54&#x27;</span>, <span class="hljs-string">&#x27;data55&#x27;</span>,<br>       <span class="hljs-string">&#x27;data56&#x27;</span>, <span class="hljs-string">&#x27;data57&#x27;</span>, <span class="hljs-string">&#x27;data58&#x27;</span>, <span class="hljs-string">&#x27;data59&#x27;</span>, <span class="hljs-string">&#x27;data60&#x27;</span>, <span class="hljs-string">&#x27;data61&#x27;</span>, <span class="hljs-string">&#x27;data62&#x27;</span>, <span class="hljs-string">&#x27;data63&#x27;</span>, <span class="hljs-string">&#x27;data64&#x27;</span>, <span class="hljs-string">&#x27;data65&#x27;</span>, <span class="hljs-string">&#x27;data66&#x27;</span>,<br>       <span class="hljs-string">&#x27;data67&#x27;</span>, <span class="hljs-string">&#x27;data68&#x27;</span>, <span class="hljs-string">&#x27;data69&#x27;</span>, <span class="hljs-string">&#x27;data70&#x27;</span>, <span class="hljs-string">&#x27;data71&#x27;</span>, <span class="hljs-string">&#x27;data72&#x27;</span>, <span class="hljs-string">&#x27;data73&#x27;</span>, <span class="hljs-string">&#x27;data74&#x27;</span>, <span class="hljs-string">&#x27;data75&#x27;</span>, <span class="hljs-string">&#x27;data76&#x27;</span>, <span class="hljs-string">&#x27;data77&#x27;</span>,<br>       <span class="hljs-string">&#x27;data78&#x27;</span>, <span class="hljs-string">&#x27;data79&#x27;</span>, <span class="hljs-string">&#x27;data80&#x27;</span>, <span class="hljs-string">&#x27;data81&#x27;</span>, <span class="hljs-string">&#x27;data82&#x27;</span>, <span class="hljs-string">&#x27;data83&#x27;</span>, <span class="hljs-string">&#x27;data84&#x27;</span>, <span class="hljs-string">&#x27;data85&#x27;</span>, <span class="hljs-string">&#x27;data86&#x27;</span>, <span class="hljs-string">&#x27;data87&#x27;</span>, <span class="hljs-string">&#x27;data88&#x27;</span>,<br>       <span class="hljs-string">&#x27;data89&#x27;</span>, <span class="hljs-string">&#x27;data90&#x27;</span>, <span class="hljs-string">&#x27;data91&#x27;</span>, <span class="hljs-string">&#x27;data92&#x27;</span>, <span class="hljs-string">&#x27;data93&#x27;</span>, <span class="hljs-string">&#x27;data94&#x27;</span>, <span class="hljs-string">&#x27;data95&#x27;</span>, <span class="hljs-string">&#x27;data96&#x27;</span>, <span class="hljs-string">&#x27;data97&#x27;</span>, <span class="hljs-string">&#x27;data98&#x27;</span>, <span class="hljs-string">&#x27;data99&#x27;</span>]<br></code></pre></td></tr></table></figure><p>#把上述data为偶数的数据过滤掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [ <span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i)   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)  <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span> ]<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>#需求 ：生成一个[‘data0’,’musen1’,’data1’,’musen2’……’data98’,’musen99’,]</p><p>#常规语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">li = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br><br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        li.append(<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br>    <span class="hljs-keyword">else</span>:<br>        li.append(<span class="hljs-string">&quot;musen&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><span class="hljs-built_in">print</span>(li)<br></code></pre></td></tr></table></figure><h4 id="2-三元运算符"><a href="#2-三元运算符" class="headerlink" title="2.三元运算符"></a>2.三元运算符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n =<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个数字：&quot;</span>))<br><br>number = <span class="hljs-string">&quot;大于10&quot;</span><span class="hljs-keyword">if</span> <span class="hljs-number">10</span> &lt; n <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;小于10&quot;</span><br><br><span class="hljs-built_in">print</span>(number)<br></code></pre></td></tr></table></figure><h5 id="2-1推导式结合：三元运算符使用"><a href="#2-1推导式结合：三元运算符使用" class="headerlink" title="2.1推导式结合：三元运算符使用"></a>2.1推导式结合：三元运算符使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>  <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;musen&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)]<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h4 id="3-字典推导式"><a href="#3-字典推导式" class="headerlink" title="3.字典推导式"></a>3.字典推导式</h4><h5 id="3-1字典推导式语法"><a href="#3-1字典推导式语法" class="headerlink" title="3.1字典推导式语法"></a>3.1字典推导式语法</h5><p>#字典推导式基本语法</p><p><code>dic = &#123;k:v for x in xxx&#125;</code></p><p>#字典推导式结合 if 进行过滤</p><p><code>dic = &#123;k:v for x in xxx if xxx&#125;</code></p><p>#字典推导式结合 三元运算符 进行过滤</p><p><code>dic = &#123;k:v  if xx else xxx  for x in xxx &#125;</code></p><h5 id="3-2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据"><a href="#3-2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据" class="headerlink" title="3.2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据"></a>3.2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据</h5><p>li &#x3D; [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]</p><p>#之前for循环的做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1= &#123;&#125;<br><br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(li):<br><br>​dict1[i] = j<br><br><span class="hljs-built_in">print</span>(dict1)<br></code></pre></td></tr></table></figure><p>#字典推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;i:j  <span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(li) &#125;<br><br>​<span class="hljs-built_in">print</span>(dic)<br></code></pre></td></tr></table></figure><h5 id="3-3-使用字典推倒式将下面字符串格式的数据，改成字典类型的数据"><a href="#3-3-使用字典推倒式将下面字符串格式的数据，改成字典类型的数据" class="headerlink" title="3.3  使用字典推倒式将下面字符串格式的数据，改成字典类型的数据"></a>3.3  使用字典推倒式将下面字符串格式的数据，改成字典类型的数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">cookie = <span class="hljs-string">&#x27;BIDUPSID=D0727533D7147B7;PSTM=1530348042; BAIDUID=B1005C9BC2EB28; &#x27;</span> \<br>         <span class="hljs-string">&#x27;sugstore=0;__cfduid=d0a13458f8ac2a;BD_UPN=12314353;ispeed_lsm=2;&#x27;</span> \<br>         <span class="hljs-string">&#x27;BDORZ=B490B5EBF6F3CD402&#x27;</span><br><br>res = cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)<br>dic = &#123;&#125;<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> res:<br>     d = item.split(<span class="hljs-string">&#x27;=&#x27;</span>)<br>     key = d[<span class="hljs-number">0</span>]<br>     value = d[<span class="hljs-number">1</span>]<br>     dic[key] =value<br> <span class="hljs-built_in">print</span>(dic)<br></code></pre></td></tr></table></figure><h6 id="3-4-1字典推导式实现"><a href="#3-4-1字典推导式实现" class="headerlink" title="3.4.1字典推导式实现"></a>3.4.1字典推导式实现</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = &#123;item.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: item.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)&#125;<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h6 id="3-4-2推导式中双重for嵌套"><a href="#3-4-2推导式中双重for嵌套" class="headerlink" title="3.4.2推导式中双重for嵌套"></a>3.4.2推导式中双重for嵌套</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = &#123;k: v <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> [item.split(<span class="hljs-string">&#x27;=&#x27;</span>)]&#125;<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h6 id="3-4-3列表推导式集合字典推导式"><a href="#3-4-3列表推导式集合字典推导式" class="headerlink" title="3.4.3列表推导式集合字典推导式"></a>3.4.3列表推导式集合字典推导式</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [item.split(<span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)]<br><span class="hljs-comment"># print(res)</span><br>dic = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> res&#125;<br><span class="hljs-built_in">print</span>(dic)<br></code></pre></td></tr></table></figure><p>3.4.4列表推导式集合字典推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dic2 = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> [item.split(<span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)]&#125;<br><span class="hljs-built_in">print</span>(dic2)<br></code></pre></td></tr></table></figure><h5 id="3-5推导式中多重for嵌套"><a href="#3-5推导式中多重for嵌套" class="headerlink" title="3.5推导式中多重for嵌套"></a>3.5推导式中多重for嵌套</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">li =[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]:<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]:<br>        li.append(<span class="hljs-string">&#x27;&#123;&#125;-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i,v))<br><span class="hljs-built_in">print</span>(li)<br><br><br>li2 = [<span class="hljs-string">&#x27;&#123;&#125;-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i, v) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>] <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]]<br><span class="hljs-built_in">print</span>(li2)<br><br></code></pre></td></tr></table></figure><h4 id="4-集合推导式和生成器表达式"><a href="#4-集合推导式和生成器表达式" class="headerlink" title="4.集合推导式和生成器表达式"></a>4.集合推导式和生成器表达式</h4><p>列表推导式 : [ x for x in XXX ]<br>字典推导式 : { k:v  for x in XXX }</p><p>集合推导式  : { x for x in XXX }<br>生成器表达式 : ( x for x in XXX ) </p><h5 id="4-1集合推导式"><a href="#4-1集合推导式" class="headerlink" title="4.1集合推导式"></a>4.1集合推导式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">se = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)&#125;<br><span class="hljs-built_in">print</span>(se)<br></code></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的编码规范</title>
    <link href="/2020/03/10/pep8/"/>
    <url>/2020/03/10/pep8/</url>
    
    <content type="html"><![CDATA[<h1 id="python的编码规范"><a href="#python的编码规范" class="headerlink" title="python的编码规范"></a>python的编码规范</h1><h4 id="1-1-pep8规范"><a href="#1-1-pep8规范" class="headerlink" title="1.1 pep8规范"></a>1.1 pep8规范</h4><h5 id="1-缩进"><a href="#1-缩进" class="headerlink" title="1.缩进"></a>1.缩进</h5><p>*每一级缩进使用4个空格。</p><p>*续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐<a href="https://blog.csdn.net/ratsniper/article/details/78954852#fn:7">3</a>。当使用挂行缩进时，应该考虑到第一行不应该有参数，以及使用缩进以区分自己是续行。</p><h5 id="2-行的最大长度"><a href="#2-行的最大长度" class="headerlink" title="2.行的最大长度"></a>2.行的最大长度</h5><p>Ctrl+Alt+L (格式化代码快捷键 ——&gt;&gt; 代码会自动按照pep8规范格式化)</p><p>*所有行限制的最大字符数为79个.</p><p>*注释的限制最大字符数是72个</p><p>\ 表示隐式换行</p><p>*如果一个字符串过长，可以回车，pycharm会自动补一个\  隐式换行连接符。</p><h5 id="3-空行"><a href="#3-空行" class="headerlink" title="3.空行"></a>3.空行</h5><p>*顶层函数和类的定义，前后用两个空行隔开。</p><p>*类的方法定义用一个空行隔开</p><h5 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h5><p>与代码相矛盾的注释比没有注释还糟，当代码更改时，优先更新对应的注释！<br>注释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！)。<br>如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号。<br>在句尾结束的时候应该使用两个空格。<br>当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格。<br>在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读。</p><h6 id="1-块注释"><a href="#1-块注释" class="headerlink" title="1.块注释"></a>1.块注释</h6><p>块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。<br>块注释内部的段落通过只有一个#的空行分隔。</p><h6 id="2-行内注释"><a href="#2-行内注释" class="headerlink" title="2.行内注释"></a>2.行内注释</h6><p>有节制地使用行内注释。<br>行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始。<br>事实上，如果状态明显的话，行内注释是不必要的，反而会分散注意力。</p><h6 id="3-文档字符串注释"><a href="#3-文档字符串注释" class="headerlink" title="3.文档字符串注释"></a>3.文档字符串注释</h6><p>编写好的文档说明（也叫“docstrings”）的约定在<a href="http://legacy.python.org/dev/peps/pep-0257/">PEP 257</a>中永恒不变。</p><ul><li>要为所有的公共模块，函数，类以及方法编写文档说明。非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后。</li><li><a href="http://legacy.python.org/dev/peps/pep-0257/">PEP 257</a> 描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行</li></ul><p> <code>#__doc__ 属性：获取对象的文档字符串注释</code></p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests`<br><br>`<span class="hljs-built_in">print</span>(requests.__doc__)<br></code></pre></td></tr></table></figure><p>类中的文档字符串注释：</p><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Musen</span>:`<br><br>`<span class="hljs-string">&quot;&quot;&quot;`</span><br><span class="hljs-string"></span><br><span class="hljs-string">`mesen这个类的文档字符串注释`</span><br><span class="hljs-string"></span><br><span class="hljs-string">`详细的功能介绍`</span><br><span class="hljs-string"></span><br><span class="hljs-string">`&quot;&quot;&quot;</span>`<br><br>​<span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>(<span class="hljs-params">self,name :<span class="hljs-built_in">str</span>,age :<span class="hljs-built_in">int</span></span>)  -&gt; <span class="hljs-literal">None</span>:   <span class="hljs-comment">#name str类型 age int类型 方法返回值 为None </span><br><br>​<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">​work1这个方法的文档字符串注释</span><br><span class="hljs-string"></span><br><span class="hljs-string">​该方法功能的整体说明</span><br><span class="hljs-string"></span><br><span class="hljs-string">​param name：名字</span><br><span class="hljs-string"></span><br><span class="hljs-string">​param  age：年龄</span><br><span class="hljs-string"></span><br><span class="hljs-string">​&quot;&quot;&quot;</span><br><br>`<span class="hljs-built_in">print</span>(MuSen.__doc__)<br></code></pre></td></tr></table></figure><h5 id="5-命名的约定"><a href="#5-命名的约定" class="headerlink" title="5.命名的约定"></a>5.命名的约定</h5><h6 id="1-变量命名"><a href="#1-变量命名" class="headerlink" title="1.变量命名"></a>1.变量命名</h6><p>永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名。<br>在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替。</p><h6 id="2-函数命名"><a href="#2-函数命名" class="headerlink" title="2.函数命名"></a>2.函数命名</h6><p>函数名应该小写，如果想提高可读性可以用下划线分隔。<br>大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用（比如 threading.py），保持向后兼容性。</p><h6 id="3-类命名"><a href="#3-类命名" class="headerlink" title="3.类命名"></a>3.类命名</h6><p>类名一般使用首字母大写的约定。<br>在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替。<br>注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量。</p><p>4.类里面的函数和方法参数</p><p>始终要将 self 作为实例方法的的第一个参数。<br>始终要将 cls 作为类静态方法的第一个参数。<br>如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好。（也许最好用同义词来避免这种冲突）</p><p>参考资料:</p><p>pep8编码规范 <a href="https://blog.csdn.net/ratsniper/article/details/78954852">https://blog.csdn.net/ratsniper/article/details/78954852</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python基础</tag>
      
      <tag>Python编码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
