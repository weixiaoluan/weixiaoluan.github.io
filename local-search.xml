<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python高阶编程总结</title>
    <link href="/2020/06/15/Python%E9%AB%98%E9%98%B6%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2020/06/15/Python%E9%AB%98%E9%98%B6%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Python高阶编程总结"><a href="#Python高阶编程总结" class="headerlink" title="Python高阶编程总结"></a>Python高阶编程总结</h1><h2 id="web框架封装之路由分发"><a href="#web框架封装之路由分发" class="headerlink" title="web框架封装之路由分发"></a>web框架封装之路由分发</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">from</span> concurrent.futures.thread <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServe</span>:<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">9988</span></span>):<br><br>    <span class="hljs-comment"># 1、socket.socket：创建一个tcp套接字</span><br><br>​    self.tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br>    <span class="hljs-comment"># 2、bind：绑定ip和端口</span><br><br>​    self.tcp_socket.bind((host, port))<br>​    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务已启动！地址:http://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(host, port))<br><br>    <span class="hljs-comment"># 3、listen：设置连接池最大的连接数</span><br><br>​    self.tcp_socket.listen(<span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, max_workers=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=max_workers) <span class="hljs-keyword">as</span> tps:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>            <span class="hljs-comment"># 4、accept：等待客户端进行连接</span><br><br>​            cli_socket, addr = self.tcp_socket.accept()<br><br>            <span class="hljs-comment"># 提交处理请求的任务函数到线程池</span><br><br>​            tps.submit(self.handle_request, cli_socket)<br>​            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;客户端<span class="hljs-subst">&#123;addr&#125;</span>,建立了连接&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_request</span>(<span class="hljs-params">self, cli_socket</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;处理客户端请求的方法&quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 1、解析客户端的请求数据</span><br><br>​    request_info = self.parser_request(cli_socket)<br>​    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求数据&quot;</span>, request_info)<br>​    code = <span class="hljs-number">200</span><br>​    desc = <span class="hljs-string">&#x27;OK&#x27;</span><br><br>    <span class="hljs-comment"># 2、判断请求路径，不同的请求路径交给不同的方法去处理</span><br><br>​    path = request_info[<span class="hljs-string">&#x27;path&#x27;</span>]<br><br>    <span class="hljs-comment"># 通过请求路径，获取路由关系中对应的处理函数</span><br><br>​    handle_func = ulrs.get(path)<br>​    <span class="hljs-keyword">if</span> handle_func:<br><br>        <span class="hljs-comment"># 调用获取到的处理函数</span><br><br>​        body = handle_func(request_info)<br>​    <span class="hljs-keyword">else</span>:<br>​        body = <span class="hljs-string">&#x27;请求的路径不存在&#x27;</span><br>​        code = <span class="hljs-number">404</span><br>​        desc = <span class="hljs-string">&#x27;Not Found&#x27;</span><br><br>    <span class="hljs-comment"># if request_info[&#x27;path&#x27;] == &#x27;/&#x27;:</span><br><br>    <span class="hljs-comment">#     # 请求根路径</span><br><br>    <span class="hljs-comment">#     body = index(request_info)</span><br><br>    <span class="hljs-comment"># elif request_info[&#x27;path&#x27;] == &#x27;/user/login&#x27;:</span><br><br>    <span class="hljs-comment">#     # 登录的地址</span><br><br>    <span class="hljs-comment">#     body = login(request_info)</span><br><br>    <span class="hljs-comment"># else:</span><br><br>    <span class="hljs-comment">#     body = &#x27;请求的路径不存在&#x27;</span><br><br>    <span class="hljs-comment">#     code = 404</span><br><br>    <span class="hljs-comment">#     desc = &#x27;Not Found&#x27;</span><br><br>    <span class="hljs-comment"># 3、返回响应结果</span><br><br>​    header = <span class="hljs-string">&#x27;HTTP/1.1 &#123;&#125; &#123;&#125;\r\n&#x27;</span>.<span class="hljs-built_in">format</span>(code, desc)<br>​    header += <span class="hljs-string">&#x27;Content-Type: text/html;charset=utf-8\r\n&#x27;</span><br>​    header += <span class="hljs-string">&#x27;\r\n\r\n&#x27;</span><br><br>    <span class="hljs-comment"># 读取html文件</span><br><br>​    msg = (header + body).encode()<br>​    cli_socket.send(msg)<br><br>    <span class="hljs-comment"># 7、关闭套接字</span><br><br>​    cli_socket.close()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parser_request</span>(<span class="hljs-params">self, cli_socket</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    解析http请求报文</span><br><span class="hljs-string">    :param cli_socket: 处理客户端的套接字</span><br><span class="hljs-string">    :return: 解析好的请求信息</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    request_info = &#123;<br>        <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-string">&#x27;method&#x27;</span>: <span class="hljs-string">&quot;GET&quot;</span>,<br>        <span class="hljs-string">&quot;params&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;data_params&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;json_params&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;headers&quot;</span>: <span class="hljs-literal">None</span><br>    &#125;<br><br>    <span class="hljs-comment"># 接收客户端请求数据,并转换为字符串</span><br><br>​    data = cli_socket.recv(<span class="hljs-number">10240</span>).decode()<br>​    data = data.split(<span class="hljs-string">&#x27;\r\n&#x27;</span>)<br><br>    <span class="hljs-comment"># 请求方法，</span><br><br>​    one_lines = data[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27; &#x27;</span>)<br>​    request_info[<span class="hljs-string">&#x27;method&#x27;</span>] = one_lines[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 请求路径</span><br><br>​    path = one_lines[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 请求头</span><br><br>​    headers = &#123;item.split(<span class="hljs-string">&#x27;: &#x27;</span>)[<span class="hljs-number">0</span>]: item.split(<span class="hljs-string">&#x27;: &#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data[<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>]&#125;<br><br>    <span class="hljs-comment"># 请求参数</span><br><br>    <span class="hljs-comment"># 1、查询字符串参数（get请求传参）</span><br><br>​    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;?&#x27;</span> <span class="hljs-keyword">in</span> path:<br>​        path, params = path.split(<span class="hljs-string">&#x27;?&#x27;</span>)<br>​        params = &#123;i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> params.split(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;<br>​    <span class="hljs-keyword">else</span>:<br>​        params = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 判断是否有请求体：</span><br><br>​    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-keyword">in</span> headers:<br>​        <span class="hljs-keyword">if</span> headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] == <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>:<br>​            request_info[<span class="hljs-string">&#x27;data_params&#x27;</span>] = &#123;i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data[-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;<br><br>            <span class="hljs-comment"># 2、表单参数</span><br><br>​        <span class="hljs-keyword">elif</span> headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] == <span class="hljs-string">&#x27;application/json&#x27;</span>:<br>​            <span class="hljs-keyword">import</span> json<br><br>            <span class="hljs-comment"># 3、json参数</span><br><br>​            request_info[<span class="hljs-string">&#x27;json_params&#x27;</span>] = json.loads(data[-<span class="hljs-number">1</span>])<br>​    request_info[<span class="hljs-string">&#x27;path&#x27;</span>] = path<br>​    request_info[<span class="hljs-string">&#x27;params&#x27;</span>] = params<br>​    request_info[<span class="hljs-string">&#x27;headers&#x27;</span>] = headers<br>​    <span class="hljs-keyword">return</span> request_info<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;处理登录请求的方法&quot;&quot;&quot;</span><br>    body = <span class="hljs-string">&#x27;&lt;h1&gt;登录页面&lt;/h1&gt;&#x27;</span><br><br><span class="hljs-keyword">return</span> body<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;请求首页对应的处理方法&quot;&quot;&quot;</span><br>    body = <span class="hljs-string">&#x27;&lt;h1&gt;项目首页&lt;/h1&gt;&#x27;</span><br>    <span class="hljs-keyword">return</span> body<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">request</span>):<br>    body = <span class="hljs-string">&#x27;&lt;h1&gt;注册页面&lt;/h1&gt;&#x27;</span><br>    <span class="hljs-keyword">return</span> body<br><br><br>ulrs = &#123;<br>    <span class="hljs-string">&quot;/&quot;</span>: index,<br>    <span class="hljs-string">&quot;/user/login&quot;</span>: login,<br>    <span class="hljs-string">&#x27;/user/register&#x27;</span>: register<br>&#125;<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = HttpServe()<br>    app.run(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h2 id="flask框架路由装饰器的实现"><a href="#flask框架路由装饰器的实现" class="headerlink" title="flask框架路由装饰器的实现"></a>flask框架路由装饰器的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">from</span> concurrent.futures.thread <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br>ulrs = &#123;<br>    <span class="hljs-comment"># &quot;/&quot;: index,</span><br>    <span class="hljs-comment"># &quot;/user/login&quot;: login,</span><br>    <span class="hljs-comment"># &#x27;/user/register&#x27;: register</span><br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServe</span>:<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">9988</span></span>):<br><br>    <span class="hljs-comment"># 1、socket.socket：创建一个tcp套接字</span><br><br>​    self.tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br>    <span class="hljs-comment"># 2、bind：绑定ip和端口</span><br><br>​    self.tcp_socket.bind((host, port))<br>​    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务已启动！地址:http://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(host, port))<br><br>    <span class="hljs-comment"># 3、listen：设置连接池最大的连接数</span><br><br>​    self.tcp_socket.listen(<span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, max_workers=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=max_workers) <span class="hljs-keyword">as</span> tps:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>            <span class="hljs-comment"># 4、accept：等待客户端进行连接</span><br><br>​            cli_socket, addr = self.tcp_socket.accept()<br><br>            <span class="hljs-comment"># 提交处理请求的任务函数到线程池</span><br><br>​            tps.submit(self.handle_request, cli_socket)<br>​            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;客户端<span class="hljs-subst">&#123;addr&#125;</span>,建立了连接&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_request</span>(<span class="hljs-params">self, cli_socket</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;处理客户端请求的方法&quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 1、解析客户端的请求数据</span><br><br>​    request_info = self.parser_request(cli_socket)<br>​    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求数据&quot;</span>, request_info)<br>​    code = <span class="hljs-number">200</span><br>​    desc = <span class="hljs-string">&#x27;OK&#x27;</span><br><br>    <span class="hljs-comment"># 2、判断请求路径，不同的请求路径交给不同的方法去处理</span><br><br>​    path = request_info[<span class="hljs-string">&#x27;path&#x27;</span>]<br><br>    <span class="hljs-comment"># 通过请求路径，获取路由关系中对应的处理函数</span><br><br>​    handle_func = ulrs.get(path)<br>​    <span class="hljs-keyword">if</span> handle_func:<br><br>        <span class="hljs-comment"># 调用获取到的处理函数</span><br><br>​        body = handle_func(request_info)<br>​    <span class="hljs-keyword">else</span>:<br>​        body = <span class="hljs-string">&#x27;请求的路径不存在&#x27;</span><br>​        code = <span class="hljs-number">404</span><br>​        desc = <span class="hljs-string">&#x27;Not Found&#x27;</span><br><br>    <span class="hljs-comment"># if request_info[&#x27;path&#x27;] == &#x27;/&#x27;:</span><br><br>    <span class="hljs-comment">#     # 请求根路径</span><br><br>    <span class="hljs-comment">#     body = index(request_info)</span><br><br>    <span class="hljs-comment"># elif request_info[&#x27;path&#x27;] == &#x27;/user/login&#x27;:</span><br><br>    <span class="hljs-comment">#     # 登录的地址</span><br><br>    <span class="hljs-comment">#     body = login(request_info)</span><br><br>    <span class="hljs-comment"># else:</span><br><br>    <span class="hljs-comment">#     body = &#x27;请求的路径不存在&#x27;</span><br><br>    <span class="hljs-comment">#     code = 404</span><br><br>    <span class="hljs-comment">#     desc = &#x27;Not Found&#x27;</span><br><br>    <span class="hljs-comment"># 3、返回响应结果</span><br><br>​    header = <span class="hljs-string">&#x27;HTTP/1.1 &#123;&#125; &#123;&#125;\r\n&#x27;</span>.<span class="hljs-built_in">format</span>(code, desc)<br>​    header += <span class="hljs-string">&#x27;Content-Type: text/html;charset=utf-8\r\n&#x27;</span><br>​    header += <span class="hljs-string">&#x27;\r\n\r\n&#x27;</span><br><br>    <span class="hljs-comment"># 读取html文件</span><br><br>​    msg = (header + body).encode()<br>​    cli_socket.send(msg)<br><br>    <span class="hljs-comment"># 7、关闭套接字</span><br><br>​    cli_socket.close()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parser_request</span>(<span class="hljs-params">self, cli_socket</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    解析http请求报文</span><br><span class="hljs-string">    :param cli_socket: 处理客户端的套接字</span><br><span class="hljs-string">    :return: 解析好的请求信息</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    request_info = &#123;<br>        <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-string">&#x27;method&#x27;</span>: <span class="hljs-string">&quot;GET&quot;</span>,<br>        <span class="hljs-string">&quot;params&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;data_params&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;json_params&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;headers&quot;</span>: <span class="hljs-literal">None</span><br>    &#125;<br><br>    <span class="hljs-comment"># 接收客户端请求数据,并转换为字符串</span><br><br>​    data = cli_socket.recv(<span class="hljs-number">10240</span>).decode()<br>​    data = data.split(<span class="hljs-string">&#x27;\r\n&#x27;</span>)<br><br>    <span class="hljs-comment"># 请求方法，</span><br><br>​    one_lines = data[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27; &#x27;</span>)<br>​    request_info[<span class="hljs-string">&#x27;method&#x27;</span>] = one_lines[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 请求路径</span><br><br>​    path = one_lines[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 请求头</span><br><br>​    headers = &#123;item.split(<span class="hljs-string">&#x27;: &#x27;</span>)[<span class="hljs-number">0</span>]: item.split(<span class="hljs-string">&#x27;: &#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data[<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>]&#125;<br><br>    <span class="hljs-comment"># 请求参数</span><br><br>    <span class="hljs-comment"># 1、查询字符串参数（get请求传参）</span><br><br>​    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;?&#x27;</span> <span class="hljs-keyword">in</span> path:<br>​        path, params = path.split(<span class="hljs-string">&#x27;?&#x27;</span>)<br>​        params = &#123;i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> params.split(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;<br>​    <span class="hljs-keyword">else</span>:<br>​        params = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 判断是否有请求体：</span><br><br>​    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-keyword">in</span> headers:<br>​        <span class="hljs-keyword">if</span> headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] == <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>:<br>​            request_info[<span class="hljs-string">&#x27;data_params&#x27;</span>] = &#123;i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data[-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;<br><br>            <span class="hljs-comment"># 2、表单参数</span><br><br>​        <span class="hljs-keyword">elif</span> headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] == <span class="hljs-string">&#x27;application/json&#x27;</span>:<br>​            <span class="hljs-keyword">import</span> json<br><br>            <span class="hljs-comment"># 3、json参数</span><br><br>​            request_info[<span class="hljs-string">&#x27;json_params&#x27;</span>] = json.loads(data[-<span class="hljs-number">1</span>])<br>​    request_info[<span class="hljs-string">&#x27;path&#x27;</span>] = path<br>​    request_info[<span class="hljs-string">&#x27;params&#x27;</span>] = params<br>​    request_info[<span class="hljs-string">&#x27;headers&#x27;</span>] = headers<br>​    <span class="hljs-keyword">return</span> request_info<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">router</span>(<span class="hljs-params">path</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">func</span>):<br>        ulrs[path] = func<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@router(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;处理登录请求的方法&quot;&quot;&quot;</span><br>    body = <span class="hljs-string">&#x27;&lt;h1&gt;登录页面&lt;/h1&gt;&#x27;</span><br><br><span class="hljs-keyword">return</span> body<br><br><br><span class="hljs-meta">@router(<span class="hljs-params"><span class="hljs-string">&#x27;/user/login&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;请求首页对应的处理方法&quot;&quot;&quot;</span><br>    body = <span class="hljs-string">&#x27;&lt;h1&gt;项目首页&lt;/h1&gt;&#x27;</span><br>    <span class="hljs-keyword">return</span> body<br><br><br><span class="hljs-meta">@router(<span class="hljs-params"><span class="hljs-string">&#x27;/user/register&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">request</span>):<br>    body = <span class="hljs-string">&#x27;&lt;h1&gt;注册页面&lt;/h1&gt;&#x27;</span><br>    <span class="hljs-keyword">return</span> body<br><br><span class="hljs-meta">@router(<span class="hljs-params"><span class="hljs-string">&#x27;/project&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">project</span>(<span class="hljs-params">request</span>):<br>    body = <span class="hljs-string">&#x27;&lt;h1&gt;project页面&lt;/h1&gt;&#x27;</span><br>    <span class="hljs-keyword">return</span> body<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = HttpServe()<br>    app.run(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h2 id="使用自定义的web服务框架写后端"><a href="#使用自定义的web服务框架写后端" class="headerlink" title="使用自定义的web服务框架写后端"></a>使用自定义的web服务框架写后端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> day14.server <span class="hljs-keyword">import</span> HttpServe<br><br>app = HttpServe()<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这个是首页&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这个是登录页面&#x27;</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/register&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这个是注册页面&#x27;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><h2 id="server-py"><a href="#server-py" class="headerlink" title="server.py"></a>server.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">from</span> concurrent.futures.thread <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br>ulrs = &#123;<br><br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServe</span>:<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">9988</span></span>):<br><br>    <span class="hljs-comment"># 1、socket.socket：创建一个tcp套接字</span><br><br>​    self.tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br>    <span class="hljs-comment"># 2、bind：绑定ip和端口</span><br><br>​    self.tcp_socket.bind((host, port))<br>​    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务已启动！地址:http://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(host, port))<br><br>    <span class="hljs-comment"># 3、listen：设置连接池最大的连接数</span><br><br>​    self.tcp_socket.listen(<span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, max_workers=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=max_workers) <span class="hljs-keyword">as</span> tps:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>            <span class="hljs-comment"># 4、accept：等待客户端进行连接</span><br><br>​            cli_socket, addr = self.tcp_socket.accept()<br><br>            <span class="hljs-comment"># 提交处理请求的任务函数到线程池</span><br><br>​            tps.submit(self.handle_request, cli_socket)<br>​            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;客户端<span class="hljs-subst">&#123;addr&#125;</span>,建立了连接&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_request</span>(<span class="hljs-params">self, cli_socket</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;处理客户端请求的方法&quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 1、解析客户端的请求数据</span><br><br>​    request_info = self.parser_request(cli_socket)<br>​    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求数据&quot;</span>, request_info)<br>​    code = <span class="hljs-number">200</span><br>​    desc = <span class="hljs-string">&#x27;OK&#x27;</span><br><br>    <span class="hljs-comment"># 2、判断请求路径，不同的请求路径交给不同的方法去处理</span><br><br>​    path = request_info[<span class="hljs-string">&#x27;path&#x27;</span>]<br><br>    <span class="hljs-comment"># 通过请求路径，获取路由关系中对应的处理函数</span><br><br>​    handle_func = ulrs.get(path)<br>​    <span class="hljs-keyword">if</span> handle_func:<br><br>        <span class="hljs-comment"># 调用获取到的处理函数</span><br><br>​        body = handle_func(request_info)<br>​    <span class="hljs-keyword">else</span>:<br>​        body = <span class="hljs-string">&#x27;请求的路径不存在&#x27;</span><br>​        code = <span class="hljs-number">404</span><br>​        desc = <span class="hljs-string">&#x27;Not Found&#x27;</span><br><br>    <span class="hljs-comment"># 3、返回响应结果</span><br><br>​    header = <span class="hljs-string">&#x27;HTTP/1.1 &#123;&#125; &#123;&#125;\r\n&#x27;</span>.<span class="hljs-built_in">format</span>(code, desc)<br>​    header += <span class="hljs-string">&#x27;Content-Type: text/html;charset=utf-8\r\n&#x27;</span><br>​    header += <span class="hljs-string">&#x27;\r\n\r\n&#x27;</span><br><br>    <span class="hljs-comment"># 读取html文件</span><br><br>​    msg = (header + body).encode()<br>​    cli_socket.send(msg)<br><br>    <span class="hljs-comment"># 7、关闭套接字</span><br><br>​    cli_socket.close()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parser_request</span>(<span class="hljs-params">self, cli_socket</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    解析http请求报文</span><br><span class="hljs-string">    :param cli_socket: 处理客户端的套接字</span><br><span class="hljs-string">    :return: 解析好的请求信息</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    request_info = &#123;<br>        <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-string">&#x27;method&#x27;</span>: <span class="hljs-string">&quot;GET&quot;</span>,<br>        <span class="hljs-string">&quot;params&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;data_params&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;json_params&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;headers&quot;</span>: <span class="hljs-literal">None</span><br>    &#125;<br><br>    <span class="hljs-comment"># 接收客户端请求数据,并转换为字符串</span><br><br>​    data = cli_socket.recv(<span class="hljs-number">10240</span>).decode()<br>​    data = data.split(<span class="hljs-string">&#x27;\r\n&#x27;</span>)<br><br>    <span class="hljs-comment"># 请求方法，</span><br><br>​    one_lines = data[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27; &#x27;</span>)<br>​    request_info[<span class="hljs-string">&#x27;method&#x27;</span>] = one_lines[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 请求路径</span><br><br>​    path = one_lines[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 请求头</span><br><br>​    headers = &#123;item.split(<span class="hljs-string">&#x27;: &#x27;</span>)[<span class="hljs-number">0</span>]: item.split(<span class="hljs-string">&#x27;: &#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data[<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>]&#125;<br><br>    <span class="hljs-comment"># 请求参数</span><br><br>    <span class="hljs-comment"># 1、查询字符串参数（get请求传参）</span><br><br>​    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;?&#x27;</span> <span class="hljs-keyword">in</span> path:<br>​        path, params = path.split(<span class="hljs-string">&#x27;?&#x27;</span>)<br>​        params = &#123;i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> params.split(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;<br>​    <span class="hljs-keyword">else</span>:<br>​        params = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 判断是否有请求体：</span><br><br>​    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-keyword">in</span> headers:<br>​        <span class="hljs-keyword">if</span> headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] == <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>:<br>​            request_info[<span class="hljs-string">&#x27;data_params&#x27;</span>] = &#123;i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data[-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;<br><br>            <span class="hljs-comment"># 2、表单参数</span><br><br>​        <span class="hljs-keyword">elif</span> headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] == <span class="hljs-string">&#x27;application/json&#x27;</span>:<br>​            <span class="hljs-keyword">import</span> json<br><br>            <span class="hljs-comment"># 3、json参数</span><br><br>​            request_info[<span class="hljs-string">&#x27;json_params&#x27;</span>] = json.loads(data[-<span class="hljs-number">1</span>])<br>​    request_info[<span class="hljs-string">&#x27;path&#x27;</span>] = path<br>​    request_info[<span class="hljs-string">&#x27;params&#x27;</span>] = params<br>​    request_info[<span class="hljs-string">&#x27;headers&#x27;</span>] = headers<br>​    <span class="hljs-keyword">return</span> request_info<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">route</span>(<span class="hljs-params">self, path</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;路由装饰器&quot;&quot;&quot;</span><br><br>​    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">func</span>):<br>​        ulrs[path] = func<br><br>​    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket编程</title>
    <link href="/2020/06/01/socket%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/06/01/socket%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><h2 id="flask框架介绍"><a href="#flask框架介绍" class="headerlink" title="flask框架介绍"></a>flask框架介绍</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> flask<br><br>app = flask.Flask(__name__)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-keyword">return</span> flask.jsonify(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;msg&#x27;</span>: <span class="hljs-string">&#x27;OK&#x27;</span>&#125;)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>Flask是一个基于Python的微型Web框架，它被称为“micro framework”（微框架），因为它使用简单，没有自带的ORM（对象关系映射）或其他组件。它的主要目的是提供一个简单易用的框架来构建Web应用程序。Flask的核心只包含了路由、请求处理和响应处理等基本功能，但是它支持插件式的扩展，如ORM、表单验证、文件上传、缓存等等。因此，它可以根据需要进行扩展，同时也可以保持应用程序的简洁性。</p><p>Flask的特点包括：</p><ol><li>轻量级：Flask代码量少、易于使用、容易上手；</li><li>便于扩展：使用Flask框架可以轻松扩展应用程序，支持许多扩展，例如SQLAlchemy、WTForms等；</li><li>易于测试：Flask是轻量级的，提供了一系列测试工具和API，以帮助开发者更容易地编写测试；</li><li>与其他库的兼容性良好：Flask与Werkzeug和Jinja2等库兼容性良好；</li><li>文档齐全：Flask官方提供了完整的文档，其中包含大量的教程和示例。</li></ol><p>Flask是一个开源的项目，代码托管在GitHub上，可以通过pip进行安装。常见的使用Flask开发的Web应用包括博客、论坛、电子商务平台、企业内部管理系统等。</p><h2 id="requests发送各种请求"><a href="#requests发送各种请求" class="headerlink" title="requests发送各种请求"></a>requests发送各种请求</h2><p>requests是一个非常流行的Python HTTP库，它提供了非常简单易用的接口来发送各种类型的HTTP请求。requests支持的请求类型包括：</p><ol><li>GET请求</li></ol><p>GET请求是最常见的HTTP请求类型，可以使用requests库的get方法发送GET请求，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>response = requests.get(<span class="hljs-string">&#x27;https://www.example.com&#x27;</span>)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><ol><li>POST请求</li></ol><p>POST请求通常用于向服务器提交表单数据或上传文件等操作。可以使用requests库的post方法发送POST请求，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>data = &#123;<span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;testuser&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>: <span class="hljs-string">&#x27;testpass&#x27;</span>&#125;<br>response = requests.post(<span class="hljs-string">&#x27;https://www.example.com/login&#x27;</span>, data=data)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><ol><li>PUT请求</li></ol><p>PUT请求通常用于向服务器更新资源。可以使用requests库的put方法发送PUT请求，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;newname&#x27;</span>&#125;<br>response = requests.put(<span class="hljs-string">&#x27;https://www.example.com/resources/123&#x27;</span>, data=data)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><ol><li>DELETE请求</li></ol><p>DELETE请求通常用于从服务器删除资源。可以使用requests库的delete方法发送DELETE请求，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>response = requests.delete(<span class="hljs-string">&#x27;https://www.example.com/resources/123&#x27;</span>)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><ol><li>HEAD请求</li></ol><p>HEAD请求通常用于获取资源的元信息，例如资源的大小和类型。可以使用requests库的head方法发送HEAD请求，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>response = requests.head(<span class="hljs-string">&#x27;https://www.example.com/resources/123&#x27;</span>)<br><span class="hljs-built_in">print</span>(response.headers)<br></code></pre></td></tr></table></figure><ol><li>PATCH请求</li></ol><p>PATCH请求通常用于向服务器部分更新资源。可以使用requests库的patch方法发送PATCH请求，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;newname&#x27;</span>&#125;<br>response = requests.patch(<span class="hljs-string">&#x27;https://www.example.com/resources/123&#x27;</span>, data=data)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><ol><li>OPTIONS请求</li></ol><p>OPTIONS请求通常用于获取资源支持的HTTP方法和请求头信息等。可以使用requests库的options方法发送OPTIONS请求，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>response = requests.options(<span class="hljs-string">&#x27;https://www.example.com/resources/123&#x27;</span>)<br><span class="hljs-built_in">print</span>(response.headers)<br></code></pre></td></tr></table></figure><p>除了以上列出的请求类型，requests还支持其他一些请求类型，例如CONNECT、TRACE等。</p><h2 id="基于socket实现TCP服务端"><a href="#基于socket实现TCP服务端" class="headerlink" title="基于socket实现TCP服务端"></a>基于socket实现TCP服务端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1、socket.socket：创建一个tcp套接字</span><br><br>tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2、bind：绑定ip和端口</span><br><br>tcp_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9988</span>))<br><br><span class="hljs-comment"># 3、listen：设置连接池最大的连接数</span><br><br>tcp_socket.listen(<span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 4、accept：等待客户端进行连接</span><br><br>client_info = tcp_socket.accept()<br><br><span class="hljs-comment"># 5、获取客户端的地址和处理客户端连接的套接字</span><br><br>cli_socket,addr = client_info<br><br><span class="hljs-comment"># 6、recv接收客户端的请求数据</span><br><br>res = cli_socket.recv(<span class="hljs-number">2048</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求数据：&quot;</span>,res.decode())<br><br><span class="hljs-comment"># 7、给客户端返回数据</span><br><br><span class="hljs-comment"># 8、关闭套接字</span><br><br>cli_socket.close()<br>tcp_socket.close()<br></code></pre></td></tr></table></figure><p>下面是基于socket实现TCP服务端的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 定义服务器IP地址和端口号</span><br>server_ip = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>server_port = <span class="hljs-number">8888</span><br><br><span class="hljs-comment"># 创建一个TCP套接字对象</span><br>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 绑定服务器IP地址和端口号</span><br>server_socket.bind((server_ip, server_port))<br><br><span class="hljs-comment"># 监听客户端的连接请求</span><br>server_socket.listen(<span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务器启动，等待客户端连接...&quot;</span>)<br><br><span class="hljs-comment"># 循环处理客户端请求</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 接收客户端连接请求</span><br>    client_socket, client_addr = server_socket.accept()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;客户端已连接，客户端地址：&quot;</span>, client_addr)<br><br>    <span class="hljs-comment"># 接收客户端发送的数据</span><br>    data = client_socket.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;收到客户端数据：&quot;</span>, data.decode())<br><br>    <span class="hljs-comment"># 发送数据给客户端</span><br>    client_socket.send(<span class="hljs-string">&quot;Hello, client!&quot;</span>.encode())<br><br>    <span class="hljs-comment"># 关闭客户端套接字</span><br>    client_socket.close()<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们通过<code>socket</code>模块创建了一个TCP套接字对象，然后通过<code>bind</code>方法将服务器IP地址和端口号绑定到套接字上。接着，通过<code>listen</code>方法监听客户端的连接请求，并进入循环等待客户端连接。一旦有客户端连接上来，我们就通过<code>accept</code>方法接收客户端连接请求，并创建一个新的套接字对象（<code>client_socket</code>）来处理客户端请求。然后，我们通过<code>recv</code>方法接收客户端发送的数据，并通过<code>send</code>方法发送数据给客户端。最后，我们关闭客户端套接字，继续循环等待下一个客户端连接。</p><h2 id="socket实现TCP服务端2"><a href="#socket实现TCP服务端2" class="headerlink" title="socket实现TCP服务端2"></a>socket实现TCP服务端2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1、socket.socket：创建一个tcp套接字</span><br><br>tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2、bind：绑定ip和端口</span><br><br>tcp_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9988</span>))<br><br><span class="hljs-comment"># 3、listen：设置连接池最大的连接数</span><br><br>tcp_socket.listen(<span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 4、accept：等待客户端进行连接</span><br>    client_info = tcp_socket.accept()<br>    <span class="hljs-comment"># 5、获取客户端的地址和处理客户端连接的套接字</span><br>    cli_socket,addr = client_info<br>    <span class="hljs-comment"># 6、recv接收客户端的请求数据</span><br>    res = cli_socket.recv(<span class="hljs-number">2048</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;addr&#125;</span>发送，请求数据：<span class="hljs-subst">&#123;res.decode()&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 7、给客户端返回数据</span><br>    msg = <span class="hljs-string">&#x27;收到 OK&#x27;</span>.encode()<br>    cli_socket.send(msg)<br>    <span class="hljs-comment"># 8、关闭套接字</span><br>    cli_socket.close()<br></code></pre></td></tr></table></figure><h2 id="socket实现tcp的客户端"><a href="#socket实现tcp的客户端" class="headerlink" title="socket实现tcp的客户端"></a>socket实现tcp的客户端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM<br><br><span class="hljs-comment"># 1、创建tcp套接字</span><br><br>tcp_socket = socket(AF_INET, SOCK_STREAM)<br><br><span class="hljs-comment"># 2、connect:连接服务端</span><br><br>tcp_socket.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9988</span>))<br><br><span class="hljs-comment"># 3、send:发送请求数据</span><br><br>msg = <span class="hljs-string">&#x27;你好，服务端,我是musen&#x27;</span>.encode()<br>tcp_socket.send(msg)<br><br><span class="hljs-comment"># 4、接收服务端返回的数据</span><br><br>res = tcp_socket.recv(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务端返回：&quot;</span>,res.decode())<br><br><span class="hljs-comment"># 5、关闭套接字</span><br><br>tcp_socket.close()<br></code></pre></td></tr></table></figure><h2 id="socket实现HTTP客户端"><a href="#socket实现HTTP客户端" class="headerlink" title="socket实现HTTP客户端"></a>socket实现HTTP客户端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">url, method=<span class="hljs-string">&#x27;GET&#x27;</span>, params=<span class="hljs-literal">None</span>, data=<span class="hljs-literal">None</span>, json=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-comment"># 1、创建tcp套接字</span><br>    tcp_socket = socket(AF_INET, SOCK_STREAM)<br>    <span class="hljs-comment"># 2、connect:连接服务端</span><br>    tcp_socket.connect((url, <span class="hljs-number">80</span>))<br>    <span class="hljs-comment"># 构造http请求报文</span><br>    request_info = <span class="hljs-string">&#x27;GET / HTTP/1.1\r\n&#x27;</span><br>    request_info += <span class="hljs-string">&#x27;Host: &#123;&#125;:80\r\n&#x27;</span>.<span class="hljs-built_in">format</span>(url)<br>    request_info += <span class="hljs-string">&#x27;User-Agent: python-requests/2.24.0\r\n&#x27;</span><br>    request_info += <span class="hljs-string">&#x27;Accept-Encoding: gzip, deflate\r\n&#x27;</span><br>    request_info += <span class="hljs-string">&#x27;Connection: keep-alive\r\n&#x27;</span><br>    request_info += <span class="hljs-string">&#x27;Accept: */*\r\n&#x27;</span><br>    request_info += <span class="hljs-string">&#x27;\r\n\r\n&#x27;</span><br>    <span class="hljs-comment"># 3、send:发送请求数据</span><br>    msg = request_info.encode()<br>    tcp_socket.send(msg)<br>    <span class="hljs-comment"># 4、接收服务端返回的数据</span><br>    res = tcp_socket.recv(<span class="hljs-number">10240</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务端返回：&quot;</span>, res.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-comment"># 5、关闭套接字</span><br>    tcp_socket.close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    request(<span class="hljs-string">&#x27;www.lemonban.com&#x27;</span>)<br><br><span class="hljs-comment">#request(&#x27;www.lemonban.com/user/login&#x27;)</span><br></code></pre></td></tr></table></figure><h2 id="socket实现HTTP服务端2"><a href="#socket实现HTTP服务端2" class="headerlink" title="socket实现HTTP服务端2"></a>socket实现HTTP服务端2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1、socket.socket：创建一个tcp套接字</span><br><br>tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2、bind：绑定ip和端口</span><br><br>tcp_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9988</span>))<br><br><span class="hljs-comment"># 3、listen：设置连接池最大的连接数</span><br><br>tcp_socket.listen(<span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 4、accept：等待客户端进行连接</span><br>    cli_socket,addr = tcp_socket.accept()<br>    <span class="hljs-comment"># 5、recv接收客户端的请求数据</span><br>    res = cli_socket.recv(<span class="hljs-number">2048</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;addr&#125;</span>发送，请求数据：<span class="hljs-subst">&#123;res.decode()&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 6、给客户端返回数据(按照HTTP的响应报文进行返回)</span><br>    <span class="hljs-comment"># header = &#x27;HTTP/1.1 200 OK\r\n&#x27;</span><br>    <span class="hljs-comment"># header += &#x27;Content-Type: text/html;charset=utf-8\r\n&#x27;</span><br>    <span class="hljs-comment"># header += &#x27;\r\n\r\n&#x27;</span><br>    <span class="hljs-comment"># body = &#x27;&lt;h1&gt;柠檬班&lt;/h1&gt;&#x27;</span><br>    header = <span class="hljs-string">&#x27;HTTP/1.1 404 Not Found\r\n&#x27;</span><br>    header += <span class="hljs-string">&#x27;Content-Type: text/html;charset=utf-8\r\n&#x27;</span><br>    header += <span class="hljs-string">&#x27;\r\n\r\n&#x27;</span><br>    body = <span class="hljs-string">&#x27;&lt;h1&gt;页面跑丢了&lt;/h1&gt;&#x27;</span><br>    msg = (header+body).encode()<br>    cli_socket.send(msg)<br>    <span class="hljs-comment"># 7、关闭套接字</span><br>    cli_socket.close()<br></code></pre></td></tr></table></figure><h2 id="socket实现返回静态网页的HTTP服务端2"><a href="#socket实现返回静态网页的HTTP服务端2" class="headerlink" title="socket实现返回静态网页的HTTP服务端2"></a>socket实现返回静态网页的HTTP服务端2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 1、socket.socket：创建一个tcp套接字</span><br><br>tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 2、bind：绑定ip和端口</span><br><br>tcp_socket.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9988</span>))<br><br><span class="hljs-comment"># 3、listen：设置连接池最大的连接数</span><br><br>tcp_socket.listen(<span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 4、accept：等待客户端进行连接</span><br>    cli_socket, addr = tcp_socket.accept()<br>    <span class="hljs-comment"># 5、recv接收客户端的请求数据</span><br>    res = cli_socket.recv(<span class="hljs-number">2048</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;addr&#125;</span>发送，请求数据：<span class="hljs-subst">&#123;res.decode()&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 6、给客户端返回数据(按照HTTP的响应报文进行返回)</span><br>    header = <span class="hljs-string">&#x27;HTTP/1.1 200 OK\r\n&#x27;</span><br>    header += <span class="hljs-string">&#x27;Content-Type: text/html;charset=utf-8\r\n&#x27;</span><br>    header += <span class="hljs-string">&#x27;\r\n\r\n&#x27;</span><br>    <span class="hljs-comment"># 读取html文件</span><br>    body = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;report.html&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).read()<br>    msg = (header + body).encode()<br>    cli_socket.send(msg)<br>    <span class="hljs-comment"># 7、关闭套接字</span><br>    cli_socket.close()<br></code></pre></td></tr></table></figure><h2 id="基于线程池实现静态网页的HTTP服务端2"><a href="#基于线程池实现静态网页的HTTP服务端2" class="headerlink" title="基于线程池实现静态网页的HTTP服务端2"></a>基于线程池实现静态网页的HTTP服务端2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">from</span> concurrent.futures.thread <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServe</span>:<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">9988</span></span>):<br><br>    <span class="hljs-comment"># 1、socket.socket：创建一个tcp套接字</span><br><br>​    self.tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br>    <span class="hljs-comment"># 2、bind：绑定ip和端口</span><br><br>​    self.tcp_socket.bind((host, port))<br>​    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务已启动！地址:http://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(host, port))<br><br>    <span class="hljs-comment"># 3、listen：设置连接池最大的连接数</span><br><br>​    self.tcp_socket.listen(<span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, max_workers=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=max_workers) <span class="hljs-keyword">as</span> tps:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>            <span class="hljs-comment"># 4、accept：等待客户端进行连接</span><br><br>​            cli_socket, addr = self.tcp_socket.accept()<br><br>            <span class="hljs-comment"># 提交处理请求的任务函数到线程池</span><br><br>​            tps.submit(self.handle_request, cli_socket)<br>​            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;客户端<span class="hljs-subst">&#123;addr&#125;</span>,建立了连接&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_request</span>(<span class="hljs-params">self, cli_socket</span>):<br><br>    <span class="hljs-comment"># 5、recv接收客户端的请求数据</span><br><br>​    res = cli_socket.recv(<span class="hljs-number">2048</span>)<br><br>    <span class="hljs-comment"># 6、给客户端返回数据(按照HTTP的响应报文进行返回)</span><br><br>​    header = <span class="hljs-string">&#x27;HTTP/1.1 200 OK\r\n&#x27;</span><br>​    header += <span class="hljs-string">&#x27;Content-Type: text/html;charset=utf-8\r\n&#x27;</span><br>​    header += <span class="hljs-string">&#x27;\r\n\r\n&#x27;</span><br><br>    <span class="hljs-comment"># 读取html文件</span><br><br>​    body = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;report.html&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).read()<br>​    msg = (header + body).encode()<br>​    cli_socket.send(msg)<br><br>    <span class="hljs-comment"># 7、关闭套接字</span><br><br>​    cli_socket.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = HttpServe()<br>    app.run(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h2 id="实现根据不同的请求方法和路径做不同的处理"><a href="#实现根据不同的请求方法和路径做不同的处理" class="headerlink" title="实现根据不同的请求方法和路径做不同的处理"></a>实现根据不同的请求方法和路径做不同的处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">from</span> concurrent.futures.thread <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServe</span>:<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port=<span class="hljs-number">9988</span></span>):<br><br>    <span class="hljs-comment"># 1、socket.socket：创建一个tcp套接字</span><br><br>​    self.tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br>    <span class="hljs-comment"># 2、bind：绑定ip和端口</span><br><br>​    self.tcp_socket.bind((host, port))<br>​    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务已启动！地址:http://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(host, port))<br><br>    <span class="hljs-comment"># 3、listen：设置连接池最大的连接数</span><br><br>​    self.tcp_socket.listen(<span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, max_workers=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=max_workers) <span class="hljs-keyword">as</span> tps:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>            <span class="hljs-comment"># 4、accept：等待客户端进行连接</span><br><br>​            cli_socket, addr = self.tcp_socket.accept()<br><br>            <span class="hljs-comment"># 提交处理请求的任务函数到线程池</span><br><br>​            tps.submit(self.handle_request, cli_socket)<br>​            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;客户端<span class="hljs-subst">&#123;addr&#125;</span>,建立了连接&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_request</span>(<span class="hljs-params">self, cli_socket</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;处理客户端请求的方法&quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 1、解析客户端的请求数据</span><br><br>​    request_info = self.parser_request(cli_socket)<br>​    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求数据&quot;</span>,request_info)<br><br>    <span class="hljs-comment"># 2、判断请求路径，不同的请求路径交给不同的方法去处理</span><br><br>    <span class="hljs-comment"># 3、返回响应结果</span><br><br>​    header = <span class="hljs-string">&#x27;HTTP/1.1 200 OK\r\n&#x27;</span><br>​    header += <span class="hljs-string">&#x27;Content-Type: text/html;charset=utf-8\r\n&#x27;</span><br>​    header += <span class="hljs-string">&#x27;\r\n\r\n&#x27;</span><br><br>    <span class="hljs-comment"># 读取html文件</span><br><br>​    body = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;report.html&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).read()<br>​    msg = (header + body).encode()<br>​    cli_socket.send(msg)<br><br>    <span class="hljs-comment"># 7、关闭套接字</span><br><br>​    cli_socket.close()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parser_request</span>(<span class="hljs-params">self, cli_socket</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    解析http请求报文</span><br><span class="hljs-string">    :param cli_socket: 处理客户端的套接字</span><br><span class="hljs-string">    :return: 解析好的请求信息</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    request_info = &#123;<br>        <span class="hljs-string">&quot;path&quot;</span>:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-string">&#x27;method&#x27;</span>:<span class="hljs-string">&quot;GET&quot;</span>,<br>        <span class="hljs-string">&quot;params&quot;</span>:<span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;data_params&quot;</span>:<span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;json_params&quot;</span>:<span class="hljs-literal">None</span><br>    &#125;<br><br>    <span class="hljs-comment"># 接收客户端请求数据,并转换为字符串</span><br><br>​    data = cli_socket.recv(<span class="hljs-number">10240</span>).decode()<br>​    data = data.split(<span class="hljs-string">&#x27;\r\n&#x27;</span>)<br><br>    <span class="hljs-comment"># 请求方法，</span><br><br>​    one_lines = data[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27; &#x27;</span>)<br>​    request_info[<span class="hljs-string">&#x27;method&#x27;</span>] = one_lines[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 请求路径</span><br><br>​    path = one_lines[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 请求头</span><br><br>​    headers = &#123;item.split(<span class="hljs-string">&#x27;: &#x27;</span>)[<span class="hljs-number">0</span>]: item.split(<span class="hljs-string">&#x27;: &#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data[<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>]&#125;<br><br>    <span class="hljs-comment"># 请求参数</span><br><br>    <span class="hljs-comment"># 1、查询字符串参数（get请求传参）</span><br><br>​    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;?&#x27;</span> <span class="hljs-keyword">in</span> path:<br>​        path, params = path.split(<span class="hljs-string">&#x27;?&#x27;</span>)<br>​        params = &#123;i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> params.split(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;<br>​    <span class="hljs-keyword">else</span>:<br>​        params = <span class="hljs-literal">None</span><br>​    request_info[<span class="hljs-string">&#x27;path&#x27;</span>] = path<br>​    request_info[<span class="hljs-string">&#x27;params&#x27;</span>] = params<br><br>    <span class="hljs-comment"># 判断是否有请求体：</span><br><br>​    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-keyword">in</span> headers:<br>​        <span class="hljs-keyword">if</span> headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] ==<span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>:<br>​            request_info[<span class="hljs-string">&#x27;data_params&#x27;</span>] = &#123;i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: i.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data[-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;<br><br>            <span class="hljs-comment"># 2、表单参数</span><br><br>​        <span class="hljs-keyword">elif</span> headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] ==<span class="hljs-string">&#x27;application/json&#x27;</span>:<br>​            <span class="hljs-keyword">import</span> json<br><br>            <span class="hljs-comment"># 3、json参数</span><br><br>​            request_info[<span class="hljs-string">&#x27;json_params&#x27;</span>] = json.loads(data[-<span class="hljs-number">1</span>])<br>​    <span class="hljs-keyword">return</span> request_info<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = HttpServe()<br>    app.run(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python协程和pytest插件</title>
    <link href="/2020/05/25/Python%E5%8D%8F%E7%A8%8B%E5%92%8Cpytest%E6%8F%92%E4%BB%B6/"/>
    <url>/2020/05/25/Python%E5%8D%8F%E7%A8%8B%E5%92%8Cpytest%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Python协程和pytest插件"><a href="#Python协程和pytest插件" class="headerlink" title="Python协程和pytest插件"></a>Python协程和pytest插件</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>“””<br>“””<br>协程：存在于线程之中，又称之为微线程，或者纤程</p><p>需求：单线程如何实现多任务？<br>    通过协程：</p><p>“””</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务1执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>        <span class="hljs-keyword">yield</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务2执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>        <span class="hljs-keyword">yield</span><br><br>g1 = work1()<br>g2 = work2()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">next</span>(g1)<br>    <span class="hljs-built_in">next</span>(g2)<br></code></pre></td></tr></table></figure><p>协程是一种比线程更加轻量级的并发编程方式，其内部的执行可以在一个线程中完成，通过协程的切换来实现并发。Python提供了内置的asyncio模块来支持协程编程。</p><p>协程的特点：</p><ol><li>协程的调度是由程序员控制的，不像线程由操作系统控制。</li><li>协程不会切换到内核态，所以运行速度比线程快。</li><li>协程是单线程内实现的并发，可以使用更少的资源实现更高的并发性。</li></ol><p>协程的关键是yield关键字，可以将协程挂起，并将控制权还给调用者。在Python中使用async关键字定义一个协程函数，函数内使用await关键字来挂起协程。</p><p>下面是一个简单的协程示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_nums</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(i)<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_letters</span>():<br>    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]:<br>        <span class="hljs-built_in">print</span>(letter)<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    task1 = asyncio.create_task(print_nums())<br>    task2 = asyncio.create_task(print_letters())<br>    <span class="hljs-keyword">await</span> task1<br>    <span class="hljs-keyword">await</span> task2<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>这个例子中，我们定义了两个协程函数print_nums和print_letters，它们分别打印数字和字母，并在每次打印后暂停1秒。我们通过asyncio.create_task来创建两个任务，并通过await关键字等待它们完成，最后使用asyncio.run来运行整个程序。</p><p>Python的asyncio模块还提供了一些基于事件循环的协程API，例如asyncio.sleep、asyncio.wait等等，这些API可以让协程更加方便地进行事件处理、任务调度等操作。</p><h2 id="python中原生协程函数的定义"><a href="#python中原生协程函数的定义" class="headerlink" title="python中原生协程函数的定义"></a>python中原生协程函数的定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">import asyncio</span><br><span class="hljs-string"></span><br><span class="hljs-string"># ======================python中原生协程函数的定义=================</span><br><span class="hljs-string"></span><br><span class="hljs-string"># async  await    asyncio</span><br><span class="hljs-string"></span><br><span class="hljs-string"># # python3.4中协程函数的定义</span><br><span class="hljs-string"></span><br><span class="hljs-string"># @asyncio.coroutine</span><br><span class="hljs-string"></span><br><span class="hljs-string"># def work():</span><br><span class="hljs-string"></span><br><span class="hljs-string">#     pass</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"># python版本要大于3.5才支持一下语法</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 定义原生的协程函数（异步函数）</span><br><span class="hljs-string"></span><br><span class="hljs-string">async def work1():</span><br><span class="hljs-string">    for i in range(1, 7):</span><br><span class="hljs-string">        print(&quot;任务1执行的第&#123;&#125;秒&quot;.format(i))</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">async def work2():</span><br><span class="hljs-string">    for i in range(1, 7):</span><br><span class="hljs-string">        print(&quot;任务1执行的第&#123;&#125;秒&quot;.format(i))</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"># 调用协程函数，返回的结果是一个协程对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">c1 = work1()</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"># =====================协程的执行机制======================</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 执行协程</span><br><span class="hljs-string"></span><br><span class="hljs-string">asyncio.run(c1)</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 事件循环的概念</span><br><span class="hljs-string"></span><br><span class="hljs-string"># # 创建一个事件循环</span><br><span class="hljs-string"></span><br><span class="hljs-string"># loop = asyncio.get_event_loop()</span><br><span class="hljs-string"></span><br><span class="hljs-string"># # 将协程对象，加入到事件循环执行的任务列表</span><br><span class="hljs-string"></span><br><span class="hljs-string"># loop.run_until_complete(c1)</span><br></code></pre></td></tr></table></figure><h2 id="python中原生协程实现多任务"><a href="#python中原生协程实现多任务" class="headerlink" title="python中原生协程实现多任务"></a>python中原生协程实现多任务</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-comment"># python版本要大于3.5才支持一下语法</span><br><br><span class="hljs-comment"># 定义原生的协程函数（异步函数）</span><br><br><span class="hljs-comment"># async def work1():</span><br><br><span class="hljs-comment">#     for i in range(1, 7):</span><br><br><span class="hljs-comment">#         print(&quot;任务1执行的第&#123;&#125;秒&quot;.format(i))</span><br><br><span class="hljs-comment">#         await asyncio.sleep(1)</span><br><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-comment"># async def work2():</span><br><br><span class="hljs-comment">#     for i in range(1, 7):</span><br><br><span class="hljs-comment">#         print(&quot;任务2执行的第&#123;&#125;秒&quot;.format(i))</span><br><br><span class="hljs-comment">#         await asyncio.sleep(1)</span><br><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-comment"># # 如何同时执行多个协程函数</span><br><br><span class="hljs-comment"># asyncio.run(asyncio.wait([work1(), work2()]))</span><br><br><br><span class="hljs-comment"># =================关于任务=========================================</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务1执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;python&#x27;</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务2执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>        <span class="hljs-comment"># await asyncio.sleep(1)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;java&#x27;</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    t1 = asyncio.create_task(work1())<br>    t2 = asyncio.create_task(work2())<br>    res1 = <span class="hljs-keyword">await</span> t1<br>    res2 = <span class="hljs-keyword">await</span> t2<br>    <span class="hljs-built_in">print</span>(res1)<br>    <span class="hljs-built_in">print</span>(res2)<br><br><br>asyncio.run(main())<br><br><span class="hljs-comment"># =============================await=====================</span><br><br><span class="hljs-comment"># await只能用在async定义的函数中，等待</span><br><br><span class="hljs-comment"># await后面只能跟(可等待对象),协程对象，任务，Future对象</span><br></code></pre></td></tr></table></figure><h2 id="gevent模块创建协程"><a href="#gevent模块创建协程" class="headerlink" title="gevent模块创建协程"></a>gevent模块创建协程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> gevent<br><span class="hljs-keyword">from</span> gevent <span class="hljs-keyword">import</span> monkey<br><br>monkey.patch_all()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务1执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务2执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># # 创建协程</span><br>    <span class="hljs-comment"># c1 = gevent.Greenlet(work1)</span><br>    <span class="hljs-comment"># c2 = gevent.Greenlet(work2)</span><br>    <span class="hljs-comment"># # 启动协程</span><br>    <span class="hljs-comment"># c1.start()</span><br>    <span class="hljs-comment"># c2.start()</span><br>    <span class="hljs-comment"># # 等待协程执行完毕</span><br>    <span class="hljs-comment"># c1.join()</span><br>    <span class="hljs-comment"># c2.join()</span><br>    <span class="hljs-comment"># ==============================================</span><br>    c1 = gevent.spawn(work1)<br>    c2 = gevent.spawn(work2)<br><br><span class="hljs-comment"># c1.join()</span><br><br><span class="hljs-comment"># c2.join()</span><br><br><span class="hljs-comment"># 等待所有协程对象执行结束</span><br><br>gevent.joinall([c1, c2])<br></code></pre></td></tr></table></figure><h2 id="协程任务的参数传递和返回值接收"><a href="#协程任务的参数传递和返回值接收" class="headerlink" title="协程任务的参数传递和返回值接收"></a>协程任务的参数传递和返回值接收</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> gevent<br><span class="hljs-keyword">from</span> gevent <span class="hljs-keyword">import</span> monkey<br><br>monkey.patch_all()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>(<span class="hljs-params">name, age</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;age:&#123;&#125;---&#123;&#125;任务1执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(age, name, i))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#125;--&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, age)<br><br><span class="hljs-comment"># 回调函数</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">musen</span>(<span class="hljs-params">res</span>):<br>    <span class="hljs-built_in">print</span>(res.get())<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br><span class="hljs-comment"># cs = [gevent.spawn(work1, &#x27;张三&#x27;, i) for i in range(10)]</span><br><br><span class="hljs-comment"># gevent.joinall(cs)</span><br><br><span class="hljs-comment"># ==================获取协程执行完任务函数的返回值=================</span><br><br><span class="hljs-comment"># c = gevent.spawn(work1, &#x27;张三&#x27;, 18)</span><br><br><span class="hljs-comment"># # 获取返回结果</span><br><br><span class="hljs-comment"># res = c.get()</span><br><br><span class="hljs-comment"># # 打印结果</span><br><br><span class="hljs-comment"># print(res)</span><br><br><span class="hljs-comment"># cs = [gevent.spawn(work1, &#x27;张三&#x27;, i) for i in range(10)]</span><br><br><span class="hljs-comment"># res = gevent.joinall(cs)</span><br><br><span class="hljs-comment"># # 获取所以的协程任务执行的结果</span><br><br><span class="hljs-comment"># result = [i.get() for i in cs]</span><br><br><span class="hljs-comment"># print(result)</span><br><br><span class="hljs-comment"># ===============给任务设置回调函数====================</span><br><br>c = gevent.spawn(work1, <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)<br><br><span class="hljs-comment"># 设置回调函数</span><br><br>c.link(musen)<br><br><span class="hljs-comment"># 等待协程执行完毕</span><br><br>c.join()<br></code></pre></td></tr></table></figure><h2 id="进程、线程、协程对比"><a href="#进程、线程、协程对比" class="headerlink" title="进程、线程、协程对比"></a>进程、线程、协程对比</h2><p>“””<br>1.进程是资源分配的单位<br>2. 线程是操作系统调度的单位<br>3.协程存在于线程之中，本质上就是一个特定情况下可以切换的特殊的函数。<br>4. 进程切由于资源是独立的，每次切换的资源很大，耗时更长<br>5. 线程的切换涉及到<strong>用户空间和内核空间的切换</strong>，需要操作系统调度，还有线程私有的栈和寄存器等 效率一般。<br>6. 协程切换任务，只设及到CUP上下文的切换，资源很小，耗时几乎可以忽略不计<br>7. 多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发<br>8. 注意点：python中的线程由于GIL锁的的存在，并不能够实现并行，要充分利用多核CUP还是需要使用进程来做。</p><ul><li><h5 id="什么场景适合用进程？"><a href="#什么场景适合用进程？" class="headerlink" title="什么场景适合用进程？"></a>什么场景适合用进程？</h5><h6 id="计算密集型的任务-比如：大规模的数据计算和处理"><a href="#计算密集型的任务-比如：大规模的数据计算和处理" class="headerlink" title="计算密集型的任务(比如：大规模的数据计算和处理)"></a>计算密集型的任务(比如：大规模的数据计算和处理)</h6></li><li><h5 id="什么场景适合用线程？"><a href="#什么场景适合用线程？" class="headerlink" title="什么场景适合用线程？"></a>什么场景适合用线程？</h5><h6 id="IO密集型的任务-比如：数据读取和写入多，网络请求多的任务"><a href="#IO密集型的任务-比如：数据读取和写入多，网络请求多的任务" class="headerlink" title="IO密集型的任务(比如：数据读取和写入多，网络请求多的任务)"></a>IO密集型的任务(比如：数据读取和写入多，网络请求多的任务)</h6></li><li><h5 id="什么场景适合用协程？"><a href="#什么场景适合用协程？" class="headerlink" title="什么场景适合用协程？"></a>什么场景适合用协程？</h5><h6 id="IO密集型项目切要求高并发-比如：用locust-搞压测里面就是用的协程-实际上真实项目中对应高并发的业务并不会选择使用python语言。"><a href="#IO密集型项目切要求高并发-比如：用locust-搞压测里面就是用的协程-实际上真实项目中对应高并发的业务并不会选择使用python语言。" class="headerlink" title="IO密集型项目切要求高并发( 比如：用locust 搞压测里面就是用的协程) ,实际上真实项目中对应高并发的业务并不会选择使用python语言。"></a>IO密集型项目切要求高并发( 比如：用locust 搞压测里面就是用的协程) ,实际上真实项目中对应高并发的业务并不会选择使用python语言。</h6></li></ul><p>“””</p><p>Python中的线程、进程和协程是用于实现多任务的三种不同方式，它们在实现方式、使用场景、性能等方面有所不同。</p><ol><li>实现方式</li></ol><ul><li>线程：由操作系统调度，在同一进程内共享进程资源，每个线程拥有自己的栈和局部变量。</li><li>进程：由操作系统调度，拥有自己独立的地址空间、内存等资源，进程之间互相独立。</li><li>协程：是用户级别的线程，由程序员自己编写调度逻辑，通过yield和send等方式实现多任务切换。</li></ul><ol><li>使用场景</li></ol><ul><li>线程：适用于I&#x2F;O密集型任务，如网络请求、文件读写等操作，可以提高CPU利用率，但是因为多线程共享进程资源，所以需要注意线程安全问题。</li><li>进程：适用于CPU密集型任务，如图像处理、科学计算等操作，可以提高CPU利用率，但是因为进程之间相互独立，所以需要通过IPC进行通信。</li><li>协程：适用于I&#x2F;O密集型任务，如网络请求、文件读写等操作，因为协程的切换开销比线程和进程小，可以提高性能。</li></ul><ol><li>性能</li></ol><ul><li>线程：由于线程的切换需要通过操作系统进行调度，所以线程切换的开销相对较大，但是因为多个线程共享进程资源，可以在一定程度上提高CPU利用率。</li><li>进程：进程之间相互独立，通信需要通过IPC进行，开销较大，但是因为可以利用多核CPU的优势，所以在CPU密集型任务中表现较好。</li><li>协程：协程的切换开销比线程和进程小，因为不需要进入操作系统内核态，所以性能相对较好，特别是在I&#x2F;O密集型任务中表现较好。</li></ul><p>总体来说，线程、进程和协程各有优缺点，在不同场景下选择适合的方式可以提高程序的性能和效率。</p><h2 id="pytest插件机制"><a href="#pytest插件机制" class="headerlink" title="pytest插件机制"></a>pytest插件机制</h2><p>pytest是一个功能强大的Python测试框架，支持各种类型的测试，包括单元测试、功能测试、性能测试等。pytest具有丰富的插件机制，使得用户可以轻松地扩展pytest的功能。</p><p>pytest的插件机制基于setuptools的entry points机制，用户可以在项目中通过编写setuptools的entry points，将自己编写的插件添加到pytest的插件系统中。pytest中的插件可以分为hook函数和fixture函数两种类型。</p><ul><li>Hook函数：hook函数是pytest中的扩展点，可以在测试执行的不同阶段进行扩展和干预。例如，可以在测试运行前后，或者在测试失败时执行特定的操作。pytest提供了大量的hook函数，用户可以根据需要选择并实现相应的hook函数来扩展pytest的功能。</li><li>Fixture函数：fixture函数是pytest中的一种特殊的hook函数，用于提供测试所需的数据或对象。pytest中的fixture函数可以看做是一种数据提供器，可以提供各种类型的数据，包括简单的字符串、整数，以及复杂的对象和函数等。用户可以通过定义fixture函数，来提供测试所需的各种数据和对象。 治具函</li></ul><p>通过扩展pytest的插件机制，用户可以实现各种自定义的测试扩展，例如自定义的断言函数、自定义的测试报告、自定义的命令行选项等。同时，pytest的插件机制也为第三方开发者提供了一个良好的扩展平台，使得开发者可以基于pytest开发各种自定义的插件，以满足不同用户的需求。</p><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunner</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preform</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-----start------&#x27;</span>)<br>        self.run_case_func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-----run_case_func------&#x27;</span>)<br>        self.send_request()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-----send_request------&#x27;</span>)<br>        self.asserttion()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-----asserttion------&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_case_func</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_request</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">asserttion</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MTRunner</span>(<span class="hljs-title class_ inherited__">TestRunner</span>):<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_case_func</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----钩子函数run_case_func---&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">asserttion</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----asserttion钩子函数的调用&#x27;</span>)<br><br><br>s = MTRunner()<br><br>s.preform()<br></code></pre></td></tr></table></figure><p>Python中的钩子函数指的是在特定事件发生时被调用的函数。它们是一种在代码执行期间自动调用的函数，可以用于修改程序的行为，例如在特定事件发生时添加额外的行为或修改已有行为。</p><p>在Python中，有多个标准库和框架支持钩子函数的使用，例如：</p><ol><li>sys.excepthook: 当未捕获的异常发生时，会调用该函数处理异常。可以通过重载该函数来修改异常处理的行为。</li><li>unittest.TestResult.addSuccess、addFailure、addError等方法：这些方法在unittest执行测试时发生并调用，可以用于在测试成功或失败时执行额外的代码或修改测试行为。</li><li>logging.Handler.emit: 该函数在记录日志时被调用，可以用于在记录日志时添加额外的处理或修改日志记录行为。</li><li>setuptools.setup: 在安装Python包时，可以使用该函数的钩子机制自定义安装行为。</li></ol><p>使用钩子函数可以使代码更加灵活，允许我们修改已有的行为或添加新的行为，同时不需要修改现有代码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python进程池和线程池</title>
    <link href="/2020/05/17/Python%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2020/05/17/Python%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python进程池和线程池"><a href="#Python进程池和线程池" class="headerlink" title="Python进程池和线程池"></a>Python进程池和线程池</h1><h2 id="进程池pool"><a href="#进程池pool" class="headerlink" title="进程池pool"></a>进程池pool</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool, Manager<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>(<span class="hljs-params">i</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----work1----&#123;&#125;----&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, os.getpid()))<br>    time.sleep(<span class="hljs-number">0.2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建一个进程池（初始化5个进程）</span><br>    po = Pool(<span class="hljs-number">5</span>)<br>    <span class="hljs-comment"># 往进程池中提交任务</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        po.apply_async(work1, args=(i,))<br>    <span class="hljs-comment"># 关闭进程池</span><br>    po.close()<br><br>po.join()<br></code></pre></td></tr></table></figure><p>该代码演示了如何使用 Python 的 multiprocessing 模块的 Pool 类来创建一个进程池，并在进程池中提交任务。</p><ul><li>首先，通过 <code>Pool(5)</code> 创建一个进程池，其中 5 表示进程池中最多同时运行 5 个进程。</li><li>然后，使用 <code>apply_async()</code> 方法向进程池中提交任务。该方法会异步地执行函数，即会立即返回，不会阻塞主进程。同时，也可以使用 <code>apply()</code> 方法，该方法会阻塞主进程，直到子进程执行完毕。</li><li>最后，调用 <code>close()</code> 方法关闭进程池，防止新的任务提交进来。调用 <code>join()</code> 方法等待所有进程执行完毕，然后主进程才退出。</li></ul><p>在上述示例中，进程池中的工作进程是由操作系统自动分配的，并且可以在运行时动态地增加或减少。虽然进程池通常比单个进程执行任务更快，但进程池也存在一些缺点。例如，如果工作进程之间需要相互通信或共享数据，则必须使用 Manager 对象等方法来实现。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">from concurrent.futures import ThreadPoolExecutor</span><br><span class="hljs-string"></span><br><span class="hljs-string">这个路径导入时没有代码提示的</span><br><span class="hljs-string"></span><br><span class="hljs-string">import time</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>线程池和进程池的方法<br>submit方法：往线程池中提交任务,<br>    参数：<br>        第一个参数为任务函数，后面的时任务函数的参数<br>    返回值:为一个Future类型的对象，<br>        可以通过Future对象的result方法获取任务函数<span class="hljs-keyword">return</span>的结果<br>    <br>shutdown方法：等待线程池中的任务函数执行完毕。<br><br><span class="hljs-built_in">map</span>方法:批量提交任务到线程池<br>    参数：<br>        第一个参数:任务函数<br>        第二个参数：任务函数的参数集（可迭代对象）<br>    返回值：<br>        包含所以任务执行结果的生成器<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">from concurrent.futures.thread import ThreadPoolExecutor</span><br><span class="hljs-string"></span><br><span class="hljs-string">def work1(name):</span><br><span class="hljs-string">    for i in range(1, 6):</span><br><span class="hljs-string">        time.sleep(1)</span><br><span class="hljs-string">        print(&quot;&#123;&#125;-任务1执行的第&#123;&#125;秒&quot;.format(name, i))</span><br><span class="hljs-string">    return &#x27;python6666  --&#123;&#125;&#x27;.format(name)</span><br><span class="hljs-string"></span><br><span class="hljs-string">创建一个线程池</span><br><span class="hljs-string"></span><br><span class="hljs-string">tps = ThreadPoolExecutor(max_workers=5)</span><br><span class="hljs-string"></span><br><span class="hljs-string">提交任务的放啊</span><br><span class="hljs-string"></span><br><span class="hljs-string">fu1 = tps.submit(work1, name=&#x27;张三&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">tps.submit(work1, name=&#x27;李四&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">设置主线程等待线程池中的任务执行完毕</span><br><span class="hljs-string"></span><br><span class="hljs-string">tps.shutdown()</span><br><span class="hljs-string"></span><br><span class="hljs-string">获取任务函数执行的结果</span><br><span class="hljs-string"></span><br><span class="hljs-string">res = fu1.result()</span><br><span class="hljs-string"></span><br><span class="hljs-string">print(res)</span><br><span class="hljs-string"></span><br><span class="hljs-string">res = tps.map(work1, [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;])</span><br><span class="hljs-string"></span><br><span class="hljs-string">#</span><br><span class="hljs-string"></span><br><span class="hljs-string">print(&quot;map的返回值&quot;,list(res))</span><br><span class="hljs-string"></span><br><span class="hljs-string">print(&quot;-----end------------&quot;)</span><br></code></pre></td></tr></table></figure><p>Python中的线程池是一种用于管理和维护线程的机制，通过它可以方便地管理线程的数量和状态，从而实现高效的并发编程。</p><p>使用Python中的线程池可以帮助我们在不同的任务之间快速切换，从而实现高效的任务调度和执行。下面介绍Python中线程池的使用方法。</p><ol><li>导入模块</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br></code></pre></td></tr></table></figure><ol><li>创建线程池</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">executor = ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>上述代码中，我们创建了一个最大容量为5的线程池executor。</p><ol><li>添加任务</li></ol><p>使用submit()方法向线程池中添加任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">future = executor.submit(task_func, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><p>其中，task_func是任务函数，arg1、arg2是函数的参数。submit()方法会返回一个Future对象，通过该对象可以获取任务的执行结果。</p><ol><li>关闭线程池</li></ol><p>在任务执行完毕后，要调用shutdown()方法关闭线程池。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">executor.shutdown()<br></code></pre></td></tr></table></figure><p>下面是一个示例代码，演示如何使用Python线程池：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task_func</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start task &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(n))<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end task &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(n))<br>    <span class="hljs-keyword">return</span> n * n<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建线程池</span><br>    executor = ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># 提交任务</span><br>    futures = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        future = executor.submit(task_func, i)<br>        futures.append(future)<br><br>    <span class="hljs-comment"># 获取任务结果</span><br>    results = []<br>    <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:<br>        result = future.result()<br>        results.append(result)<br><br>    <span class="hljs-comment"># 关闭线程池</span><br>    executor.shutdown()<br><br>    <span class="hljs-comment"># 打印结果</span><br>    <span class="hljs-built_in">print</span>(results)<br></code></pre></td></tr></table></figure><p>上述代码中，我们创建了一个最大容量为5的线程池executor，并向线程池中提交了10个任务。每个任务都会执行1秒钟，并返回一个平方数作为结果。最后，我们打印了所有任务的执行结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br>这个路径导入时没有代码提示的<br><br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">线程池和进程池的方法</span><br><span class="hljs-string">submit方法：往线程池中提交任务,</span><br><span class="hljs-string">    参数：</span><br><span class="hljs-string">        第一个参数为任务函数，后面的时任务函数的参数</span><br><span class="hljs-string">    返回值:为一个Future类型的对象，</span><br><span class="hljs-string">        可以通过Future对象的result方法获取任务函数return的结果</span><br><span class="hljs-string">    </span><br><span class="hljs-string">shutdown方法：等待线程池中的任务函数执行完毕。</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">map方法:批量提交任务到线程池</span><br><span class="hljs-string">    参数：</span><br><span class="hljs-string">        第一个参数:任务函数</span><br><span class="hljs-string">        第二个参数：任务函数的参数集（可迭代对象）</span><br><span class="hljs-string">    返回值：</span><br><span class="hljs-string">        包含所以任务执行结果的生成器</span><br><span class="hljs-string"></span><br><span class="hljs-string">线程池的上下文管理器协议中的退出方法，调用了等待线程池中任务执行结束的方法。</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> concurrent.futures.thread <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;-任务1执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(name, i))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;python6666  --&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name)<br><br>创建一个线程池<br><br><span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> tps:<br>    res = tps.<span class="hljs-built_in">map</span>(work1, [<span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-string">&#x27;22&#x27;</span>, <span class="hljs-string">&#x27;33&#x27;</span>, <span class="hljs-string">&#x27;44&#x27;</span>])<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=========end==================&quot;</span>)<br></code></pre></td></tr></table></figure><p>Python中的线程池可以通过<code>ThreadPoolExecutor</code>类实现，该类提供了丰富的线程池管理方法。在使用线程池时，可以通过使用上下文管理器协议来更方便地管理线程池。上下文管理器协议通过<code>with</code>语句实现，可以自动完成线程池的创建、任务的提交和回收。</p><h2 id="线程池上下文管理器协议"><a href="#线程池上下文管理器协议" class="headerlink" title="线程池上下文管理器协议"></a>线程池上下文管理器协议</h2><p>线程池上下文管理器协议需要实现两个方法：<code>__enter__()</code>和<code>__exit__()</code>。当使用<code>with</code>语句时，<code>__enter__()</code>方法会被调用，并返回一个线程池对象，该对象可以用于提交任务。<code>__exit__()</code>方法则在<code>with</code>块执行完毕后自动被调用，用于清理线程池资源。</p><p>下面是一个使用线程池上下文管理器协议的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">pythonCopy code<br><span class="hljs-keyword">import</span> concurrent.futures<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work1: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work2: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><span class="hljs-comment"># 创建线程池上下文管理器</span><br><span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> executor:<br>    <span class="hljs-comment"># 提交任务</span><br>    future1 = executor.submit(work1)<br>    future2 = executor.submit(work2)<br><br><span class="hljs-comment"># 线程池会在with块执行完毕后自动关闭和回收资源</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们通过<code>with</code>语句创建了一个最大工作线程数为2的线程池。在<code>with</code>块中，我们使用<code>submit()</code>方法向线程池提交了两个任务<code>work1()</code>和<code>work2()</code>。在<code>with</code>块执行完毕后，线程池会自动关闭和回收资源。</p><p>除了<code>submit()</code>方法，线程池还提供了其他方法用于任务的提交和结果的获取。在使用线程池时，可以根据需要选择适合的方法。</p><h2 id="进程池的使用"><a href="#进程池的使用" class="headerlink" title="进程池的使用"></a>进程池的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">from concurrent.futures import ThreadPoolExecutor</span><br><span class="hljs-string"></span><br><span class="hljs-string">这个路径导入时没有代码提示的</span><br><span class="hljs-string"></span><br><span class="hljs-string">import time</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>进程池的方法<br>submit方法：往进程池中提交任务,<br>    参数：<br>        第一个参数为任务函数，后面的时任务函数的参数<br>    返回值:为一个Future类型的对象，<br>        可以通过Future对象的result方法获取任务函数<span class="hljs-keyword">return</span>的结果<br>    <br>shutdown方法：等待进程池中的任务函数执行完毕。<br><br><br><span class="hljs-built_in">map</span>方法:批量提交任务到进程池<br>    参数：<br>        第一个参数:任务函数<br>        第二个参数：任务函数的参数集（可迭代对象）<br>    返回值：<br>        包含所以任务执行结果的生成器<br><br>线程池的上下文管理器协议中的退出方法，调用了等待线程池中任务执行结束的方法。<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">from concurrent.futures.process import ProcessPoolExecutor</span><br><span class="hljs-string">from multiprocessing import Manager</span><br><span class="hljs-string"></span><br><span class="hljs-string">进程池直接的通讯队列</span><br><span class="hljs-string"></span><br><span class="hljs-string">que = Manager().Queue()</span><br><span class="hljs-string"></span><br><span class="hljs-string">def work1(name):</span><br><span class="hljs-string">    for i in range(1, 6):</span><br><span class="hljs-string">        time.sleep(1)</span><br><span class="hljs-string">        print(&quot;&#123;&#125;-任务1执行的第&#123;&#125;秒&quot;.format(name, i))</span><br><span class="hljs-string">    return &#x27;python6666  --&#123;&#125;&#x27;.format(name)</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">if __name__ == &#x27;__main__&#x27;:</span><br><span class="hljs-string">    # 创建一个线程池</span><br><span class="hljs-string">    with ProcessPoolExecutor(max_workers=5) as tps:</span><br><span class="hljs-string">        res = tps.map(work1, [&#x27;11&#x27;, &#x27;22&#x27;, &#x27;33&#x27;, &#x27;44&#x27;])</span><br><span class="hljs-string"></span><br><span class="hljs-string">print(list(res))</span><br><span class="hljs-string">print(&quot;=========end==================&quot;)</span><br></code></pre></td></tr></table></figure><p>Python中的进程池（<code>multiprocessing.Pool</code>）是一种用于管理和分配进程的工具，可以方便地实现进程的并发执行。使用进程池，可以避免重复地创建和销毁进程，减少系统资源的消耗，提高程序的效率。</p><p>下面是使用Python进程池的基本步骤：</p><ol><li><p>导入相关模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br></code></pre></td></tr></table></figure></li><li><p>创建进程池</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Pool(processes=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p><code>processes</code>参数指定进程池中的进程数量。</p></li><li><p>向进程池中提交任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.apply_async(func, args=(...,))<br></code></pre></td></tr></table></figure><p><code>func</code>为要执行的函数，<code>args</code>为函数的参数，可以是一个元组或列表。</p><p>如果要获取任务执行的结果，可以使用<code>get()</code>方法。</p></li><li><p>关闭进程池</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.close()<br></code></pre></td></tr></table></figure></li><li><p>等待任务执行完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.join()<br></code></pre></td></tr></table></figure></li></ol><p>下面是一个使用进程池的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">x</span>):<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> x*x<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pool = Pool(processes=<span class="hljs-number">4</span>)<br>    results = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        results.append(pool.apply_async(worker, args=(i,)))<br>    pool.close()<br>    pool.join()<br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results:<br>        <span class="hljs-built_in">print</span>(r.get())<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们创建了一个进程池，提交了10个任务给进程池执行，并获取任务的结果。注意，我们在调用<code>get()</code>方法时，必须等待任务执行完成后才能获取到结果，否则会阻塞进程。</p><p>进程池除了<code>apply_async()</code>方法外，还提供了其他一些方法，例如<code>apply()</code>、<code>map()</code>、<code>imap()</code>等，它们的使用方式类似于<code>apply_async()</code>方法。具体使用可以查看Python官方文档。</p><h2 id="提交任务返回的Future对象"><a href="#提交任务返回的Future对象" class="headerlink" title="提交任务返回的Future对象"></a>提交任务返回的Future对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">import time</span><br><span class="hljs-string">from concurrent.futures.thread import ThreadPoolExecutor</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>Future对象的方法：<br><br>result():获取任务函数执行返回的结果<br><br>add_done_callback():添加任务执行完之后的回调函数<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">def work1(name):</span><br><span class="hljs-string">    for i in range(1, 6):</span><br><span class="hljs-string">        time.sleep(1)</span><br><span class="hljs-string">        print(&quot;&#123;&#125;-任务1执行的第&#123;&#125;秒&quot;.format(name, i))</span><br><span class="hljs-string">    return &#x27;python6666  --&#123;&#125;&#x27;.format(name)</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">def get_result(fu):</span><br><span class="hljs-string">    print(&quot;回调函数：&quot;, fu.result())</span><br><span class="hljs-string"></span><br><span class="hljs-string">创建一个线程池</span><br><span class="hljs-string"></span><br><span class="hljs-string">with ThreadPoolExecutor(max_workers=5) as tps:</span><br><span class="hljs-string">    for i in [&#x27;木森&#x27;, &#x27;张三&#x27;]:</span><br><span class="hljs-string">        futu = tps.submit(work1, i)</span><br><span class="hljs-string">        futu.add_done_callback(get_result)</span><br></code></pre></td></tr></table></figure><h2 id="unittest的用例执行机制和套件解析"><a href="#unittest的用例执行机制和套件解析" class="headerlink" title="unittest的用例执行机制和套件解析"></a>unittest的用例执行机制和套件解析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>unittest内部用例执行的机制：<br>方式一：通过执行器去执行测试套件（内置的执行器unittest.TextTestRunner()）<br>    <span class="hljs-comment"># 1、创建一个unittest.TestResult()对象，用来保存用例执行的结果</span><br>    <span class="hljs-comment"># 2、调用套件的run方法，执行测试套件suite.run(unittest.TestResult())</span><br>    <span class="hljs-comment"># 3、整理unittest.TestResult()中的执行结果，渲染报告</span><br>    <span class="hljs-comment">#执行器的内部执行用例，本质上还是调用的 套件的run方法</span><br>    <br>方式二：通过测试套件的run方法<br>    <span class="hljs-comment"># 1、遍历套件出套件中所以的测试用例。</span><br>    <span class="hljs-comment"># 2、调用用例的run去执行</span><br>    <br>方式三：通过测试用例的run方法<br>    <span class="hljs-comment"># unittest中用例最终执行的方法</span><br><br>unittest.TestResult:unittest中内置的测试结果收集器<br><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">import unittest</span><br><span class="hljs-string"></span><br><span class="hljs-string">加载指定目录下的用例到测试套件</span><br><span class="hljs-string"></span><br><span class="hljs-string">suite = unittest.defaultTestLoader.discover(r&#x27;C:\project\ck11_class\day11\testcase&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">方式一：</span><br><span class="hljs-string"></span><br><span class="hljs-string">runner = unittest.TextTestRunner()</span><br><span class="hljs-string"></span><br><span class="hljs-string">runner.run(suite)</span><br><span class="hljs-string"></span><br><span class="hljs-string">方式二：调用套件的run方法</span><br><span class="hljs-string"></span><br><span class="hljs-string">res = suite.run(unittest.TestResult())</span><br><span class="hljs-string"></span><br><span class="hljs-string">print(res)</span><br><span class="hljs-string"></span><br><span class="hljs-string">print()</span><br><span class="hljs-string"></span><br><span class="hljs-string">方式三：通过用例的run方法执行</span><br><span class="hljs-string"></span><br><span class="hljs-string">case_ = suite._tests[0]._tests[0]._tests[0]</span><br><span class="hljs-string"></span><br><span class="hljs-string">case_.run(unittest.TestResult())</span><br><span class="hljs-string"></span><br><span class="hljs-string">多线程并发执行用例：</span><br><span class="hljs-string"></span><br><span class="hljs-string">为了确保同一个用例类中，用例执行的前后关系，我们可以测试类作为线程执行的任务提交到线程池</span><br><span class="hljs-string"></span><br><span class="hljs-string">def parse_test_cls(suite):</span><br><span class="hljs-string"></span><br><span class="hljs-string">for item in suite:</span><br><span class="hljs-string"></span><br><span class="hljs-string">for su in item:</span><br><span class="hljs-string"></span><br><span class="hljs-string">for c in su:</span><br><span class="hljs-string"></span><br><span class="hljs-string">print(c, isinstance(c, unittest.TestCase))</span><br><span class="hljs-string"></span><br><span class="hljs-string">保存所以用例类的列表</span><br><span class="hljs-string"></span><br><span class="hljs-string">test_cls = []</span><br><span class="hljs-string"></span><br><span class="hljs-string">def parse_test_cls(suite):</span><br><span class="hljs-string">    for item in suite:</span><br><span class="hljs-string">        if isinstance(item, unittest.TestCase):</span><br><span class="hljs-string">            # print(&quot;item是测试用例&quot;,item)</span><br><span class="hljs-string">            return test_cls.append(suite)</span><br><span class="hljs-string">        else:</span><br><span class="hljs-string">            parse_test_cls(item)</span><br><span class="hljs-string"></span><br><span class="hljs-string">收集所以的用例</span><br><span class="hljs-string"></span><br><span class="hljs-string">suite = unittest.defaultTestLoader.discover(r&#x27;C:\project\ck11_class\day11\testcase&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">解析套件中的用例，以测试类为单位，放入test_cls中</span><br><span class="hljs-string"></span><br><span class="hljs-string">parse_test_cls(suite)</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">print(len(test_cls))</span><br></code></pre></td></tr></table></figure><h2 id="使用线程池并发执行unittest的用例"><a href="#使用线程池并发执行unittest的用例" class="headerlink" title="使用线程池并发执行unittest的用例"></a>使用线程池并发执行unittest的用例</h2><p>“””<br>“””<br>unittest内部用例执行的机制：<br>方式一：通过执行器去执行测试套件（内置的执行器unittest.TextTestRunner()）<br>    # 1、创建一个unittest.TestResult()对象，用来保存用例执行的结果<br>    # 2、调用套件的run方法，执行测试套件suite.run(unittest.TestResult())<br>    # 3、整理unittest.TestResult()中的执行结果，渲染报告<br>    #执行器的内部执行用例，本质上还是调用的 套件的run方法</p><p>方式二：通过测试套件的run方法<br>    # 1、遍历套件出套件中所以的测试用例。<br>    # 2、调用用例的run去执行</p><p>方式三：通过测试用例的run方法<br>    # unittest中用例最终执行的方法</p><p>unittest.TestResult:unittest中内置的测试结果收集器</p><p>“””</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">from</span> concurrent.futures.thread <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestRunner</span>:<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, path</span>):<br>    self.path = path<br><br>创建一个测试结果收集器<br><br>​    self.result = unittest.TestResult()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loadTestCase</span>(<span class="hljs-params">self, path</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param path: 用例存放目录路径</span><br><span class="hljs-string">    :return: 包含所以测试类的列表</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>收集所以的用例<br><br>​    suite = unittest.defaultTestLoader.discover(path)<br><br>保存所以用例类的列表<br><br>​    test_cls = []<br><br>​    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_test_cls</span>(<span class="hljs-params">suite</span>):<br>​        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> suite:<br>​            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(item, unittest.TestCase):<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;item是测试用例&quot;</span>,item)<br><br>​                <span class="hljs-keyword">return</span> test_cls.append(suite)<br>​            <span class="hljs-keyword">else</span>:<br>​                parse_test_cls(item)<br><br>解析套件中的用例，以测试类为单位，放入test_cls中<br><br>​    parse_test_cls(suite)<br><br>​    <span class="hljs-keyword">return</span> test_cls<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, thread_count</span>):<br><br>加载所以的测试类<br><br>​    cases = self.loadTestCase(self.path)<br><br>创建一个线程池<br><br>​    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=thread_count) <span class="hljs-keyword">as</span> tps:<br>​        <span class="hljs-keyword">for</span> cls <span class="hljs-keyword">in</span> cases:<br><br>执行测试用例<br><br>​            tps.submit(cls.run, self.result)<br><br>生成测试报告<br><br>​    self.generator_report()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator_report</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;生成测试报告&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----生成测试报告-----&quot;</span>)<br>    <span class="hljs-built_in">print</span>(self.result)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    runner = MyTestRunner(<span class="hljs-string">r&#x27;C:\project\ck11_class\day11\testcase&#x27;</span>)<br>    runner.run(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python多进程</title>
    <link href="/2020/05/11/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <url>/2020/05/11/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Python多进程"><a href="#Python多进程" class="headerlink" title="Python多进程"></a>Python多进程</h1><h2 id="python中的queue模块"><a href="#python中的queue模块" class="headerlink" title="python中的queue模块"></a>python中的queue模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue, LifoQueue, PriorityQueue<br><br><span class="hljs-comment"># 实例化一个队列（存放数据的容器）</span><br>q = Queue(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 添加数据（如果队列已满，则会进入堵塞状态）</span><br><span class="hljs-comment"># put_nowait: 添加数据不等待（如果队列已满，则会抛出异常）</span><br>q.put(<span class="hljs-string">&#x27;111&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;222&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;333&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;444&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;555&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--------5----&#x27;</span>)<br>q.put_nowait(<span class="hljs-string">&#x27;6666&#x27;</span>)  <span class="hljs-comment"># 如果队列已满，则会抛出异常</span><br>q.put(<span class="hljs-string">&#x27;6666&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--------6----&#x27;</span>)<br><br><span class="hljs-comment"># 获取数据（如果队列为空，则会进入堵塞状态）</span><br><span class="hljs-comment"># get_nowait: 获取数据不等待（如果队列为空，则会抛出异常）</span><br><span class="hljs-built_in">print</span>(q.get())<br><span class="hljs-built_in">print</span>(q.get())<br><span class="hljs-built_in">print</span>(q.get())<br><span class="hljs-built_in">print</span>(q.get())<br><span class="hljs-built_in">print</span>(q.get())<br><span class="hljs-built_in">print</span>(q.get(block=<span class="hljs-literal">False</span>))<br><span class="hljs-built_in">print</span>(q.get(timeout=<span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(q.get_nowait())<br><br><span class="hljs-comment"># 获取队列中数据的长度，判断队列是否已满或为空</span><br>q = Queue(<span class="hljs-number">5</span>)<br>q.put(<span class="hljs-string">&#x27;111&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;222&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;333&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;444&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;555&#x27;</span>)<br><span class="hljs-built_in">print</span>(q.qsize())  <span class="hljs-comment"># 获取队列中数据的长度</span><br><span class="hljs-built_in">print</span>(q.full())  <span class="hljs-comment"># 判断队列是否已满</span><br><span class="hljs-built_in">print</span>(q.empty())  <span class="hljs-comment"># 判断队列是否为空</span><br><br><span class="hljs-comment"># 等待队列中的任务(数据)执行完毕</span><br><span class="hljs-comment"># 通知队列，任务执行结束</span><br>q = Queue(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----start----&quot;</span>)<br>q.put(<span class="hljs-string">&#x27;111&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;222&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;333&#x27;</span>)<br><span class="hljs-built_in">print</span>(q.get())<br><span class="hljs-built_in">print</span>(q.get())<br>q.task_done()  <span class="hljs-comment"># 通知队列，任务执行结束</span><br>q.task_done()  <span class="hljs-comment"># 通知队列，任务执行结束</span><br>q.join()  <span class="hljs-comment"># 等待队列中的任务(数据)执行完毕</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----end----&quot;</span>)<br></code></pre></td></tr></table></figure><p>上述代码演示了 <code>queue</code> 模块中的 <code>Queue</code> 类的使用，其中包括了队列的添加、获取、长度、已满、为空等基本操作，以及等待队列中的任务执行完毕的 <code>join()</code> 方法和通知任务执行结束的 <code>task_done()</code> 方法。</p><p>Python 中的 <code>queue</code> 模块提供了多种数据结构实现的线程安全队列。它提供了 <code>Queue</code>、<code>LifoQueue</code> 和 <code>PriorityQueue</code> 三种队列类型，这些队列都是线程安全的。</p><ul><li><code>Queue</code>：先进先出队列，支持多线程编程。</li><li><code>LifoQueue</code>：后进先出队列，支持多线程编程。</li><li><code>PriorityQueue</code>：带优先级的队列，支持多线程编程。</li></ul><p>这三种队列类型都具有相似的操作方法，包括：</p><ul><li><code>get()</code>：获取队列中的一个元素，如果队列为空则阻塞等待。</li><li><code>put(item)</code>：将一个元素加入队列中，如果队列已满则阻塞等待。</li><li><code>get_nowait()</code>：获取队列中的一个元素，如果队列为空则抛出 <code>queue.Empty</code> 异常。</li><li><code>put_nowait(item)</code>：将一个元素加入队列中，如果队列已满则抛出 <code>queue.Full</code> 异常。</li><li><code>empty()</code>：判断队列是否为空。</li><li><code>full()</code>：判断队列是否已满。</li><li><code>qsize()</code>：获取队列中的元素个数。</li><li><code>join()</code>：等待队列中的所有元素都被取出。</li><li><code>task_done()</code>：用于在完成一项任务后，向任务已经完成的队列发送一个信号。</li></ul><p>除此之外，<code>queue</code> 模块还提供了一些线程安全的基本数据结构，如 <code>deque</code>（双端队列）和 <code>LifoDeque</code>（后进先出的双端队列），它们也可以被用于线程安全的队列实现。</p><p>总之，<code>queue</code> 模块为 Python 多线程编程提供了很好的支持。通过它提供的线程安全队列，可以有效地协调多个线程之间的数据传输和共享。</p><h2 id="队列处理多线程资源竞争的问题"><a href="#队列处理多线程资源竞争的问题" class="headerlink" title="队列处理多线程资源竞争的问题"></a>队列处理多线程资源竞争的问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><br>q = Queue()<br>q.put(<span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        number = q.get()<br>        number += <span class="hljs-number">1</span><br>        q.put(number)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        number = q.get()<br>        number += <span class="hljs-number">1</span><br>        q.put(number)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br>创建线程<br><br>t1 = Thread(target=work1)<br>t2 = Thread(target=work2)<br><br>启动线程<br><br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程：&quot;</span>, q.get())<br></code></pre></td></tr></table></figure><p>以上代码中，我们引入了 <code>queue</code> 模块中的 <code>Queue</code> 类来创建一个队列对象 <code>q</code>。我们将数字 <code>0</code> 放入队列中，并分别创建了两个线程 <code>t1</code> 和 <code>t2</code>，分别执行 <code>work1</code> 和 <code>work2</code> 函数中的任务，从队列中取出数字进行加一并再次放回队列中。最后在主线程中，我们通过 <code>q.get()</code> 方法取出队列中最后一个数字，并输出结果。</p><p>这个例子中展示了如何在多线程环境下使用队列来实现线程之间的数据共享和同步。因为 <code>Queue</code> 类本身就是线程安全的，所以我们可以放心地将其用于多线程编程中。同时，通过队列的先进先出（FIFO）特性，我们可以保证线程之间的数据传递顺序。</p><h2 id="队列扩展"><a href="#队列扩展" class="headerlink" title="队列扩展"></a>队列扩展</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> LifoQueue, PriorityQueue<br><br><span class="hljs-comment"># LifoQueue示例</span><br>q = LifoQueue()<br><br>q.put(<span class="hljs-string">&#x27;111&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;222&#x27;</span>)<br>q.put(<span class="hljs-string">&#x27;333&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(q.get())<br><br><span class="hljs-comment"># PriorityQueue示例</span><br>q = PriorityQueue()<br><br><span class="hljs-comment"># 队列中添加的数据为元组（元组的第一个值表示优先级）</span><br>q.put((<span class="hljs-number">999</span>, <span class="hljs-string">&#x27;go&#x27;</span>))<br>q.put((<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;3php&#x27;</span>))<br>q.put((<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1python&#x27;</span>))<br>q.put((<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2java&#x27;</span>))<br><br><span class="hljs-comment"># 会根据优先级来获取数据，优先级值越小，越先出来</span><br><span class="hljs-built_in">print</span>(q.get())<br><span class="hljs-built_in">print</span>(q.get())<br><span class="hljs-built_in">print</span>(q.get())<br></code></pre></td></tr></table></figure><p>在上述代码中，我们引入了 <code>queue</code> 模块中的 <code>LifoQueue</code> 和 <code>PriorityQueue</code> 类来创建了两个不同类型的队列对象 <code>q</code>。在 <code>LifoQueue</code> 示例中，我们向队列中添加了三个元素，并通过 <code>get()</code> 方法以后进先出（LIFO）的方式取出了最后一个元素。在 <code>PriorityQueue</code> 示例中，我们向队列中添加了四个元组，其中每个元组包含了一个优先级和一个数据项，通过 <code>get()</code> 方法按照优先级从小到大取出了三个元素。</p><h2 id="通过线程和队列实现生产者消费者模式"><a href="#通过线程和队列实现生产者消费者模式" class="headerlink" title="通过线程和队列实现生产者消费者模式"></a>通过线程和队列实现生产者消费者模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br>datas = Queue(<span class="hljs-number">10000</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PutData</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;生产者&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>            data = <span class="hljs-string">&#x27;第&#123;&#125;轮--数据&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(count, i)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生产：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(data))<br>            datas.put(data)<br>        time.sleep(<span class="hljs-number">1</span>)<br>        count += <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleData</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;消费者&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;消费：数据&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(datas.get()))<br>        time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br><span class="hljs-comment">#一个线程生产</span><br><br>    PutData().start()<br><br><span class="hljs-comment">#5个线程消费</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        HandleData().start()<br></code></pre></td></tr></table></figure><p>这段代码实现了一个简单的生产者-消费者模型。其中，<code>PutData</code> 类作为生产者，每秒钟生产 100 条数据，并将数据放入 <code>Queue</code> 中；<code>HandleData</code> 类作为消费者，每秒钟消费 20 条数据。</p><p>主程序中创建了一个生产者线程和五个消费者线程，启动后即开始不断地生产和消费数据。</p><p>其中，<code>Queue</code> 是 Python 内置的线程安全的队列类，可以用于在线程间传递数据。在本例中，<code>Queue</code> 实例 <code>datas</code> 的最大容量为 10000。<code>put</code> 方法用于向队列中添加元素，<code>get</code> 方法用于从队列中取出元素。当队列已满或已空时，<code>put</code> 方法和 <code>get</code> 方法都会阻塞线程。</p><p><code>Thread</code> 类是 Python 内置的线程类，可以用于创建新线程。在本例中，每个生产者和消费者都继承自 <code>Thread</code> 类，并覆盖了 <code>run</code> 方法。<code>run</code> 方法是线程的主体，包含了线程的执行逻辑。线程启动后，<code>run</code> 方法会在新的线程中执行。</p><p>该代码实现了简单的生产者-消费者模型，但是存在一些问题。例如，生产者和消费者之间的数据同步问题需要仔细考虑。此外，<code>Queue</code> 的最大容量也可能会成为瓶颈，需要根据实际情况进行调整。</p><h2 id="python中的进程模块使用"><a href="#python中的进程模块使用" class="headerlink" title="python中的进程模块使用"></a>python中的进程模块使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">进程：进行的资源是独立的</span><br><span class="hljs-string"></span><br><span class="hljs-string">注意点：window下 python创建多进程的代码入口一定要放在 if __name__ == &#x27;__main__&#x27;:里面</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务1执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务2执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 创建子进程</span><br>    p1 = Process(target=work1)<br>    p2 = Process(target=work2)<br><br><span class="hljs-comment">#启动进程</span><br><br>p1.start()<br>p2.start()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>Python提供了内置的<code>multiprocessing</code>模块，可以在Python中创建进程，实现多进程编程。在Python中，可以使用<code>Process</code>类来创建进程。下面介绍一些常用的进程模块中的函数和方法：</p><ol><li><code>Process(target=函数名, args=(传递的参数))</code>: 用于创建一个新的进程，其中<code>target</code>参数为子进程执行的函数名，<code>args</code>参数为传递给子进程的参数，可以传递多个参数，以元组的形式传递。</li><li><code>process.start()</code>: 启动进程。调用<code>process.start()</code>方法会执行<code>target(*args)</code>。</li><li><code>process.join([timeout])</code>: 阻塞进程，等待子进程结束。<code>timeout</code>为可选参数，表示阻塞的最长时间，单位是秒。如果不传递该参数，主进程将一直等待子进程结束。</li><li><code>process.terminate()</code>: 强制终止进程。</li></ol><p>下面是一个简单的例子，演示如何使用进程模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>次执行，进程id为：<span class="hljs-subst">&#123;os.getpid()&#125;</span>&quot;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p1 = Process(target=func, args=(<span class="hljs-number">5</span>,))<br>    p2 = Process(target=func, args=(<span class="hljs-number">3</span>,))<br>    <br>    p1.start()<br>    p2.start()<br>    <br>    p1.join()<br>    p2.join()<br></code></pre></td></tr></table></figure><p>上述代码中，我们使用<code>Process</code>类创建了两个子进程，分别执行<code>func(5)</code>和<code>func(3)</code>函数。在主进程中，使用<code>p1.join()</code>和<code>p2.join()</code>语句阻塞主进程，等待子进程执行结束。执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">第<span class="hljs-number">1</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4922</span><br>第<span class="hljs-number">1</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4923</span><br>第<span class="hljs-number">2</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4922</span><br>第<span class="hljs-number">2</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4923</span><br>第<span class="hljs-number">3</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4922</span><br>第<span class="hljs-number">3</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4923</span><br>第<span class="hljs-number">4</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4922</span><br>第<span class="hljs-number">1</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4924</span><br>第<span class="hljs-number">5</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4922</span><br>第<span class="hljs-number">2</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4924</span><br>第<span class="hljs-number">3</span>次执行，进程<span class="hljs-built_in">id</span>为：<span class="hljs-number">4924</span><br></code></pre></td></tr></table></figure><p>注意，在多进程编程中，每个子进程都有独立的内存空间，各个子进程之间不能直接共享数据，因此需要使用<code>Queue</code>等数据结构实现进程间通信，才能实现数据共享。此外，由于进程的创建和销毁需要一定的开销，因此过多地创建进程会导致系统资源的浪费，应该在创建进程时慎重考虑。</p><h2 id="python进程对象的参数和方法"><a href="#python进程对象的参数和方法" class="headerlink" title="python进程对象的参数和方法"></a>python进程对象的参数和方法</h2><p>“””<br>from multiprocessing import Process</p><p>“””<br>Process创建线程的参数：<br>    target：指定线程执行的任务函数<br>    daemon：是否设置为守护进程（默认是False）,【守护线进程：主进程执行结束后，自动退出】<br>    name:设置进程名<br>    args：给任务函数传递位置参数（元组）<br>    kwargs:给任务函数传递关键字参数(字典)</p><p>进程对像的方法：<br>    start():启动线进程的<br>    join()：设置主进程等待子进程执行的时间（默认等待执行完毕）<br>    run():进程中执行任务函数的方法</p><p>在进程中如何获取进程的id以及父进程的id</p><p>获取进程id:os.getpid<br>获取父进程id:os.getppid</p><p>判断进程是否存活</p><p>“””</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;父进程的id为<span class="hljs-subst">&#123;os.getppid()&#125;</span>，当前进程id为：<span class="hljs-subst">&#123;os.getpid()&#125;</span>任务1执行的第<span class="hljs-subst">&#123;i&#125;</span>秒&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;父进程的id为<span class="hljs-subst">&#123;os.getppid()&#125;</span>,进程id为：<span class="hljs-subst">&#123;os.getpid()&#125;</span>任务2执行的第<span class="hljs-subst">&#123;i&#125;</span>秒&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 创建子进程</span><br>    p1 = Process(target=work1)<br>    p2 = Process(target=work2)<br><br>启动进程<br><br>p1.start()<br>p2.start()<br><br>进程的其他几个方法<br><br><span class="hljs-built_in">print</span>(p1.is_alive())<br><span class="hljs-built_in">print</span>(p2.is_alive())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主进程结束,主进程的id&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(os.getpid()))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>Python中的<code>Process</code>类是用于创建子进程的类，提供了很多参数和方法，下面详细介绍一下。</p><h2 id="创建Process对象"><a href="#创建Process对象" class="headerlink" title="创建Process对象"></a>创建Process对象</h2><p>创建<code>Process</code>对象时可以传递以下参数：</p><ul><li><code>target</code>：表示要执行的方法，必须为可调用对象。</li><li><code>args</code>：表示要传递给方法的参数，必须为元组。</li><li><code>kwargs</code>：表示要传递给方法的关键字参数，必须为字典。</li><li><code>name</code>：表示进程的名称，可以自定义，便于识别，默认为”Process-N”，其中N为进程编号。</li><li><code>daemon</code>：表示该进程是否为守护进程，守护进程会随着主进程的退出而自动退出，默认为False。</li><li><code>group</code>：表示进程组，暂不使用。</li></ul><p>创建<code>Process</code>对象的方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;This is a process.&#x27;</span>)<br><br>p = Process(target=func)<br></code></pre></td></tr></table></figure><h2 id="Process对象方法"><a href="#Process对象方法" class="headerlink" title="Process对象方法"></a>Process对象方法</h2><p><code>Process</code>类还提供了以下方法：</p><ul><li><code>start()</code>：启动进程，会自动调用<code>run()</code>方法。</li><li><code>run()</code>：进程启动后执行的方法。</li><li><code>join([timeout])</code>：等待进程结束，如果指定了timeout，则最多等待timeout秒，否则一直等待进程结束。</li><li><code>terminate()</code>：立即终止进程。</li><li><code>is_alive()</code>：判断进程是否在运行。</li></ul><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;This is <span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span> second.&#x27;</span>)<br><br>p = Process(target=func)<br>p.start()<br>p.join(<span class="hljs-number">3</span>) <span class="hljs-comment"># 等待3秒</span><br>p.terminate() <span class="hljs-comment"># 终止进程</span><br><span class="hljs-keyword">if</span> p.is_alive():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Process is running.&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Process is terminated.&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="Process对象属性"><a href="#Process对象属性" class="headerlink" title="Process对象属性"></a>Process对象属性</h2><p><code>Process</code>类还提供了以下属性：</p><ul><li><code>name</code>：表示进程的名称，可以自定义，便于识别，默认为”Process-N”，其中N为进程编号。</li><li><code>daemon</code>：表示该进程是否为守护进程，守护进程会随着主进程的退出而自动退出，默认为False。</li><li><code>pid</code>：表示进程的ID。</li></ul><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;This is <span class="hljs-subst">&#123;p.name&#125;</span> (<span class="hljs-subst">&#123;p.pid&#125;</span>)&#x27;</span>)<br>    time.sleep(<span class="hljs-number">3</span>)<br><br>p = Process(target=func, name=<span class="hljs-string">&#x27;MyProcess&#x27;</span>)<br>p.daemon = <span class="hljs-literal">True</span><br>p.start()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;p.name&#125;</span> (<span class="hljs-subst">&#123;p.pid&#125;</span>) is running.&#x27;</span>)<br>p.join()<br></code></pre></td></tr></table></figure><p>以上就是<code>Process</code>对象的参数、方法和属性的详细介绍。</p><h2 id="进程之间如何共享数据"><a href="#进程之间如何共享数据" class="headerlink" title="进程之间如何共享数据"></a>进程之间如何共享数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">进程之间资源是独立，那么以为全局变量不共享</span><br><span class="hljs-string"></span><br><span class="hljs-string">queue.Queue:只能在同一个进程中多个线程之间进程通讯(数据共享)</span><br><span class="hljs-string"></span><br><span class="hljs-string">multiprocessing.Queue:进程之间通信的队列(跨进程实现数据共享)</span><br><span class="hljs-string"></span><br><span class="hljs-string">multiprocessing.Manager().Queue:进程池通信的对象(进程池中多个进程之间数据共享)</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue, Manager<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>(<span class="hljs-params">que</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;work1:&#x27;</span>, que.qsize(), que.get())<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>(<span class="hljs-params">que</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;work2:&#x27;</span>, que.qsize(), que.get())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    q = Queue()<br>    q.put(<span class="hljs-number">111</span>)<br>    q.put(<span class="hljs-number">222</span>)<br>    q.put(<span class="hljs-number">333</span>)<br>    <span class="hljs-comment"># 创建子进程</span><br>    p1 = Process(target=work1, args=(q,))<br>    p2 = Process(target=work2, args=(q,))<br>    <span class="hljs-comment"># 启动进程</span><br>    p1.start()<br>    p2.start()<br>    p1.join()<br>    p2.join()<br><br><span class="hljs-built_in">print</span>(q.qsize())<br></code></pre></td></tr></table></figure><p>在多进程编程中，进程之间共享数据是一项重要的功能。Python提供了多种共享数据的方式，下面介绍几种常用的方式。</p><ol><li>使用共享内存</li></ol><p>Python提供了multiprocessing.Value和multiprocessing.Array两个类，可以实现在多个进程之间共享数据。其中multiprocessing.Value是用于共享一个简单的C类型的值（如整数、浮点数等），multiprocessing.Array则是用于共享一个数组。</p><p>例如，下面的代码演示了如何在两个进程之间共享一个整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Value<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">count</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count.value):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;working...&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    count = Value(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 创建一个共享的整数对象</span><br>    p = Process(target=worker, args=(count,))<br>    p.start()<br>    p.join()<br></code></pre></td></tr></table></figure><p>在这个例子中，首先创建了一个共享的整数对象count，然后传递给子进程worker。在子进程中，通过count.value来获取这个共享的整数对象的值。需要注意的是，在共享数据时需要使用锁来保证数据的正确性。</p><ol><li>使用队列</li></ol><p>队列是多进程编程中常用的一种数据结构，Python中的multiprocessing.Queue类可以实现进程之间的通信和数据共享。</p><p>例如，下面的代码演示了如何在两个进程之间共享一个队列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        data = q.get()<br>        <span class="hljs-keyword">if</span> data <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-built_in">print</span>(data)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    q = Queue()  <span class="hljs-comment"># 创建一个队列</span><br>    p = Process(target=worker, args=(q,))<br>    p.start()<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        q.put(i)  <span class="hljs-comment"># 向队列中添加数据</span><br><br>    q.put(<span class="hljs-literal">None</span>)  <span class="hljs-comment"># 发送结束标志给子进程</span><br><br>    p.join()<br></code></pre></td></tr></table></figure><p>在这个例子中，首先创建了一个共享队列q，然后传递给子进程worker。在主进程中，通过q.put()向队列中添加数据，在子进程中通过q.get()获取数据。需要注意的是，在使用队列时，由于队列本身已经实现了线程安全，因此不需要使用额外的锁。</p><ol><li>使用共享变量</li></ol><p>共享变量是一种进程之间共享数据的简单方法，但需要注意的是，在多进程编程中需要使用进程锁来保证数据的正确性。下面的代码演示了如何在两个进程之间共享一个变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Lock<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">lock, data</span>):<br>    <span class="hljs-keyword">with</span> lock:<br>        <span class="hljs-built_in">print</span>(data.value)<br>        data.value += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    lock = Lock()<br>    data = Value(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">0</span>)<br><br>    p1 = Process(target=worker, args=(lock, data))<br>    p2 = Process(target=worker, args=(lock, data))<br><br>    p1.start()<br>    p2.start()<br><br>    p1.join()<br>    p2.join<br></code></pre></td></tr></table></figure><h2 id="可序列化的python对象"><a href="#可序列化的python对象" class="headerlink" title="可序列化的python对象"></a>可序列化的python对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-keyword">import</span> unittest<br><br>a = <span class="hljs-number">11</span><br><br>res = pickle.dumps(a)<br><br><span class="hljs-built_in">print</span>(res)<br><br>testr = unittest.TestResult()<br><br>res = pickle.dumps(testr)<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python多线程编程入门指南：初步了解并行处理</title>
    <link href="/2020/05/01/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/"/>
    <url>/2020/05/01/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Python多线程编程入门指南：初步了解并行处理"><a href="#Python多线程编程入门指南：初步了解并行处理" class="headerlink" title="Python多线程编程入门指南：初步了解并行处理"></a>Python多线程编程入门指南：初步了解并行处理</h1><h2 id="python的引用计数机制"><a href="#python的引用计数机制" class="headerlink" title="python的引用计数机制"></a>python的引用计数机制</h2><p>Python中的引用计数机制是Python用于管理内存的一种方式，也是Python最关键的对象管理机制之一。每个Python对象都具有一个引用计数器，用于记录当前有多少个变量或者对象引用了该对象，当该计数器变为0时，Python会自动将该对象从内存中删除，以释放内存空间。</p><p>引用计数机制的优点是，当一个对象不再被引用时，Python可以立即将其从内存中删除，而不必等到垃圾回收器运行。这可以有效地减少内存的占用和释放的频率，提高程序的性能和效率。</p><p>在Python中，引用计数增加的情况有：</p><ol><li>创建对象，用变量接收：<code>name = &#39;123&#39;</code></li><li>对象被其他变量引用：<code>name2 = name</code></li><li>对象被其他对象引用（放入其他容器类型的数据中）：<code>li = [11, 22, name]</code></li><li>当作为函数参数传入函数中时：<code>def func(n):print(n)func(name)</code></li></ol><p>引用计数减少的情况包括：</p><ol><li>变量被显式销毁：<code>del name</code></li><li>引用对象的变量指向了其他对象（变量被重新赋了别的值）：<code>name2 = &#39;abc&#39;</code></li><li>从其他对象（容器类型数据中）移除：<code>li.pop()</code></li><li>函数执行完毕之后，内部作用域的变量会被销毁。</li></ol><p>除了引用计数机制，Python还使用了一些其他的机制来优化内存管理。例如，Python中有一个小整数池，其中包含了一些常用的整数（从-5到256）。如果程序中使用这些整数，Python会直接引用这些整数，而不是重新创建。此外，Python还有一个字符串驻留池机制，用于优化纯字符串的创建和管理，以及缓存机制，用于缓存常用的内置数据类型。这些机制都能够帮助Python有效地管理内存，提高程序的性能和效率。</p><h2 id="python中垃圾回收机制"><a href="#python中垃圾回收机制" class="headerlink" title="python中垃圾回收机制"></a>python中垃圾回收机制</h2><p>Python的垃圾回收机制主要分为三个部分：引用计数、标记清除和分代回收。</p><p>引用计数是Python最基础也是最重要的垃圾回收机制。在Python中，每个对象都会维护一个引用计数，当这个对象被创建时，引用计数为1；每当有一个新的变量引用这个对象，它的引用计数就会加1；当一个变量不再引用这个对象时，它的引用计数就会减1。当一个对象的引用计数为0时，说明没有任何变量引用它了，这时Python就会把它当作垃圾进行回收。通过引用计数机制，Python可以快速地回收不再使用的对象，释放内存。</p><p>然而，引用计数机制可能会遇到循环引用的问题，即两个或多个对象之间互相引用，导致它们的引用计数不为0。为了解决这个问题，Python引入了标记清除机制。标记清除的原理是，从所有的根对象开始，遍历整个对象图，对所有可以访问到的对象进行标记，标记完成后，所有未标记的对象就是垃圾，可以被回收。标记清除虽然可以解决循环引用问题，但是它的效率不如引用计数高。</p><p>为了兼顾引用计数的高效和标记清除的完整性，Python还引入了分代回收机制。分代回收的思想是，把所有对象分成三代，新创建的对象放在第一代，经过一定时间或经过一定次数的垃圾回收后依然存活的对象升级到第二代，以此类推。不同的代采用不同的垃圾回收策略，第一代使用引用计数和简单标记清除，第二代使用更复杂的标记清除和分代回收，第三代使用更复杂的标记清除和完整的分代回收。这样做的好处是，大多数对象都是短命的，只在第一代中存活，只有少数对象能够升级到第二代或第三代，这样就大大减少了垃圾回收的频率，提高了Python的性能。</p><p>除了引用计数机制和垃圾回收机制外，Python还实现了一些优化机制，如小整数池和字符串驻留池。</p><p>小整数池是Python对于范围在[-5, 256]的整数做了一个缓存，这些整数在程序中多次出现时，不会重新创建，而是直接引用缓存中的对象。这样可以节省内存空间，也能提高程序的执行效率。</p><p>字符串驻留池则是对于纯字符组成的字符串做了一个缓存，这些字符串在程序中多次出现时，也不会重新创建，而是直接引用缓存中的对象。字符串驻留池的实现方式是，当程序中定义了一个字符串后，如果这个字符串是由一系列字符组成的，并且这个字符串的长度在一定范围内，Python会把这个字符串缓存起来，以便在程序中的其他位置引用相同的字符串时直接使用缓存中的对象。这种方式同样可以节省内存空间，提高程序的执行效率。</p><p>此外，Python还实现了其他一些优化机制，如迭代器、生成器、装饰器等，这些机制可以使程序更加简洁、高效、易于维护。例如，迭代器可以让程序处理大量数据时不必一次性把数据全部加载到内存中，而是可以在需要时逐个取出数据，避免了内存占用过大的问题；生成器可以使程序更加高效地生成大量数据，减少内存的使用；装饰器可以让程序的功能更加灵活、可扩展，便于维护和管理。</p><h2 id="并发编程和多任务"><a href="#并发编程和多任务" class="headerlink" title="并发编程和多任务"></a>并发编程和多任务</h2><p>在Python中，多任务、并发和并行是三个重要的概念。</p><p>多任务是指同时运行多个任务，任务可以是多个线程或进程。在多任务环境下，每个任务都是独立运行的，但它们共享计算机的资源。在Python中，我们可以通过多线程、多进程或协程来实现多任务。</p><p>并发是指同时处理多个任务，但是它并不是真正的同时执行。在并发模式下，任务会轮流进行，使得它们看起来像是同时执行。在Python中，我们可以使用多线程、协程或异步IO来实现并发。</p><p>并行是指同时执行多个任务，也就是说多个任务真正的同时执行。在并行模式下，每个任务都有自己的处理器，可以并行执行。在Python中，我们可以通过多进程、协程或异步IO来实现并行。</p><p>需要注意的是，并发和并行是不同的概念。并发可以在单核处理器上实现，通过不断地切换任务达到看似同时执行的效果。而并行则需要多核处理器的支持，可以真正地同时执行多个任务。</p><h2 id="认识多线程"><a href="#认识多线程" class="headerlink" title="认识多线程"></a>认识多线程</h2><ol><li><p>什么是多线程？</p><ul><li>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。</li><li>多线程就是在一个程序中同时运行多个线程完成不同的任务，每个线程都可以独立运行，并且共享程序的内存空间。</li></ul></li><li><p>为什么需要多线程？</p><ul><li>多线程可以提高程序的运行效率，特别是在多核 CPU 的计算机上。</li><li>多线程可以实现并发编程，使得程序能够同时处理多个任务，提高了程序的响应速度。</li></ul></li><li><p>Python 中如何实现多线程？ </p><ul><li><p>Python 中可以使用内置的 threading 模块来实现多线程。</p></li><li><p>创建线程：通过 Thread 类来创建线程对象。</p></li><li><p>启动线程：通过 start() 方法来启动线程。</p></li><li><p>在子线程中执行任务：通过将需要执行的任务封装成一个函数，并将函数名作为 target 参数传入 Thread 类的构造函数中。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务1执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务2执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><span class="hljs-comment"># 创建线程</span><br>t1 = Thread(target=work1)<br>t2 = Thread(target=work2)<br><br><span class="hljs-comment"># 启动线程</span><br>t1.start()<br>t2.start()<br></code></pre></td></tr></table></figure></li><li><p>代码演示</p><ul><li>上述代码通过创建两个线程来模拟多任务的场景，其中 t1 线程执行 work1 函数，t2 线程执行 work2 函数。</li><li>在执行 t1.start() 和 t2.start() 之后，t1 和 t2 线程会同时启动，并且分别执行 work1 和 work2 函数中的代码。</li><li>由于 t1 和 t2 线程是并发执行的，因此在控制台中会看到两个函数的输出交替出现，这就实现了多任务的效果。</li></ul></li></ol><h2 id="线程模块的使用"><a href="#线程模块的使用" class="headerlink" title="线程模块的使用"></a>线程模块的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">import time</span><br><span class="hljs-string">from threading import Thread</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">def work1(name):</span><br><span class="hljs-string">    for i in range(1, 6):</span><br><span class="hljs-string">        time.sleep(1)</span><br><span class="hljs-string">        print(&quot;&#123;&#125;-任务1执行的第&#123;&#125;秒&quot;.format(name, i))</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">def work2(name):</span><br><span class="hljs-string">    for i in range(1, 7):</span><br><span class="hljs-string">        time.sleep(1)</span><br><span class="hljs-string">        print(&quot;&#123;&#125;-任务2执行的第&#123;&#125;秒&quot;.format(name, i))</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>Thread创建线程的参数：<br>    target：指定线程执行的任务函数<br>    daemon：是否设置为守护线程（默认是<span class="hljs-literal">False</span>）,【守护线程：主线程执行结束后，自动退出】<br>    name:设置线程名<br>    args：给任务函数传递位置参数（元组）<br>    kwargs:给任务函数传递关键字参数(字典)<br>    group：不需要传<br><br>线程对像的方法：<br>    start():启动线程的<br>    join()：设置主线程等待子线程执行的时间（默认等待执行完毕）<br>    run():线程中执行任务函数的方法<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">if __name__ == &#x27;__main__&#x27;:</span><br><span class="hljs-string">    s_time = time.time()</span><br><span class="hljs-string">    # 创建子线程</span><br><span class="hljs-string">    t1 = Thread(target=work1, args=(&#x27;张三&#x27;,))</span><br><span class="hljs-string">    t2 = Thread(target=work2, kwargs=&#123;&#x27;name&#x27;: &quot;李四&quot;&#125;)</span><br><span class="hljs-string">    # 启动线程</span><br><span class="hljs-string">    t1.start()</span><br><span class="hljs-string">    t2.start()</span><br><span class="hljs-string">    t1.run()</span><br><span class="hljs-string"></span><br><span class="hljs-string">    # 线程对象的join方法：设置主线程等待的时间</span><br><span class="hljs-string">    # t1.join(1)</span><br><span class="hljs-string">    # t2.join()</span><br><span class="hljs-string">    # 注意点：默认情况下，主线程不会等待子线程</span><br><span class="hljs-string">    e_time = time.time()</span><br><span class="hljs-string">    print(&quot;两个任务执行的总时间:&quot;, e_time - s_time)</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h2 id="自定义线程类"><a href="#自定义线程类" class="headerlink" title="自定义线程类"></a>自定义线程类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">自定义线程类的适用场景：</span><br><span class="hljs-string">    创建一个或多个执行特定任务的线程，可以再自定义线程类的run方法中，写任务执行的逻辑代码</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTread</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;用来生成测试数据&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;-任务执行的第&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(self.name, i))<br><br><br>t = MyTread(name=<span class="hljs-string">&#x27;musen&#x27;</span>)<br>t.start()<br><br>t2 = MyTread(name=<span class="hljs-string">&#x27;yuze&#x27;</span>)<br>t2.start()<br><br>t.run()<br><br>t2.run()<br></code></pre></td></tr></table></figure><h2 id="多线程之间资源竞争的问题"><a href="#多线程之间资源竞争的问题" class="headerlink" title="多线程之间资源竞争的问题"></a>多线程之间资源竞争的问题</h2><p>python中多线程是共享全局变量的（会出现资源竞争）</p><p>Cpython解释器中由于全局解释器锁(GIL)的存在，在同一时间，多个线程无法真正的一起执行(不可能出现并行)</p><p>python的GIL锁：<br>    1、线程只有获取全局解释器锁才能执行，执行到【线程切换的情况】会释放全局解释器锁<br>    线程切换的两种情况：<br>        1、线程执行遇到耗时等待（IO[input output]操作）<br>        2、执行时间达到指定的阈值(0.005秒)<br>            import sys<br>            print(sys.getswitchinterval())</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        number += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work1：&quot;</span>, number)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        number += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work2：&quot;</span>, number)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br>    <span class="hljs-comment"># 创建线程</span><br>    t1 = Thread(target=work1)<br>    t2 = Thread(target=work2)<br><br>    <span class="hljs-comment"># 启动线程</span><br>    t1.start()<br>    t2.start()<br><br>    <span class="hljs-comment"># 等待子线程执行完毕</span><br>    t1.join()<br>    t2.join()<br><br>    <span class="hljs-comment"># 输出结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程：&quot;</span>, number)<br></code></pre></td></tr></table></figure><p>这段代码演示了Python多线程中全局变量的问题。在两个线程<code>work1</code>和<code>work2</code>中都对全局变量<code>number</code>进行了100000次的加1操作。当主线程在两个子线程执行完毕后打印全局变量<code>number</code>时，由于两个子线程同时修改了<code>number</code>变量，所以可能得到意料之外的结果。</p><p>为了解决这个问题，可以使用锁机制来保证同一时间只有一个线程能够修改<code>number</code>变量。Python中提供了一个内置的<code>Lock</code>对象，可以使用它来实现线程同步，保证线程安全。下面是一份使用<code>Lock</code>对象解决上述问题的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-number">0</span><br>lock = Lock()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        <span class="hljs-keyword">with</span> lock:<br>            number += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work1：&quot;</span>, number)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        <span class="hljs-keyword">with</span> lock:<br>            number += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work2：&quot;</span>, number)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Lock<br><br>    <span class="hljs-comment"># 创建线程</span><br>    t1 = Thread(target=work1)<br>    t2 = Thread(target=work2)<br><br>    <span class="hljs-comment"># 启动线程</span><br>    t1.start()<br>    t2.start()<br><br>    <span class="hljs-comment"># 等待子线程执行完毕</span><br>    t1.join()<br>    t2.join()<br><br>    <span class="hljs-comment"># 输出结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程：&quot;</span>, number)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们首先创建了一个<code>Lock</code>对象，并在<code>work1</code>和<code>work2</code>函数中使用了<code>with lock</code>语句块，确保每次只有一个线程能够执行对<code>number</code>变量的修改。这样，当两个子线程完成了对<code>number</code>的所有修改后，主线程打印<code>number</code>的值就能得到正确的结果。</p><p>需要注意的是，在使用锁的过程中，需要避免死锁问题的发生，即两个线程相互等待对方释放锁而无法继续执行的情况。因此，在使用锁时需要遵循一些规则，如尽量避免使用嵌套锁、避免长时间持有锁等。</p><h2 id="线程模块中的Luck"><a href="#线程模块中的Luck" class="headerlink" title="线程模块中的Luck"></a>线程模块中的Luck</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Lock, Thread<br><br>number = <span class="hljs-number">0</span><br><br>使用Lock创建一把锁：锁的两种状态（上锁，未上锁）<br><br>loc = Lock()<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">注意点：</span><br><span class="hljs-string">    为了解决多线程操作共同的全局变量，出现资源竞争的情况，可以通过锁把</span><br><span class="hljs-string">    关键的代码【对全局资源修改的代码】锁起来，确保同一时间只有一个线程执行【对全局资源修改的代码】</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500000</span>):<br>        <span class="hljs-comment"># 上锁</span><br>        loc.acquire()<br>        number += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 释放锁</span><br>        loc.release()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work1：&quot;</span>, number)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500000</span>):<br>        <span class="hljs-comment"># 上锁</span><br>        loc.acquire()<br>        number += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 释放锁</span><br>        loc.release()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work2：&quot;</span>, number)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>创建线程<br><br>​    t1 = Thread(target=work1)<br>​    t2 = Thread(target=work2)<br><br>启动线程<br><br>​    t1.start()<br>​    t2.start()<br>​    t1.join()<br>​    t2.join()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程：&quot;</span>, number)<br></code></pre></td></tr></table></figure><p>本段代码演示了在多线程程序中如何使用 Lock（锁） 解决共享全局变量出现资源竞争的问题。</p><p>首先，通过 from threading import Lock 引入了 Lock 类。然后，创建了一把锁：loc &#x3D; Lock()。</p><p>在 work1 和 work2 函数中对全局变量 number 进行了 500000 次的自增操作。为了避免出现资源竞争，上锁和释放锁的操作必须要成对出现，保证同一时间只有一个线程执行修改共享全局变量的代码段。具体来说，在执行 number +&#x3D; 1 前，先调用 loc.acquire() 上锁；在执行完后，再调用 loc.release() 释放锁。这样可以保证多线程修改同一个全局变量时，不会出现数据错误。</p><p>最后，在主线程中输出了全局变量 number 的值。</p><p>在使用 Lock 的时候，需要注意以下几点：</p><ol><li>Lock 对象创建后处于未上锁状态，即 Lock.acquire() 返回值为 True。</li><li>多个线程可以同时调用 Lock.acquire() 上锁，但只有一个线程可以成功获取锁，其他线程会阻塞直到锁被释放。</li><li>可以通过调用 Lock.release() 释放锁，使其他线程可以获取到锁。</li><li>上锁和释放锁的操作必须要成对出现，否则会出现死锁等问题。</li><li>锁的过度使用会降低程序的性能。因此，在多线程编程时，应该尽量减少锁的使用。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python元类</title>
    <link href="/2020/04/23/%E8%AE%A4%E8%AF%86%E5%85%83%E7%B1%BB/"/>
    <url>/2020/04/23/%E8%AE%A4%E8%AF%86%E5%85%83%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Python元类"><a href="#Python元类" class="headerlink" title="Python元类"></a>Python元类</h1><h2 id="认识元类"><a href="#认识元类" class="headerlink" title="认识元类"></a>认识元类</h2><p>Python中的元类是一种高级语言特性，是Python中面向对象编程的重要组成部分之一。元类用于创建类，就像类用于创建对象一样。元类可以控制类的创建过程，可以修改类的属性、方法等等，同时也可以控制类的实例化过程。</p><p>在Python中，所有的东西都是对象，包括类。Python中的类是一个对象，是由元类创建出来的。元类实际上就是一个类的类，用于创建类对象。</p><p>在Python中，可以使用type()函数动态地创建类。type()函数的参数分别是类名、基类、类的属性（字典类型）。这种动态创建类的方式，实际上就是使用了元类。</p><p>下面通过示例代码来详细介绍下Python中元类的使用。</p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>        <span class="hljs-comment"># 控制类的创建过程</span><br>        attrs[<span class="hljs-string">&#x27;version&#x27;</span>] = <span class="hljs-string">&#x27;1.0&#x27;</span><br>        attrs[<span class="hljs-string">&#x27;info&#x27;</span>] = <span class="hljs-keyword">lambda</span> self: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;This is a class created by MyMeta&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(metaclass=MyMeta):<br>    <span class="hljs-comment"># 控制类的属性</span><br>    name = <span class="hljs-string">&#x27;MyClass&#x27;</span><br>    age = <span class="hljs-number">18</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, gender</span>):<br>        self.gender = gender<br><br>    <span class="hljs-comment"># 控制类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, I am&#x27;</span>, self.gender)<br><br><span class="hljs-comment"># 控制类的实例化过程</span><br>m = MyClass(<span class="hljs-string">&#x27;male&#x27;</span>)<br>m.say_hello()<br>m.info()<br><span class="hljs-built_in">print</span>(m.version)<br></code></pre></td></tr></table></figure><p>在这段代码中，我们定义了一个名为MyMeta的元类，继承自type类。在元类的<code>__new__()</code>方法中，我们通过修改attrs参数来控制了类的属性和方法，并返回一个新的类对象。</p><p>我们还定义了一个名为MyClass的类，并将元类设置为MyMeta。在MyClass中，我们设置了两个属性（name和age），以及一个方法（say_hello）和一个构造函数。我们还通过实例化一个MyClass对象来演示了元类对类实例化过程的控制。</p><p>通过这个例子，我们可以看到元类的用法和效果。元类是一个高级特性，掌握了元类的用法，可以更加灵活地控制类的创建过程、属性、方法以及实例化过程。在实际开发中，可以根据需要使用元类来实现更加灵活的编程。</p><h2 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h2><p>元类是 Python 中比较高级的概念，它用于控制类的创建。在 Python 中内置的元类是 <code>type</code>，它用于创建类。</p><p>通过自定义元类可以干涉类的创建过程，可以在类创建之前或之后添加、修改、删除属性等操作。自定义元类必须继承于 <code>type</code> 类，并实现 <code>__new__</code> 方法。</p><p><code>__new__</code> 方法用于在创建类时被调用，接收的参数有 <code>cls</code>、<code>name</code>、<code>bases</code>、<code>attrs</code>、<code>*args</code> 和 <code>**kwargs</code>。其中，<code>cls</code> 代表元类本身，<code>name</code> 代表要创建的类的名称，<code>bases</code> 代表要创建的类的父类，<code>attrs</code> 代表要创建的类的属性。</p><p>下面是一个简单的示例代码，演示如何使用自定义元类 <code>MyMateClass</code> 动态创建一个名为 <code>Demo</code> 的类，其中 <code>CaseData</code> 是类的属性之一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMateClass</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name&quot;</span>, name)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;bases&quot;</span>, bases)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;attrs&quot;</span>, attrs)<br>        <span class="hljs-comment"># 调用父类的new方法创建一个类，并返回</span><br>        new_cls = <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs, )<br>        <span class="hljs-keyword">return</span> new_cls<br><br><span class="hljs-comment"># 使用元类动态创建类</span><br>Demo = MyMateClass(<span class="hljs-string">&#x27;Demo&#x27;</span>, (<span class="hljs-built_in">object</span>,), &#123;<span class="hljs-string">&#x27;CaseData&#x27;</span>: [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>]&#125;)<br><span class="hljs-built_in">print</span>(Demo)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个自定义元类 <code>MyMateClass</code>，并在 <code>__new__</code> 方法中打印了类名、父类和属性信息。然后使用 <code>MyMateClass</code> 动态创建了一个名为 <code>Demo</code> 的类，并将 <code>CaseData</code> 设置为该类的一个属性。</p><p>总结一下，元类是一种高级的 Python 概念，可以用于控制类的创建过程。通过自定义元类，我们可以在类创建之前或之后对类进行干涉操作。在自定义元类中，必须实现 <code>__new__</code> 方法，并继承于 <code>type</code> 类。</p><h2 id="class定义类时指定元类"><a href="#class定义类时指定元类" class="headerlink" title="class定义类时指定元类"></a>class定义类时指定元类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义元类：必须要继承type类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMateClass</span>(<span class="hljs-title class_ inherited__">type</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name&quot;</span>, name)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;bases&quot;</span>, bases)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;attrs&quot;</span>, attrs)<br>        <span class="hljs-comment"># 调用父类的new方法创建一个类，并返回</span><br>        new_cls = <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs, )<br>        <span class="hljs-keyword">return</span> new_cls<br><br><br><span class="hljs-comment"># 定义类时，使用指定的元类去创建类(在类名后面的括号中通过metaclass指定元类)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoTest</span>(<span class="hljs-built_in">object</span>, metaclass=MyMateClass):<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(DemoTest))<br></code></pre></td></tr></table></figure><p>在 Python 中，元类是用于创建类的类，也就是说元类是类的类。在 Python 中，内置的元类是 type。当我们使用 class 关键字定义一个类时，实际上是使用了 type 类的一个实例去创建这个类的。</p><p>自定义元类可以干涉类创建的过程，也就是说可以在类创建的过程中做一些自定义的操作。元类必须要继承自 type 类，并且实现 <strong>new</strong> 方法。在 <strong>new</strong> 方法中，可以对类进行一些操作并返回一个新的类。创建类时，可以通过在类名后面的括号中通过 metaclass 参数指定元类。</p><p>示例代码中，自定义了一个元类 MyMateClass，并重写了它的 <strong>new</strong> 方法，在该方法中打印了传入的类名、基类和属性。然后定义了一个类 DemoTest，在类名后面的括号中通过 metaclass 参数指定元类为 MyMateClass。最后通过 type 函数获取 DemoTest 的类型，并输出其类型。</p><p>运行代码，可以看到输出了传入元类 <strong>new</strong> 方法的类名、基类和属性，并且输出了 DemoTest 的类型为 MyMateClass。</p><p>元类是 Python 中高级语法，通常在开发中较少使用。掌握元类有助于理解 Python 类的底层实现。</p><h2 id="通过元类实现DDT这个模块生成用例的公共能"><a href="#通过元类实现DDT这个模块生成用例的公共能" class="headerlink" title="通过元类实现DDT这个模块生成用例的公共能"></a>通过元类实现DDT这个模块生成用例的公共能</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_test_method</span>(<span class="hljs-params">func, params</span>):<br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> func(self, params)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-comment"># 自定义元类：必须要继承type类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMateClass</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs, *args, **kwargs</span>):<br>        new_cls = <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br>        <span class="hljs-comment"># 获取测试类中定义的测试数据</span><br>        <span class="hljs-comment"># 遍历测试数据，动态的给测试类添加用例(test开头的方法)</span><br>        <span class="hljs-keyword">for</span> index, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(attrs[<span class="hljs-string">&#x27;Cases&#x27;</span>]):<br>            <span class="hljs-comment"># 定义一个测试方法名</span><br>            new_func_name = <span class="hljs-string">&#x27;test_&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, index)<br>            <span class="hljs-comment"># 获取测试类中定义的方法</span><br>            method = update_test_method(attrs[<span class="hljs-string">&#x27;porform&#x27;</span>], item)<br>            <span class="hljs-comment"># 动态给测试类添加方法</span><br>            <span class="hljs-built_in">setattr</span>(new_cls, new_func_name, method)<br>        <span class="hljs-keyword">return</span> new_cls<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseTest</span>(unittest.TestCase, metaclass=TestMateClass):<br>    Cases = [<br>        &#123;<span class="hljs-string">&#x27;case_id&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;case_title&#x27;</span>: <span class="hljs-string">&#x27;用例1&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.baudi.com&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;001&#x27;</span>, <span class="hljs-string">&#x27;excepted&#x27;</span>: <span class="hljs-string">&#x27;ok&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;case_id&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;case_title&#x27;</span>: <span class="hljs-string">&#x27;用例4&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.baudi.com&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;002&#x27;</span>, <span class="hljs-string">&#x27;excepted&#x27;</span>: <span class="hljs-string">&#x27;ok&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;case_id&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;case_title&#x27;</span>: <span class="hljs-string">&#x27;用例2&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.baudi.com&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;002&#x27;</span>, <span class="hljs-string">&#x27;excepted&#x27;</span>: <span class="hljs-string">&#x27;ok&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;case_id&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;case_title&#x27;</span>: <span class="hljs-string">&#x27;用例3&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.baudi.com&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;002&#x27;</span>, <span class="hljs-string">&#x27;excepted&#x27;</span>: <span class="hljs-string">&#x27;ok&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;case_id&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;case_title&#x27;</span>: <span class="hljs-string">&#x27;用例5&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.baudi.com&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-string">&#x27;002&#x27;</span>, <span class="hljs-string">&#x27;excepted&#x27;</span>: <span class="hljs-string">&#x27;ok&#x27;</span>&#125;<br>    ]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">porform</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试用例接收到测试数据&quot;</span>, item)<br>        <span class="hljs-comment"># 第一步：处理测试数据</span><br>        self.__handle_data()<br>        <span class="hljs-comment"># 第二步：发送请求</span><br>        self.__request_api()<br>        <span class="hljs-comment"># 第三步：提交接口返回的数据（上下接口有参数依赖的）</span><br>        self.__response_handle()<br>        <span class="hljs-comment"># 第四步：预期结果和实际结果断言</span><br>        self.__assertion()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__handle_data</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__request_api</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__response_handle</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__assertion</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python面向对象编程的三大特征</title>
    <link href="/2020/04/17/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/"/>
    <url>/2020/04/17/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Python面向对象编程的三大特征"><a href="#Python面向对象编程的三大特征" class="headerlink" title="Python面向对象编程的三大特征"></a>Python面向对象编程的三大特征</h1><p>Python是一种面向对象的编程语言，它支持面向对象的编程范式，拥有面向对象编程的三大特征：封装、继承和多态。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是指将数据和行为组合在一个类中，并对外部使用者隐藏其内部实现的细节。数据封装可以通过类的属性和方法来实现，可以将数据的可见性限制在类的内部，外部用户无法访问类的内部数据。这可以帮助保护数据的完整性和安全性，并且使得代码更易于维护。</p><p>以下是一个简单的封装示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.name<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.age<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_name</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>):<br>        self.age = age<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个类<code>MyClass</code>，该类有<code>name</code>和<code>age</code>属性，同时有获取和设置属性的方法。这里，我们将数据封装在类中，并对外部使用者隐藏其内部实现细节。外部用户只能通过类的公共接口来访问和修改数据，这样可以保证数据的安全性。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是指通过一个已有的类来派生出一个新的类，新的类具有已有类的所有属性和方法，并可以添加新的属性和方法。继承可以帮助我们实现代码的复用和扩展，同时也使得代码更加简洁易读。</p><p>以下是一个简单的继承示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello, my name is <span class="hljs-subst">&#123;self.name&#125;</span> and I&#x27;m <span class="hljs-subst">&#123;self.age&#125;</span> years old.&quot;</span>)<br>        <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, grade</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name, age)<br>        self.grade = grade<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">study</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> is studying in grade <span class="hljs-subst">&#123;self.grade&#125;</span>.&quot;</span>)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个父类<code>Person</code>和一个子类<code>Student</code>。<code>Person</code>类有<code>name</code>和<code>age</code>属性，并有一个<code>say_hello</code>方法，用于打招呼。<code>Student</code>类继承了<code>Person</code>类，并添加了一个<code>grade</code>属性和一个<code>study</code>方法。我们可以看到，在<code>Student</code>类中，我们使用<code>super().__init__(name, age)</code>来调用父类的构造方法，并且在子类中添加了新的属性和方法。这样，我们就可以复用<code>Person</code>类的属性和方法，并且可以根据需要扩展代码。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指不同对象对同一消息做出不同的响应，也就是说，同一种方法可以有不同的表现形式，这个特性可以使代码更加灵活。多态有两种表现形式：重载和重写。</p><p>重载（overloading）是指在一个类中定义多个同名的方法，它们具有不同的参数个数、类型或者顺序，但是它们的方法名相同。Python不支持方法重载，因为Python中的方法是以方法名为索引的字典。</p><p>重写（overriding）是指在子类中定义与父类中同名的方法，这样子类对象就可以使用子类自己的方法了。Python中方法的重写使用和继承一样的方式实现。</p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多态示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">&quot;汪汪汪&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sound</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">&quot;喵喵喵&quot;</span>)<br><br><span class="hljs-comment"># 测试</span><br>animals = [Dog(<span class="hljs-string">&quot;旺财&quot;</span>), Cat(<span class="hljs-string">&quot;小黑&quot;</span>)]<br><span class="hljs-keyword">for</span> animal <span class="hljs-keyword">in</span> animals:<br>    animal.sound()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python属性管理和多态</title>
    <link href="/2020/04/12/Python%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <url>/2020/04/12/Python%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E5%92%8C%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Python属性管理和多态"><a href="#Python属性管理和多态" class="headerlink" title="Python属性管理和多态"></a>Python属性管理和多态</h1><h2 id="1-私有属性和属性字典"><a href="#1-私有属性和属性字典" class="headerlink" title="1.私有属性和属性字典"></a>1.私有属性和属性字典</h2><h3 id="1-1私有属性"><a href="#1-1私有属性" class="headerlink" title="1.1私有属性"></a>1.1私有属性</h3><p>Python中，私有属性指的是在类定义中以双下划线（“__”）开头的属性，这样的属性在类外部不能直接访问。Python并没有真正的私有属性，实际上它是通过一种名为“name mangling”的机制来实现的，即将属性名进行修改，以避免被意外访问。</p><p>当Python解释器遇到类定义中的以双下划线开头的属性时，会自动将属性名进行修改，使其变成“_classname__attribute”的形式。例如，在类定义中定义了一个私有属性“__private”，它的实际名称将变为“_classname__private”。这样，我们就可以在类的方法中访问这个属性，但在类外部无法直接访问。</p><p>下面是一个示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.__age = age<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_age</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__age<br><br>p = Person(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">25</span>)<br><span class="hljs-built_in">print</span>(p.name)   <span class="hljs-comment"># Output: Alice</span><br><span class="hljs-built_in">print</span>(p.get_age())   <span class="hljs-comment"># Output: 25</span><br><span class="hljs-built_in">print</span>(p.__age)   <span class="hljs-comment"># Output: AttributeError: &#x27;Person&#x27; object has no attribute &#x27;__age&#x27;</span><br><span class="hljs-built_in">print</span>(p._Person__age)   <span class="hljs-comment"># Output: 25</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个Person类，其中定义了一个私有属性“__age”。在类的构造函数中，我们初始化了这个属性。我们还定义了一个名为“get_age”的方法，它可以返回私有属性“__age”的值。</p><p>在主程序中，我们创建了一个Person类的实例p，并尝试访问它的“name”和“__age”属性。由于“name”属性不是私有属性，因此我们可以直接访问它。但是，由于“__age”是私有属性，我们不能直接访问它。如果我们尝试这样做，Python会引发AttributeError异常。但是，我们可以使用“_Person__age”这样的名称来访问它。</p><p>需要注意的是，尽管我们可以通过这种方式访问私有属性，但是这并不是Python语言官方建议的做法。在Python中，一般情况下应该尽量避免访问私有属性，而是通过公共接口访问属性值，这样可以使代码更加健壮和易于维护。</p><h3 id="1-2-属性字典"><a href="#1-2-属性字典" class="headerlink" title="1.2 属性字典"></a>1.2 属性字典</h3><p>在Python中，每个对象都有一个字典，记录了它的属性和对应的值。这个字典被称为属性字典（<code>__dict__</code>），可以通过它来获取对象的属性。</p><p>对于类来说，类的属性字典记录了类定义中的所有属性，包括类变量和方法。对于对象来说，属性字典记录了对象实例中定义的所有属性，包括实例变量和方法。属性字典是一个键值对的集合，键是属性名，值是属性值。</p><p>在Python中，私有属性是指以双下划线开头但不以双下划线结尾的属性。Python中的私有属性并不是真正的私有，它们只是在属性名前面添加了一个下划线，告诉其他程序员这个属性不应该被直接访问。但是，Python中的属性字典可以访问到这些私有属性。</p><p>下面是一个示例代码，演示如何使用属性字典获取类和对象的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    __private_attribute = <span class="hljs-string">&#x27;private&#x27;</span><br>    public_attribute = <span class="hljs-string">&#x27;public&#x27;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.instance_attribute = <span class="hljs-string">&#x27;instance&#x27;</span><br>        <br>m = MyClass()<br><span class="hljs-built_in">print</span>(MyClass.__dict__)  <span class="hljs-comment"># 获取类的属性字典</span><br><span class="hljs-comment"># 输出：&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;_MyClass__private_attribute&#x27;: &#x27;private&#x27;, </span><br><span class="hljs-comment">#        &#x27;public_attribute&#x27;: &#x27;public&#x27;, &#x27;__init__&#x27;: &lt;function MyClass.__init__ at 0x7f9df32d4a60&gt;, </span><br><span class="hljs-comment">#        &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;MyClass&#x27; objects&gt;, &#x27;__weakref__&#x27;: </span><br><span class="hljs-comment">#        &lt;attribute &#x27;__weakref__&#x27; of &#x27;MyClass&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span><br><br><span class="hljs-built_in">print</span>(m.__dict__)  <span class="hljs-comment"># 获取对象的属性字典</span><br><span class="hljs-comment"># 输出：&#123;&#x27;instance_attribute&#x27;: &#x27;instance&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>从输出结果可以看出，属性字典中包含了类的所有属性，包括私有属性。同时，属性字典也可以用于获取对象实例中定义的属性。</p><h2 id="2-限制类创建对象的实例属性"><a href="#2-限制类创建对象的实例属性" class="headerlink" title="2.限制类创建对象的实例属性"></a>2.限制类创建对象的实例属性</h2><p>Python中的__slots__属性可以用于限制对象的属性，使对象只能添加在__slots__列表中声明过的实例属性。它的作用主要有两个：</p><ol><li>阻止给对象创建属性字典__dict__，从而节省内存。</li><li>限制对象的属性，避免程序员在不经意间给对象添加新的属性，从而增强程序的安全性和可维护性。</li></ol><p>在使用__slots__时，可以将它声明在类中，其值是一个包含字符串的列表，每个字符串代表一个属性名。在类的实例化过程中，只能为类中__slots__列表中声明的属性名赋值，否则会报AttributeError错误。下面是一个简单的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    __slots__ = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass2</span>:<br>    __slots__ = []<br><br>m = MyClass(<span class="hljs-string">&#x27;musen&#x27;</span>, <span class="hljs-number">18</span>)<br>m2 = MyClass(<span class="hljs-string">&#x27;musen1&#x27;</span>, <span class="hljs-number">118</span>)<br>mm = MyClass2()<br></code></pre></td></tr></table></figure><p>在这个例子中，类<code>MyClass</code>中声明了<code>__slots__</code>属性，包含了两个属性名<code>name</code>和<code>age</code>。类<code>MyClass2</code>中声明了一个空的<code>__slots__</code>属性。在实例化<code>MyClass</code>时，只能为<code>name</code>和<code>age</code>属性赋值。而在实例化<code>MyClass2</code>时，则不受任何限制。</p><p>需要注意的是，<code>__slots__</code>属性只对当前类有效，不会影响父类或子类。另外，使用<code>__slots__</code>可能会对代码的扩展性和维护性带来一些影响，因为类的属性必须在<code>__slots__</code>中声明，所以如果需要添加新的属性，需要修改类的定义。</p><h2 id="3-python中属性访问机制"><a href="#3-python中属性访问机制" class="headerlink" title="3.python中属性访问机制"></a>3.python中属性访问机制</h2><ol><li>Python 中有四个魔术方法与对象的属性相关，分别是 <strong>getattribute</strong>、<strong>setattr</strong>、<strong>delattr</strong> 和 <strong>getattr</strong>；<br>getattribute、setattr、delattr 和 getattr；</li><li><strong>getattribute</strong> 方法在对象访问属性时触发，它能够返回属性的值；</li><li><strong>setattr</strong> 方法在对象设置属性时触发，它能够设置属性的值；</li><li><strong>delattr</strong> 方法在删除对象属性时触发，它能够删除属性；</li><li><strong>getattr</strong> 方法在对象获取不存在的属性时触发，它能够处理不存在的属性。</li></ol><p>以上这些魔术方法都可以重写，以实现对对象属性的特定操作。例如，在 <strong>setattr</strong> 方法中，可以对设置的属性值进行检查和过滤。</p><p>代码中的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        对象访问属性触发的魔术方法</span><br><span class="hljs-string">        :param item: 属性名</span><br><span class="hljs-string">        :return: 属性值</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__getattribute__(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        对象设置属性触发的魔术方法</span><br><span class="hljs-string">        :param key: 属性名</span><br><span class="hljs-string">        :param value: 属性值</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-built_in">super</span>().__setattr__(key, value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        删除对象属性触发的魔术方法</span><br><span class="hljs-string">        :param item: 要删除的属性名</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-built_in">super</span>().__delattr__(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        对象获取属性，属性不存在时触发的魔术方法</span><br><span class="hljs-string">        :param item:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span><br><br>m = MyTest(<span class="hljs-string">&#x27;musen&#x27;</span>, <span class="hljs-number">18</span>)<br><br><span class="hljs-comment"># 动态设置属性</span><br><span class="hljs-built_in">setattr</span>(m, <span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-number">100</span>)<br><span class="hljs-built_in">setattr</span>(m, <span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-number">200</span>)<br><span class="hljs-built_in">print</span>(m.__dict__)<br><br><span class="hljs-comment"># 访问属性</span><br><span class="hljs-built_in">print</span>(m.name)  <span class="hljs-comment"># m.name  ===&gt; m.__getattribute__(&#x27;name&#x27;)</span><br><br><span class="hljs-comment"># 删除属性</span><br><span class="hljs-keyword">del</span> m.name<br><span class="hljs-built_in">print</span>(m.__dict__)<br><br><span class="hljs-comment"># 获取不存在的属性</span><br><span class="hljs-built_in">print</span>(m.py)<br></code></pre></td></tr></table></figure><h2 id="4-属性管理的案例"><a href="#4-属性管理的案例" class="headerlink" title="4.属性管理的案例"></a>4.属性管理的案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDemo</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> key == <span class="hljs-string">&#x27;id&#x27;</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">and</span> value &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">super</span>().__setattr__(key, value)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">&#x27;id属性只能设置为int类型，并且值大于0&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-string">&#x27;datas&#x27;</span>:<br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-string">&#x27;name&#x27;</span>:<br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">super</span>().__setattr__(key, value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">or</span> item == <span class="hljs-string">&#x27;datas&#x27;</span>:<br>            <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">&#x27;属性&#123;&#125;不能删除&#x27;</span>.<span class="hljs-built_in">format</span>(item))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">super</span>().__delattr__(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;name&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;新用例&#x27;</span><br>        <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">&#x27;对象没有&#123;&#125;属性&#x27;</span>.<span class="hljs-built_in">format</span>(item))<br><br><br>m2 = MyDemo()<br><br>m2.<span class="hljs-built_in">id</span> = <span class="hljs-number">999</span><br>m2.datas = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><br><span class="hljs-built_in">print</span>(m2.__dict__)<br><span class="hljs-built_in">print</span>(m2.name)<br></code></pre></td></tr></table></figure><p>在Python中，我们可以使用__setattr__、__getattr__和__delattr__魔术方法来自定义类的属性设置、获取和删除操作。</p><p>在上面的代码中，我们定义了一个MyDemo类，该类具有id、datas和name三个属性。在__setattr__方法中，我们对id属性的值进行了类型和值范围的限制，并且对datas和name属性不做限制。对于其他属性，我们调用了父类的__setattr__方法进行默认处理。</p><p>在__delattr__方法中，我们限制了对id和datas属性的删除，并对其他属性调用了父类的__delattr__方法。</p><p>在__getattr__方法中，如果获取的是name属性并且该属性没有值，则返回’新用例’，否则抛出AttributeError异常。</p><p>总之，使用这些魔术方法，我们可以对类的属性进行更加精细的控制，从而确保数据的完整性和安全性</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入了解Python中的魔术方法</title>
    <link href="/2020/04/05/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
    <url>/2020/04/05/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="深入了解Python中的魔术方法"><a href="#深入了解Python中的魔术方法" class="headerlink" title="深入了解Python中的魔术方法"></a>深入了解Python中的魔术方法</h1><h2 id="1-魔术方法介绍"><a href="#1-魔术方法介绍" class="headerlink" title="1.魔术方法介绍"></a>1.魔术方法介绍</h2><p>在Python中，魔术方法（Magic Methods），也称为双下划线方法（dunder methods），是一种特殊的方法，用于在类定义中实现特殊的行为。这些方法的名称都以两个下划线（__）开头和结尾，比如 <code>__init__</code>、<code>__str__</code>、<code>__repr__</code> 等等。</p><p>Python的魔术方法可以实现类似于操作符重载、属性访问控制、对象创建与销毁等特殊功能，以及一些高级编程技巧，比如上下文管理器、迭代器等。</p><p>当我们在类中定义了某个魔术方法时，Python会在特定的时机自动调用该方法，从而实现预期的功能。例如，在创建对象时，Python会自动调用 <code>__init__</code> 方法来初始化对象；在使用 <code>print</code> 函数打印对象时，Python会自动调用 <code>__str__</code> 方法来返回字符串表示。</p><p>总之，Python的魔术方法是一种非常强大的功能，可以大大增强类的灵活性和可定制性，也是 Python 面向对象编程的重要基础</p><h2 id="2-new方法"><a href="#2-new方法" class="headerlink" title="2.new方法"></a>2.new方法</h2><p>Python 中，每个类都有一个名为 <strong>new</strong> 的特殊方法。在创建一个新的实例时，<strong>new</strong> 方法会被首先调用，用于创建并返回实例对象。然后，<strong>init</strong> 方法会被调用，用于对新创建的对象进行初始化。在这篇博客中，我们将详细介绍 <strong>new</strong> 方法的使用。</p><h3 id="什么是-new-方法？"><a href="#什么是-new-方法？" class="headerlink" title="什么是 new 方法？"></a>什么是 <strong>new</strong> 方法？</h3><p><strong>new</strong> 方法是 Python 中的一个特殊方法，用于创建类的实例对象。与常规的实例方法不同，<strong>new</strong> 方法是一个类方法，因此应该接收类作为第一个参数。</p><p><strong>new</strong> 方法通常被用于一下几种情况：</p><ul><li>控制实例的创建过程</li><li>返回已有对象的引用</li><li>子类化不可变类型</li></ul><h3 id="如何使用-new-方法"><a href="#如何使用-new-方法" class="headerlink" title="如何使用 new 方法"></a>如何使用 <strong>new</strong> 方法</h3><p><strong>new</strong> 方法必须返回一个实例对象。如果 <strong>new</strong> 方法返回的是其他类型的对象，那么该方法会被忽略，直接调用 <strong>init</strong> 方法进行初始化。如果 <strong>new</strong> 方法返回的是类的实例对象，那么该对象会被传递给 <strong>init</strong> 方法进行初始化。</p><p>下面是一个简单的例子，演示如何在 <strong>new</strong> 方法中创建实例对象：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby">pythonCopy code<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        instance = <span class="hljs-variable language_">super</span>().__new__(cls)<br>        instance.value = args[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> instance<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>obj = <span class="hljs-title class_">MyClass</span>(<span class="hljs-number">123</span>)<br>print(obj.value)  <span class="hljs-comment"># 123</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们重写了 <strong>new</strong> 方法，在创建新的实例对象时，将传入的参数 value 赋值给实例对象的属性。然后，在 <strong>init</strong> 方法中，我们再次将 value 赋值给实例对象的属性。最终，实例对象的 value 属性的值应该是 123。</p><h3 id="new-方法与-init-方法的区别"><a href="#new-方法与-init-方法的区别" class="headerlink" title="new 方法与 init 方法的区别"></a><strong>new</strong> 方法与 <strong>init</strong> 方法的区别</h3><p>Python 中每个类都有两个特殊的方法：<strong>new</strong> 和 <strong>init</strong>。这两个方法都是用于创建类的实例对象。但是，它们在实现细节和用途上有所不同。</p><p><strong>new</strong> 方法是一个类方法，用于创建并返回实例对象。它的主要作用是控制实例对象的创建过程。通常情况下，我们不需要自己实现 <strong>new</strong> 方法，因为 Python 提供的默认实现已经足够满足大多数需求。</p><p><strong>init</strong> 方法是一个实例方法，用于对新创建的对象进行初始化。它的主要作用是设置实例对象的属性。通常情况下，我们需要重写 <strong>init</strong> 方法，以便在对象创建时初始化一些属性。</p><h2 id="3-new方法的使用场景和单例模式"><a href="#3-new方法的使用场景和单例模式" class="headerlink" title="3.new方法的使用场景和单例模式"></a>3.new方法的使用场景和单例模式</h2><p>在Python中，<code>__new__</code>方法是一个特殊的方法，用于创建类的新实例。它在<code>__init__</code>方法之前被调用，用于创建对象并返回该对象的实例。<code>__new__</code>方法通常用于控制对象的创建过程，比如单例模式，对象池等场景。</p><p>单例模式是一种常用的设计模式，它确保类只有一个实例，并提供了对该实例的全局访问点。在Python中，可以使用<code>__new__</code>方法来实现单例模式。具体做法是，在<code>__new__</code>方法中，判断类是否已经创建过实例对象，如果没有，创建一个新的实例对象，并把该实例对象保存在类属性中，以后再创建对象时，直接返回保存的实例对象即可。</p><p>以下是使用<code>__new__</code>方法实现单例模式的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __instance = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls.__instance:<br>            cls.__instance = <span class="hljs-built_in">super</span>().__new__(cls, *args, **kwargs)<br>        <span class="hljs-keyword">return</span> cls.__instance<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Singleton</code>类只有一个实例对象。当第一次调用<code>Singleton()</code>时，<code>__new__</code>方法被调用，创建一个新的实例对象，并将它保存在类属性<code>__instance</code>中。以后再调用<code>Singleton()</code>时，直接返回保存的实例对象即可。</p><p>总结一下，<code>__new__</code>方法是Python中一个非常重要的特殊方法，用于创建类的新实例。它可以用于控制对象的创建过程，例如实现单例模式，对象池等场景。</p><p>4.call方法<br><code>__call__</code> 方法是 Python 中的一个魔术方法，用于让实例对象能够像函数一样被调用。如果一个类实现了 <code>__call__</code> 方法，那么这个类的实例对象可以被当做函数来使用，通过在对象后面加括号的方式调用，就会自动触发 <code>__call__</code> 方法。</p><p>下面是 <code>__call__</code> 方法的代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCreateFunction</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----call方法执行了----&quot;</span>)<br><br><br>musen = MyCreateFunction()<br>musen()<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个 <code>MyCreateFunction</code> 类，然后在这个类中实现了 <code>__call__</code> 方法，当 <code>musen()</code> 被调用时，实际上是触发了 <code>musen</code> 实例对象的 <code>__call__</code> 方法，于是我们就可以在 <code>__call__</code> 方法中实现任何我们希望对象被调用时执行的逻辑。注意，在这里我们使用 <code>callable()</code> 函数检查了函数和对象是否可调用。</p><p>总的来说，<code>__call__</code> 方法可以让我们把一个类的实例对象像函数一样使用，这对于一些特定的场景（如函数装饰器）非常有用。</p><h2 id="4-call方法应用的类实现装饰器"><a href="#4-call方法应用的类实现装饰器" class="headerlink" title="4.call方法应用的类实现装饰器"></a>4.call方法应用的类实现装饰器</h2><p>当我们想要在函数执行前后添加一些额外的功能，或者对函数进行修改时，我们通常会使用装饰器。装饰器是一种函数或类，它可以接受一个函数作为参数，并返回一个新的函数或类，新的函数或类具有扩展的功能或者对原函数进行修改。</p><p>类装饰器是一种使用类来实现装饰器的方法。类装饰器使用了类的 <strong>call</strong> 方法。当我们将一个类作为装饰器时，Python 会自动调用这个类的 <strong>call</strong> 方法。这个方法将被用来装饰一个函数，然后返回一个新的函数。这个新的函数将会替换原来的函数。</p><p>下面，我们将会展示两个使用类装饰器的例子，一个是用来实现装饰器的类的例子，另一个是用来实现数据驱动测试的例子。</p><h4 id="示例1：装饰器类的使用"><a href="#示例1：装饰器类的使用" class="headerlink" title="示例1：装饰器类的使用"></a>示例1：装饰器类的使用</h4><p>我们可以定义一个类，将需要装饰的函数作为参数传递给这个类，然后在这个类的 <strong>call</strong> 方法中添加额外的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---装饰器扩展的功能代码1---&quot;</span>)<br>        res = self.func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---装饰器扩展的功能代码2---&quot;</span>)<br>        <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-meta">@Decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----功能函数work--------&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">9999</span><br><br><br>res = work()<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个类 Decorator，它接收一个函数作为参数，然后在 <strong>call</strong> 方法中添加了额外的功能。我们将这个类应用到函数 work 上，使用 @Decorator 装饰器来实现。当我们调用 work() 函数时，它将会先执行 <strong>call</strong> 方法中的代码，然后再执行原函数。</p><h4 id="示例2：数据驱动测试的实现"><a href="#示例2：数据驱动测试的实现" class="headerlink" title="示例2：数据驱动测试的实现"></a>示例2：数据驱动测试的实现</h4><p>我们可以定义一个类，将需要装饰的函数作为参数传递给这个类，然后在这个类的 <strong>call</strong> 方法中添加数据驱动测试的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args</span>):<br>        self.data = args<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, func, *args, **kwargs</span>):<br>        func.DATA = self.data<br>        <span class="hljs-keyword">return</span> func<br><br><br><span class="hljs-meta">@Data(<span class="hljs-params"><span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----功能函数work--------&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">9999</span><br><br><br><span class="hljs-built_in">print</span>(work.DATA)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个类 Data，它接收一个数据列表作为参数，然后在 <strong>call</strong> 方法中将这个数据列表附加到函数对象上。我们将这个类应用到函数 work 上，使用 @Data 装饰器来实现。当我们调用 work() 函数时，它将会输出数据列表。</p><h2 id="5-上下文管理器协议"><a href="#5-上下文管理器协议" class="headerlink" title="5.上下文管理器协议"></a>5.上下文管理器协议</h2><p>Python的上下文管理协议(Context Management Protocol)是一种用于在资源分配和释放时，自动执行特定代码的协议。在Python中，上下文管理器（Context Manager）是一个对象，它定义了在进入和退出代码块时要执行的操作。上下文管理器可以使用Python的with语句来使用，以确保资源被正确分配和释放。在with语句块结束时，Python会自动调用上下文管理器的__exit__方法。</p><p>上下文管理器必须实现__enter__和__exit__两个方法。__enter__方法在进入with语句块时调用，并返回一个可供使用的对象，__exit__方法在with语句块执行结束后自动调用，用于释放资源。</p><p>以下是一个使用上下文管理器的简单示例，实现了打开和关闭文件的自动化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenFile</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, file_name, mode</span>):<br>        self.file_name = file_name<br>        self.mode = mode<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        self.file = <span class="hljs-built_in">open</span>(self.file_name, self.mode)<br>        <span class="hljs-keyword">return</span> self.file<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):<br>        self.file.close()<br><br><br><span class="hljs-keyword">with</span> OpenFile(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，OpenFile是一个上下文管理器，__enter__方法打开文件并返回一个文件对象，__exit__方法关闭文件。</p><p>使用with语句调用OpenFile时，会执行以下操作：</p><ol><li>调用OpenFile的__enter__方法，打开文件并返回文件对象。</li><li>with语句块中使用文件对象写入数据。</li><li>with语句块执行完毕后，调用OpenFile的__exit__方法，关闭文件。</li></ol><p>如果在with语句块中发生异常，Python会自动调用__exit__方法，用于释放资源。</p><p>上下文管理器可以大大简化资源管理的过程，特别是在使用文件、网络连接等需要手动释放的资源时。使用with语句管理资源时，可以避免遗漏释放资源的情况，也可以提高代码的可读性和可维护性。</p><p>除了自定义上下文管理器外，Python还提供了一些内置的上下文管理器，比如在文件操作时使用的open函数，使用with语句块自动关闭文件。另外，Python的标准库中还有一些模块，如contextlib和threading等，提供了许多有用的上下文管理器。</p><p>6.str方法魔术方法 <code>__str__</code> 是一个用于自定义对象在转换为字符串时的输出形式的方法。在使用 <code>print</code> 函数或是将对象转换为字符串时，Python 解释器会自动调用该方法并将其返回值作为字符串输出。</p><p>以下是一个示例代码，其中定义了一个 <code>Person</code> 类，并在其 <code>__str__</code> 方法中自定义了输出的字符串形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Person(name=<span class="hljs-subst">&#123;self.name&#125;</span>, age=<span class="hljs-subst">&#123;self.age&#125;</span>)&quot;</span><br><br><br>p = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>)<br><span class="hljs-built_in">print</span>(p)  <span class="hljs-comment"># 输出：Person(name=Alice, age=30)</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>__str__</code> 方法中返回了一个格式化字符串，其中包含了该对象的两个属性 <code>name</code> 和 <code>age</code>。在调用 <code>print</code> 函数时，Python 解释器会自动调用 <code>p</code> 对象的 <code>__str__</code> 方法并将其返回值输出。</p><p>需要注意的是，<code>__str__</code> 方法返回的字符串应该尽量简洁清晰，并且不应包含任何详细的实现细节，因为它的主要作用是为了方便开发者调试和输出信息。</p><p>另外，如果一个对象同时定义了 <code>__str__</code> 和 <code>__repr__</code> 方法，那么在使用 <code>print</code> 函数时将会调用 <code>__str__</code> 方法，而在使用 <code>repr</code> 函数时将会调用 <code>__repr__</code> 方法。</p><h2 id="6-运算符对应的魔术方法"><a href="#6-运算符对应的魔术方法" class="headerlink" title="6.运算符对应的魔术方法"></a>6.运算符对应的魔术方法</h2><p>在 Python 中，运算符都有对应的魔术方法（Magic Methods），这些方法以双下划线 __ 开头和结尾。这些方法可以用于自定义对象的行为，使其支持各种运算符操作。</p><p>以下是常用运算符和对应的魔术方法：</p><ul><li>算术运算符：<ul><li>加法 (+)：<strong>add</strong></li><li>减法 (-)：<strong>sub</strong></li><li>乘法 (<em>)：*<em>mul</em></em></li><li>除法 (&#x2F;)：<strong>truediv</strong></li><li>取整除 (&#x2F;&#x2F;)：<strong>floordiv</strong></li><li>模运算 (%)：<strong>mod</strong></li><li>幂运算 (**): <strong>pow</strong></li></ul></li><li>比较运算符：<ul><li>等于 (&#x3D;&#x3D;)：<strong>eq</strong></li><li>不等于 (!&#x3D;)：<strong>ne</strong></li><li>大于 (&gt;)：<strong>gt</strong></li><li>小于 (&lt;)：<strong>lt</strong></li><li>大于等于 (&gt;&#x3D;)：<strong>ge</strong></li><li>小于等于 (&lt;&#x3D;)：<strong>le</strong></li></ul></li><li>位运算符：<ul><li>按位与 (&amp;)：<strong>and</strong></li><li>按位或 (|)：<strong>or</strong></li><li>按位异或 (^)：<strong>xor</strong></li><li>按位取反 (~)：<strong>invert</strong></li><li>左移 (&lt;&lt;)：<strong>lshift</strong></li><li>右移 (&gt;&gt;)：<strong>rshift</strong></li></ul></li><li>布尔运算符：<ul><li>与 (and)：<strong>and</strong></li><li>或 (or)：<strong>or</strong></li><li>非 (not)：<strong>not</strong></li></ul></li></ul><p>以下是一些示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个自定义的向量类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x<br>        self.y = y<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.x + other.x, self.y + other.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__sub__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.x - other.x, self.y - other.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self, scalar</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.x * scalar, self.y * scalar)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.x == other.x <span class="hljs-keyword">and</span> self.y == other.y<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;(<span class="hljs-subst">&#123;self.x&#125;</span>, <span class="hljs-subst">&#123;self.y&#125;</span>)&quot;</span><br><br><span class="hljs-comment"># 测试向量类的运算符方法</span><br>v1 = Vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>v2 = Vector(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>v3 = v1 + v2<br>v4 = v2 - v1<br>v5 = v1 * <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(v3)  <span class="hljs-comment"># 输出 (4, 6)</span><br><span class="hljs-built_in">print</span>(v4)  <span class="hljs-comment"># 输出 (2, 2)</span><br><span class="hljs-built_in">print</span>(v5)  <span class="hljs-comment"># 输出 (2, 4)</span><br><span class="hljs-built_in">print</span>(v1 == Vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 输出 True</span><br><span class="hljs-built_in">print</span>(v1 == Vector(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 输出 False</span><br></code></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个自定义的向量类 Vector，实现了加法、减法、乘法、相等和字符串表示等运算符的魔术方法。这些方法使得我们可以像使用内置类型一样使用自定义对象，实现了更自然的语法和行为。</p><p>7.容器相关的魔术方法</p><p>Python中的容器是指可以包含其他对象的对象，例如列表、元组、集合和字典等。这些容器可以使用一些特殊的魔术方法来实现其行为。下面我们将介绍一些与容器相关的魔术方法以及它们的作用。</p><ol><li><code>__len__(self)</code>: 返回容器中元素的数量。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items)<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_list))  <span class="hljs-comment"># 输出：4</span><br></code></pre></td></tr></table></figure><ol><li><code>__getitem__(self, index)</code>: 获取容器中指定位置的元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-keyword">return</span> self.items[index]<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(my_list[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 输出：1</span><br></code></pre></td></tr></table></figure><ol><li><code>__setitem__(self, index, value)</code>: 设置容器中指定位置的元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, index, value</span>):<br>        self.items[index] = value<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>my_list[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(my_list[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 输出：5</span><br></code></pre></td></tr></table></figure><ol><li><code>__delitem__(self, index)</code>: 删除容器中指定位置的元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-keyword">del</span> self.items[index]<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-keyword">del</span> my_list[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(my_list[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 输出：2</span><br></code></pre></td></tr></table></figure><ol><li><code>__contains__(self, item)</code>: 判断容器中是否包含指定元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> item <span class="hljs-keyword">in</span> self.items<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> my_list)  <span class="hljs-comment"># 输出：True</span><br></code></pre></td></tr></table></figure><ol><li><code>__iter__(self)</code>: 返回一个迭代器对象。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self.items)<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(item)  <span class="hljs-comment"># 输出：1 2 3 4</span><br></code></pre></td></tr></table></figure><ol><li><code>__reversed__(self)</code>: 返回一个反向迭代器对象。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        self.items = items<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reversed__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reversed</span>(self.items)<br><br>my_list = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(my_list):<br>    <span class="hljs-built_in">print</span>(item)  <span class="hljs-comment"># 输出：4 3 2 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python类属性的动态管理</title>
    <link href="/2020/03/31/Python%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <url>/2020/03/31/Python%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Python类属性的动态管理"><a href="#Python类属性的动态管理" class="headerlink" title="Python类属性的动态管理"></a>Python类属性的动态管理</h1><p>Python 是一门支持动态语言特性的语言，其中类属性动态管理是其中的一种。Python 允许在运行时对类和对象的属性进行动态的增加、删除和修改，这样可以增强代码的灵活性，使程序可以更好地适应不同的需求。</p><p>在 Python 中，动态管理类属性的方法包括：<code>delattr()</code>、<code>getattr()</code>、<code>hasattr()</code> 和 <code>setattr()</code>。</p><p><code>delattr()</code> 方法可以删除类的某个属性。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">delattr</span>(MyClass, <span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-comment"># 删除 MyClass 类的属性 a</span><br></code></pre></td></tr></table></figure><p><code>getattr()</code> 方法可以获取类的某个属性。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">attr = <span class="hljs-built_in">getattr</span>(MyClass, <span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-comment"># 获取 MyClass 类的属性 a</span><br></code></pre></td></tr></table></figure><p><code>hasattr()</code> 方法可以判断类是否有某个属性。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;a&#x27;</span>):  <span class="hljs-comment"># 判断 MyClass 类是否有属性 a</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MyClass has attribute a&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>setattr()</code> 方法可以动态地为类添加属性。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">setattr</span>(MyClass, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">300</span>)  <span class="hljs-comment"># 为 MyClass 类添加属性 c</span><br></code></pre></td></tr></table></figure><p>除了对类属性进行动态管理，我们还可以对类的方法进行动态管理。方法也是类的属性，只不过是可调用的属性。例如，我们可以在运行时为一个类添加一个方法，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">setattr</span>(MyClass, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-keyword">lambda</span> self: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>))<br></code></pre></td></tr></table></figure><p>然后我们可以在对象上调用这个新添加的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = MyClass()<br>obj.test()  <span class="hljs-comment"># 输出 &quot;Hello, world!&quot;</span><br></code></pre></td></tr></table></figure><p>类属性的动态管理使得 Python 代码具有了更高的灵活性，可以更好地适应各种需求。但是，这种灵活性也容易导致代码的可读性和可维护性下降，因此在使用时需要慎重考虑。</p><p>四、setattr()方法</p><p><code>setattr()</code>方法用于给类添加属性或方法，其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">setattr</span>(<span class="hljs-built_in">object</span>, name, value)<br></code></pre></td></tr></table></figure><ul><li>object：必选参数，表示要添加属性或方法的类。</li><li>name：必选参数，表示要添加的属性或方法名。 姓名：</li><li>value：必选参数，表示要添加的属性或方法值。 价值：</li></ul><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 给类动态添加属性</span><br><span class="hljs-built_in">setattr</span>(MyClass, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>)<br><span class="hljs-built_in">setattr</span>(MyClass, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 给类动态添加方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br><span class="hljs-built_in">setattr</span>(MyClass, <span class="hljs-string">&#x27;say_hello&#x27;</span>, func)<br><br><span class="hljs-comment"># 测试</span><br>m = MyClass()<br><span class="hljs-built_in">print</span>(m.name, m.age)  <span class="hljs-comment"># 输出 &#x27;Tom 20&#x27;</span><br>m.say_hello()  <span class="hljs-comment"># 输出 &#x27;hello world&#x27;</span><br></code></pre></td></tr></table></figure><p>五、delattr()方法</p><p><code>delattr()</code>方法用于删除类的属性或方法，其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">delattr</span>(<span class="hljs-built_in">object</span>, name)<br></code></pre></td></tr></table></figure><ul><li>object：必选参数，表示要删除属性或方法的类。 对象：必</li><li>name：必选参数，表示要删除的属性或方法名。 姓名：</li></ul><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除类属性</span><br><span class="hljs-built_in">delattr</span>(MyClass, <span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-built_in">print</span>(MyClass.__dict__)<br><br><span class="hljs-comment"># 删除类方法</span><br><span class="hljs-built_in">delattr</span>(MyClass, <span class="hljs-string">&#x27;demo&#x27;</span>)<br><span class="hljs-built_in">print</span>(MyClass.__dict__)<br></code></pre></td></tr></table></figure><p>六、hasattr()方法</p><p><code>hasattr()</code>方法用于判断类是否拥有某个属性或方法，其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">hasattr</span>(<span class="hljs-built_in">object</span>, name)<br></code></pre></td></tr></table></figure><ul><li>object：必选参数，表示要检查属性或方法的类。 目的：</li><li>name：必选参数，表示要检查的属性或方法名。 姓名：必</li></ul><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 判断类是否拥有某个属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;a&#x27;</span>))  <span class="hljs-comment"># 输出 False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;name&#x27;</span>))  <span class="hljs-comment"># 输出 True</span><br><br><span class="hljs-comment"># 判断类是否拥有某个方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;demo&#x27;</span>))  <span class="hljs-comment"># 输出 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;test_01&#x27;</span>))  <span class="hljs-comment"># 输出 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(MyClass, <span class="hljs-string">&#x27;say_hello&#x27;</span>))  <span class="hljs-comment"># 输出 True</span><br></code></pre></td></tr></table></figure><p>七、总结</p><p>类属性的动态管理可以让我们在运行时动态地修改类的属性和方法，这样就可以让代码更加灵活和可扩展。通过<code>setattr()</code>方法和<code>delattr()</code>方法，我们可以方便地添加或删除类的属性或方法。通过<code>getattr()</code>方法和<code>hasattr()</code>方法，我们可以判断类是否拥有某个属性或方法，并动态地获取该属性或方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级Python编程技巧之装饰器：让你的代码更灵活、更强大(二)</title>
    <link href="/2020/03/26/%E9%AB%98%E7%BA%A7Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E3%80%81%E6%9B%B4%E5%BC%BA%E5%A4%A7(%E4%BA%8C)/"/>
    <url>/2020/03/26/%E9%AB%98%E7%BA%A7Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E3%80%81%E6%9B%B4%E5%BC%BA%E5%A4%A7(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="高级Python编程技巧之装饰器：让你的代码更灵活、更强大-二"><a href="#高级Python编程技巧之装饰器：让你的代码更灵活、更强大-二" class="headerlink" title="高级Python编程技巧之装饰器：让你的代码更灵活、更强大(二)"></a>高级Python编程技巧之装饰器：让你的代码更灵活、更强大(二)</h1><h2 id="1-装饰器装饰类"><a href="#1-装饰器装饰类" class="headerlink" title="1.装饰器装饰类"></a>1.装饰器装饰类</h2><p>Python中，我们可以使用装饰器来对类进行装饰，以扩展类的功能或改变类的行为。下面是详细介绍Python如何用装饰器装饰类的步骤：</p><p>1.定义装饰器函数</p><p>我们首先需要定义一个装饰器函数，该函数接收一个类对象作为参数，并返回一个新的类对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">cls</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-comment"># 扩展代码</span><br>        res = cls(*args, **kwargs)<br>        <span class="hljs-comment"># 扩展代码</span><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>上述代码中，我们定义了一个装饰器函数<code>decorator</code>，它的作用是在类的构造函数执行前后加入一些扩展代码，并返回一个新的类对象。其中，<code>wrapper</code>函数作为装饰器的内部函数，用于执行扩展代码，并返回原类的实例对象。</p><p>2.使用装饰器修饰类</p><p>接下来，我们需要使用装饰器语法来修饰目标类，使其受到装饰器函数的影响。具体来说，我们可以使用<code>@</code>符号来修饰类，并将装饰器函数作为参数传入。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>上述代码中，我们使用装饰器<code>decorator</code>对<code>MyClass</code>类进行装饰。当我们实例化<code>MyClass</code>的对象时，实际上会执行装饰器函数<code>decorator</code>，并返回一个新的类对象。</p><p>3.使用装饰后的类</p><p>最后，我们可以使用装饰后的类来创建对象，并使用其中的方法和属性。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_obj = MyClass()<br>my_obj.some_method()<br></code></pre></td></tr></table></figure><p>上述代码中，我们创建了一个<code>MyClass</code>类的实例对象<code>my_obj</code>，并调用其中的方法<code>some_method()</code>。当调用该方法时，实际上会执行经过装饰器函数<code>decorator</code>扩展后的新类对象的方法。</p><p>总结：</p><p>使用装饰器对类进行装饰是Python中一种常见的编程技巧，它可以在不改变原有代码的基础上，对类的功能和行为进行扩展和改变。在实际开发中，我们可以利用装饰器对类进行扩展，使得代码更加简洁、灵活和易于维护。</p><h2 id="2-普通函数作为装饰器"><a href="#2-普通函数作为装饰器" class="headerlink" title="2.普通函数作为装饰器"></a>2.普通函数作为装饰器</h2><p>装饰器定义的常见形式：<br>    一、闭包实现的装饰器：<br>       适用场景：一般用于在原功能函数&#x2F;类的基础上做功能扩展</p><p>二、普通的函数实现的装饰器：<br>    适用场景：一般用于给被装饰的函数&#x2F;类，动态去添加或修改属性</p><p>三、类实现的装饰器(下次课讲)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    func.name = <span class="hljs-string">&#x27;musen&#x27;</span><br>    <span class="hljs-keyword">return</span> func`<br><br><br><span class="hljs-meta">@decorator  </span><span class="hljs-comment"># work = decorator(work)`</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------work---------&quot;</span>)<br><br><span class="hljs-built_in">print</span>(work.name)<br></code></pre></td></tr></table></figure><h2 id="3-functools模块中内置的装饰器"><a href="#3-functools模块中内置的装饰器" class="headerlink" title="3.functools模块中内置的装饰器"></a>3.functools模块中内置的装饰器</h2><p><code>functools</code> 模块是 Python 标准库中的一个模块，主要提供一些高阶函数（higher-order functions）和操作函数对象（callable objects）的工具。其中包含一些内置的装饰器，可以帮助我们实现一些常用的功能，例如缓存函数、包装函数等。</p><p>下面是 <code>functools</code> 模块中常用的内置装饰器的介绍：</p><ol><li><code>lru_cache()</code>：该装饰器用于缓存函数的结果，避免重复计算。该装饰器会创建一个 LRU（Least Recently Used）缓存，将函数的参数和结果作为键值对存储起来，当函数被再次调用时，如果参数在缓存中已经有对应的结果，则直接返回缓存中的结果，否则计算新结果并将其存入缓存中。该装饰器的一个常见应用场景是加速递归函数，将其转换为迭代函数。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-meta">@functools.lru_cache(<span class="hljs-params">maxsize=<span class="hljs-number">128</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><ol><li><code>wraps()</code>：该装饰器用于将被装饰函数的元信息（比如函数名、参数列表、文档字符串等）复制到装饰器函数中，避免因装饰器而改变函数的元信息。该装饰器通常与其他装饰器一起使用。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Before the function is called.&quot;</span>)<br>        func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After the function is called.&quot;</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;A simple function that greets the user.&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span>)<br>    <br><span class="hljs-built_in">print</span>(say_hello.__name__)  <span class="hljs-comment"># 输出：&#x27;say_hello&#x27;</span><br><span class="hljs-built_in">print</span>(say_hello.__doc__)   <span class="hljs-comment"># 输出：&#x27;A simple function that greets the user.&#x27;</span><br></code></pre></td></tr></table></figure><ol><li><code>partial()</code>：该函数用于部分应用（partial application）一个函数的参数，返回一个新的函数对象。部分应用是指将一个函数的某些参数固定下来，返回一个新的函数对象，这个新函数对象调用时不再需要提供那些已经被固定的参数，而是只需要提供剩余的参数。</li></ol><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x * y<br><br><span class="hljs-comment"># 固定第一个参数为2</span><br>double = functools.partial(multiply, <span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">print</span>(double(<span class="hljs-number">3</span>))   <span class="hljs-comment"># 输出：6</span><br><span class="hljs-built_in">print</span>(double(<span class="hljs-number">4</span>))   <span class="hljs-comment"># 输出：8</span><br></code></pre></td></tr></table></figure><p>以上是 <code>functools</code> 模块中常用的内置装饰器的介绍，它们提供了很多有用的功能，可以让我们更方便地编写 Python 函数。</p><h2 id="4-多个装饰器装饰一个函数"><a href="#4-多个装饰器装饰一个函数" class="headerlink" title="4.多个装饰器装饰一个函数"></a>4.多个装饰器装饰一个函数</h2><p>Python中允许我们通过在函数定义之前使用<code>@decorator</code>语法来应用装饰器。当函数被调用时，它们将被装饰器所包装。但是，有时候我们可能需要多个装饰器来装饰一个函数。在这种情况下，多个装饰器会按照装饰器的顺序一层一层地包装函数，从而实现多个装饰器的效果。</p><p>以下是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--demo----&#x27;</span>)<br>    <span class="hljs-keyword">return</span> func<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">musen</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------musen--------&quot;</span>)<br>    <span class="hljs-keyword">return</span> func<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lemon</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---------lemon-----&quot;</span>)<br>    <span class="hljs-keyword">return</span> func<br><br><br><span class="hljs-meta">@demo</span><br><span class="hljs-meta">@lemon</span><br><span class="hljs-meta">@musen  </span><span class="hljs-comment"># work = demo(lemon(musen(work)))</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----work--------&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    work()<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>work</code>函数被<code>@demo</code>、<code>@lemon</code>和<code>@musen</code>三个装饰器装饰。这些装饰器是按照从上到下的顺序执行的。这意味着首先执行<code>musen</code>装饰器，然后是<code>lemon</code>装饰器，最后是<code>demo</code>装饰器。这个顺序是非常重要的，因为装饰器是按照它们的顺序被执行的。</p><p>当<code>work</code>函数被调用时，它会被<code>musen</code>装饰器所包装，然后被<code>lemon</code>装饰器所包装，最后被<code>demo</code>装饰器所包装。这就意味着，当<code>work</code>函数被调用时，它将打印出所有三个装饰器的输出，然后再执行函数本身。</p><p>多个装饰器的顺序是非常重要的，因为它们的执行顺序会影响最终的结果。此外，不同的装饰器可能会有不同的作用，因此要仔细考虑它们的顺序。在使用多个装饰器时，最好使用一些注释来解释它们的作用和顺序，以便更好地理解代码。</p><h2 id="5-装饰器小节总结"><a href="#5-装饰器小节总结" class="headerlink" title="5.装饰器小节总结"></a>5.装饰器小节总结</h2><p>Python中的装饰器是一种高级语言特性，它可以对已有的函数或类进行功能扩展和修改，而无需改变原有函数或类的定义。装饰器本身是一个函数，它接受一个函数作为参数，并返回一个新的函数，通常新函数会在原函数前后执行一些额外的操作，比如记录日志、缓存结果、检查参数等。装饰器可以极大地提高代码的复用性和可维护性，让代码更加简洁、清晰。</p><p>Python中常用的装饰器有三种：</p><p>1.函数装饰器：用于修饰函数，可以在不改变函数定义的情况下增加功能，常见的函数装饰器包括 @property、@staticmethod、@classmethod、@wraps等。</p><p>2.类装饰器：用于修饰类，可以在不改变类定义的情况下增加功能，常见的类装饰器包括 @singleton、@contextmanager等。</p><p>3.方法装饰器：用于修饰类的方法，可以在不改变方法定义的情况下增加功能，常见的方法装饰器包括 @classmethod、@staticmethod、@property等。</p><p>Python标准库中提供了一个 functools 模块，其中包括一些内置的装饰器函数，如 lru_cache、singledispatch、wraps 等，这些装饰器函数可以帮助我们快速实现一些常见的装饰器功能，同时还可以提高代码的效率和可读性。</p><p>需要注意的是，装饰器虽然可以提高代码的可复用性和可维护性，但过多的装饰器也可能会导致代码过于复杂和难以理解，因此在使用装饰器时需要根据具体情况进行权衡。同时，在编写装饰器时也需要考虑异常处理、函数签名、函数元信息等方面的问题，以确保装饰器的正确性和可靠性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级Python编程技巧之装饰器：让你的代码更灵活、更强大(一)</title>
    <link href="/2020/03/22/%E9%AB%98%E7%BA%A7Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E3%80%81%E6%9B%B4%E5%BC%BA%E5%A4%A7(%E4%B8%80)/"/>
    <url>/2020/03/22/%E9%AB%98%E7%BA%A7Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%9A%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E3%80%81%E6%9B%B4%E5%BC%BA%E5%A4%A7(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="高级Python编程技巧之装饰器：让你的代码更灵活、更强大-一"><a href="#高级Python编程技巧之装饰器：让你的代码更灵活、更强大-一" class="headerlink" title="高级Python编程技巧之装饰器：让你的代码更灵活、更强大(一)"></a>高级Python编程技巧之装饰器：让你的代码更灵活、更强大(一)</h1><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><p>开放封闭原则是面向对象设计中的一项重要原则，指的是软件实体（如类、模块、函数等）应该对扩展开放，对修改关闭。具体来说，开放封闭原则要求我们设计软件实体时，应该尽量避免修改已有的代码，而是应该通过扩展已有的代码来实现新的功能。</p><p>开放封闭原则的核心思想是通过抽象来实现扩展。在软件设计时，我们应该尽量使用抽象的方式来描述系统的功能和特性，而不是依赖于具体的实现细节。这样，当需要增加新的功能时，只需要增加新的抽象，而不需要修改已有的代码。</p><p>下面举一个简单的例子来说明开放封闭原则的应用。假设我们有一个计算器程序，该程序可以进行加、减、乘、除四种运算。如果我们使用开放封闭原则来设计这个程序，那么我们可以先定义一个抽象的运算接口，该接口包含一个计算方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>然后，我们可以针对每种运算定义一个具体的类，这些类都实现了运算接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 + num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subtract</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 - num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Multiply</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 * num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Divide</span>(<span class="hljs-title class_ inherited__">Operation</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-keyword">return</span> num1 / num2<br></code></pre></td></tr></table></figure><p>这样，当需要增加新的运算时，只需要定义一个新的类，并实现运算接口即可。这个过程中，我们并没有修改已有的代码，而是通过扩展已有的代码来实现新的功能。</p><p>总之，开放封闭原则是面向对象设计中的一个非常重要的原则，它可以帮助我们设计出具有可扩展性和可维护性的软件系统。在实际应用中，我们应该尽可能地遵守这个原则，从而提高软件系统的可靠性和可用性。</p><h2 id="装饰器的介绍"><a href="#装饰器的介绍" class="headerlink" title="装饰器的介绍"></a>装饰器的介绍</h2><p>Python装饰器是一种特殊的语法，用于在不改变已有函数代码的情况下，为函数添加额外的功能或修改其行为。装饰器常常被用于日志记录、性能分析、输入合法性检查、缓存等场景。</p><h2 id="装饰器的示例代码"><a href="#装饰器的示例代码" class="headerlink" title="装饰器的示例代码"></a>装饰器的示例代码</h2><p>以下是一个简单的装饰器示例代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">def my_decorator(func):<br>    def <span class="hljs-keyword">wrapper</span>():<br>        print(&quot;Before the function is called.&quot;)<br>        func()<br>        print(&quot;After the function is called.&quot;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span><br><br>@my_decorator<br>def say_hello():<br>    print(&quot;Hello!&quot;)<br><br>say_hello()<br></code></pre></td></tr></table></figure><p>在这个示例代码中，我们定义了一个名为<code>my_decorator</code>的装饰器函数，它接受一个函数作为参数，并返回一个新的函数<code>wrapper</code>。这个新函数<code>wrapper</code>在调用原始函数之前和之后都执行了一些额外的代码。我们还使用装饰器语法<code>@my_decorator</code>来装饰<code>say_hello</code>函数，使得它在调用前后分别打印了”Before the function is called.”和”After the function is called.”。</p><h2 id="装饰器的装饰过程"><a href="#装饰器的装饰过程" class="headerlink" title="装饰器的装饰过程"></a>装饰器的装饰过程</h2><p>装饰器在Python中是通过函数或类实现的。在Python中，函数是一等公民，因此可以将函数作为参数传递给另一个函数，并返回一个函数。</p><p>当我们使用装饰器语法将一个函数装饰器应用于另一个函数时，Python会自动调用装饰器函数，并将被装饰函数作为参数传递给它。装饰器函数会在不修改原始函数代码的情况下，返回一个新的函数或类，用于替换原始函数或类。当我们调用经过装饰的函数时，实际上是调用了这个新的函数或类。</p><h2 id="装饰带参数的函数"><a href="#装饰带参数的函数" class="headerlink" title="装饰带参数的函数"></a>装饰带参数的函数</h2><p>在Python中，装饰带参数的函数需要在装饰器函数内部再定义一层函数，该函数用于接收原函数的参数并返回一个新的函数，新的函数才是真正被调用的函数。下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator start&quot;</span>)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator end&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>上述代码中，装饰器<code>decorator</code>定义了一个内部函数<code>wrapper</code>，<code>wrapper</code>接收原函数的参数<code>*args</code>和<code>**kwargs</code>，并在调用原函数前后输出一些信息。注意，在调用原函数时，需要使用<code>*args</code>和<code>**kwargs</code>将参数传递给原函数。在函数执行结束后，返回函数的执行结果。<code>add</code>函数被<code>@decorator</code>装饰，因此在执行<code>add</code>函数时会先执行<code>decorator</code>函数。</p><h2 id="装饰带返回值的函数"><a href="#装饰带返回值的函数" class="headerlink" title="装饰带返回值的函数"></a>装饰带返回值的函数</h2><p>要装饰带返回值的函数，需要在装饰器函数中定义一个内部函数，该函数调用原函数并返回执行结果。下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator start&quot;</span>)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;decorator end&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>上述代码中，<code>add</code>函数返回<code>a + b</code>的结果，在执行完<code>add</code>函数后，将结果赋给变量<code>result</code>。在装饰器<code>decorator</code>中，将原函数执行的结果存储在变量<code>result</code>中，并在执行完装饰器函数后返回该结果。</p><h2 id="通用装饰器的定义"><a href="#通用装饰器的定义" class="headerlink" title="通用装饰器的定义"></a>通用装饰器的定义</h2><p>通用装饰器的定义通常采用闭包的形式，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-comment"># 执行一些前置操作</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Before the function is called.&quot;</span>)<br>        <span class="hljs-comment"># 调用函数或方法</span><br>        result = func(*args, **kwargs)<br>        <span class="hljs-comment"># 执行一些后置操作</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After the function is called.&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>my_decorator</code> 是一个通用装饰器函数，它的参数 <code>func</code> 是一个被装饰的函数或方法。<code>wrapper</code> 是一个内部函数，它接收任意数量的位置参数和关键字参数，然后在调用被装饰的函数前后执行一些操作。</p><p>当一个函数被装饰器装饰时，装饰器实际上会返回 <code>wrapper</code> 函数，而不是原来的函数。这意味着当我们调用被装饰的函数时，实际上是调用了 <code>wrapper</code> 函数，而且这个函数执行了前置操作、调用了原函数、执行了后置操作。</p><p>下面是一个使用通用装饰器的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + name)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;done&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个 <code>say_hello</code> 函数，并用 <code>my_decorator</code> 装饰了它。当我们调用 <code>say_hello</code> 函数时，实际上是调用了装饰器返回的 <code>wrapper</code> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">say_hello(<span class="hljs-string">&quot;Tom&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Before the function <span class="hljs-keyword">is</span> called.<br>Hello, Tom<br>After the function <span class="hljs-keyword">is</span> called.<br></code></pre></td></tr></table></figure><p>上述代码中，我们调用了 <code>say_hello</code> 函数，并将 “Tom” 作为参数传递给它。装饰器在调用 <code>say_hello</code> 函数前后分别打印了 “Before the function is called.” 和 “After the function is called.” 的信息，这说明装饰器在 <code>say_hello</code> 函数的前后执行了一些操作。最后，函数返回了 “done” 这个字符串。</p><p>总的来说，通用装饰器是非常实用的，因为它可以应用于任何函数或方法，而不需要为每个函数都写一个专门的装饰器。同时，通用装饰器也可以方便地扩展和修改，以满足不同的需求。</p><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>在Python中，装饰器也可以接受参数。这种装饰器被称为带参数的装饰器。带参数的装饰器的定义方法与普通的装饰器有所不同，需要再次包装一层。</p><p>下面我们通过示例来详细介绍下Python中的可以传递参数的装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator_with_args</span>(<span class="hljs-params">arg1, arg2, arg3</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decorator with arguments &#123;&#125;, &#123;&#125;, &#123;&#125; called&quot;</span>.<span class="hljs-built_in">format</span>(arg1, arg2, arg3))<br>            func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br></code></pre></td></tr></table></figure><p>上述代码定义了一个带有三个参数的装饰器<code>decorator_with_args</code>，该装饰器用于为函数添加额外的功能，包括在函数执行前后输出一些信息。</p><p>现在我们来使用这个带有参数的装饰器来装饰一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@decorator_with_args(<span class="hljs-params"><span class="hljs-string">&quot;arg1&quot;</span>, <span class="hljs-string">&quot;arg2&quot;</span>, <span class="hljs-string">&quot;arg3&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_function</span>(<span class="hljs-params">arg</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;my_function called with argument:&quot;</span>, arg)<br></code></pre></td></tr></table></figure><p>在这里，我们使用<code>@</code>符号将<code>my_function</code>函数应用到<code>decorator_with_args</code>装饰器上，并传入了三个参数：”arg1”、”arg2”和”arg3”。当我们调用<code>my_function</code>函数时，装饰器会先输出”Decorator with arguments arg1, arg2, arg3 called”，然后再执行函数体。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python内置函数扩展、偏函数和闭包函数</title>
    <link href="/2020/03/18/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E3%80%81%E5%81%8F%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0/"/>
    <url>/2020/03/18/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E3%80%81%E5%81%8F%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python内置函数扩展、偏函数和闭包函数"><a href="#Python内置函数扩展、偏函数和闭包函数" class="headerlink" title="Python内置函数扩展、偏函数和闭包函数"></a>Python内置函数扩展、偏函数和闭包函数</h1><h4 id="1-1、匿名函数"><a href="#1-1、匿名函数" class="headerlink" title="1.1、匿名函数"></a>1.1、匿名函数</h4><p>python中有一种特殊的函数，不需要使用def去事定义，也不用给函数起名字，用过lamda表达式来定义，这种函<br>数叫匿名函数<br>匿名函数格式<br>lambda 参数：表达式（返回值）<br>问题需求:将以下函数改成匿名函数<br>#普通函数<br>def fun1(varl):<br>        return var1<em>2<br>#匿名函数定义后也可以用变量接收保存，但是一般不这样做<br>fun1 &#x3D; lambda var1 : var1</em>2<br>匿名函数的实际应用：匿名函数一般用来定义在表达式简单的函数，使用匿名函数可以简化代码，像上面的map,<br>filter等函数的使用。应用参数：通常用于函数传参时传递函数的场景</p><p>#问题需求一：对下面的列表进行排序（规则：根据列表中每个元素的第二个值的大小进行排序）<br>li &#x3D;[[1, 10,32]，[3， 22,99]，[2, 7,77]]<br>#问题需求二：对下面的列表进行排序（规则：根据元素的name字段的值的大小进行排序）<br>li2 &#x3D;[{‘id’: 1,”name”: 100},{‘id’： 7,”name”: 9},{‘id’: 3,”name”: 1}]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">add2 = <span class="hljs-keyword">lambda</span> a, b: a + b<br>res2 = add2(<span class="hljs-number">33</span>, <span class="hljs-number">44</span>)<br><span class="hljs-built_in">print</span>(res2)<br></code></pre></td></tr></table></figure><p>应用参数：通常用于函数传参是传递函数的场景</p><p>filter过滤器</p><p>map:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># li = [11,3,43,54,5]</span><br><span class="hljs-comment"># li.sort()</span><br><br><span class="hljs-comment"># li = [[11, 2], [1, 21], [93, 7], [87, 0], [23, 6]]</span><br>li = [<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">155</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">17</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">178</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">175</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;musen&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">185</span>&#125;,<br>]<br><span class="hljs-comment"># 根据列表中每个数据的age值大小进行排序</span><br>li.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;height&#x27;</span>])<br><span class="hljs-built_in">print</span>(li)<br></code></pre></td></tr></table></figure><p>eval：</p><p><code>eval()</code>函数是Python的一个内置函数，它可以执行一段字符串形式的Python代码，并返回执行结果。其基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">eval</span>(expression[, <span class="hljs-built_in">globals</span>[, <span class="hljs-built_in">locals</span>]])<br></code></pre></td></tr></table></figure><p>其中，<code>expression</code>是需要执行的Python代码，可以是字符串或者代码对象；<code>globals</code>和<code>locals</code>是可选参数，分别代表全局命名空间和局部命名空间。</p><p><code>eval()</code>函数的作用主要是将字符串形式的Python代码转换成可执行的代码并执行，可以实现一些动态性较强的操作。例如，可以用<code>eval()</code>函数计算一个字符串形式的数学表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">expression = <span class="hljs-string">&quot;2 + 3 * 4&quot;</span><br>result = <span class="hljs-built_in">eval</span>(expression)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出14</span><br></code></pre></td></tr></table></figure><p>还可以通过<code>eval()</code>函数来动态创建Python对象，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">expression = <span class="hljs-string">&quot;&#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;&quot;</span><br>person = <span class="hljs-built_in">eval</span>(expression)<br><span class="hljs-built_in">print</span>(person)  <span class="hljs-comment"># 输出&#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，由于<code>eval()</code>函数可以执行任意字符串形式的Python代码，因此也存在一定的安全风险。如果执行的代码来自于不可信的来源，可能会导致程序受到攻击或者损坏。因此，在使用<code>eval()</code>函数时需要谨慎，尽量避免执行来自不可信的源代码。</p><p>all：</p><p>在Python中，<code>all()</code> 是一个内置函数，用于判断一个可迭代对象中的所有元素是否都为 True。如果是，则返回 True；否则返回 False。</p><p><code>all()</code> 的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">all</span>(iterable)<br></code></pre></td></tr></table></figure><p>其中，<code>iterable</code> 表示一个可迭代对象，如列表、元组、字典、集合等。</p><p><code>all()</code> 的返回值类型为布尔型。</p><p>下面是一个例子，演示如何使用 <code>all()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">lst1 = [<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]<br>lst2 = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br>lst3 = []<br>lst4 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst1)) <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst2)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst3)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>(lst4)) <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p>在上述例子中，<code>all()</code> 分别对四个列表进行判断。<code>lst1</code> 中有一个元素为 False，因此 <code>all(lst1)</code> 的返回值为 False；<code>lst2</code> 中的所有元素都为非零值，因此 <code>all(lst2)</code> 的返回值为 True；<code>lst3</code> 为空列表，因此 <code>all(lst3)</code> 的返回值为 True；<code>lst4</code> 中有一个元素为 0，因此 <code>all(lst4)</code> 的返回值为 False。</p><p>总之，<code>all()</code> 可以判断一个可迭代对象中的所有元素是否都为 True，是编写 Python 程序中很常用的函数之一。</p><p>any:</p><p>在Python中，<code>any()</code>函数是一个内置函数，它用于检查给定可迭代对象中是否至少有一个元素为真值（True），如果至少有一个元素为真，则返回True，否则返回False。</p><p><code>any()</code>函数的语法如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">any</span><span class="hljs-params">(iterable)</span></span><br></code></pre></td></tr></table></figure><p>其中，<code>iterable</code>是一个可迭代对象，比如列表、元组、集合等。</p><p>下面是一个使用<code>any()</code>函数的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(my_list):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;至少有一个元素为True&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;所有元素都为False&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">至少有一个元素为<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>any()</code>函数检查了<code>my_list</code>列表中的所有元素，发现有一个元素为<code>True</code>，于是返回了<code>True</code>。</p><p><code>any()</code>函数非常适合用于检查可迭代对象中是否存在某个条件的元素，它可以帮助我们编写更加简洁和优雅的代码。</p><p>zip:</p><p><code>zip</code>是Python内置的一个函数，它接受任意多个（包括0个和1个）序列作为参数，返回一个由各个序列中的相同位置的元素组成的元组的迭代器。可以将多个序列进行配对，并同时迭代处理，这个过程类似于拉链的作用，因此也常被称为“拉链函数”。</p><p><code>zip</code>函数的基本语法格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">zip</span>(*iterables)<br></code></pre></td></tr></table></figure><p>其中，<code>*iterables</code>表示传入任意多个序列。</p><p>举例来说，如果有两个列表a和b，想要将它们对应的元素配对在一起，可以使用<code>zip</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>c = <span class="hljs-built_in">zip</span>(a, b)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(c))<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>可以看到，<code>zip</code>函数将a和b两个列表的相同位置的元素进行了配对，并返回了一个包含这些元素的元组列表。</p><p>除了基本用法之外，<code>zip</code>函数还可以和其他函数或语句进行组合使用，例如结合列表推导式或<code>filter</code>函数等，以实现更加复杂的数据处理逻辑。</p><h4 id="1-2偏函数"><a href="#1-2偏函数" class="headerlink" title="1.2偏函数"></a>1.2偏函数</h4><p>问题一：什么是偏函数?<br>在Python的内置模块functools 提供了很多有用的功能，其中一个就是偏函数（partial）。<br>问题二：偏函数有什么用?<br>当函数的参数个数太多，需要简化时，使用 functools.partial可以创建一个新的函数，这个新函数可以固定住<br>原函数的部分参数，从而在调用时更简单。<br>偏函数应用案列<br>#在我们之前学到的内置函数中filter中，调用的时候需要传入两个参数，第一个是函数，第二个是我们需要过滤的可迭<br>代类型的数据，<br>#我们可以通过传入不同的过滤条件去过滤出来我们需要的数据。<br>filter(lambda x:x&gt;3,1i1)<br>filter(lambda x:x&gt;10,1i1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><br><br><span class="hljs-comment"># 偏函数：固定函数的参数，简化函数调用时的参数传递</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">name, datas</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param name: 使用者的名字</span><br><span class="hljs-string">    :param datas: 传递进来的数据</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#125;-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, datas)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">res = work(<span class="hljs-string">&#x27;musen&#x27;</span>,<span class="hljs-string">&#x27;1212&#x27;</span>)<br>res2 = work(<span class="hljs-string">&#x27;musen&#x27;</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>)<br>res3 = work(<span class="hljs-string">&#x27;musen&#x27;</span>,<span class="hljs-string">&#x27;dddd&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(res2)<br><span class="hljs-built_in">print</span>(res3)<br><br>work2 = partial(work, datas=<span class="hljs-string">&#x27;musen&#x27;</span>)<br><br>r1 = work2(<span class="hljs-string">&#x27;222&#x27;</span>)<br>r2 = work2(<span class="hljs-number">333</span>)<br>r3 = work2(<span class="hljs-number">444</span>)<br>r4 = work2(<span class="hljs-number">5555</span>)<br><span class="hljs-built_in">print</span>(r1, r2, r3, r4)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work3</span>(<span class="hljs-params">datas</span>):<br>    work(<span class="hljs-string">&#x27;musen&#x27;</span>, datas)<br></code></pre></td></tr></table></figure><h4 id="1-3闭包函数"><a href="#1-3闭包函数" class="headerlink" title="1.3闭包函数"></a>1.3闭包函数</h4><p>在 Python 中，闭包是指一个函数对象，它引用了外部作用域中的一个或多个变量，即使这些变量在外部作用域已经不存在，它仍然可以访问并修改这些变量。简而言之，闭包是一种特殊的函数，它可以“记住”在创建它的时候所处的环境。</p><p>闭包函数可以用来实现许多有趣的功能，例如在 Python 中，常常使用闭包来实现装饰器。</p><p>闭包函数的基本格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer_func</span>(<span class="hljs-params">param</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner_func</span>():<br>        <span class="hljs-comment"># do something with param</span><br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> inner_func<br></code></pre></td></tr></table></figure><p>其中，<code>outer_func</code> 是外层函数，接受一个参数 <code>param</code>，返回一个内层函数 <code>inner_func</code>，内层函数可以访问外层函数的参数和变量，然后返回一个结果 <code>result</code>。</p><p>当我们调用 <code>outer_func(param)</code> 时，它会返回一个函数对象 <code>inner_func</code>，这个函数可以独立地被调用，但它仍然可以访问外层函数 <code>outer_func</code> 的作用域。这就是闭包的本质。</p><p>下面是一个具体的例子，演示了如何使用闭包来实现一个计数器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_counter</span>():<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">counter</span>():<br>        <span class="hljs-keyword">nonlocal</span> count<br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br>    <span class="hljs-keyword">return</span> counter<br><br>counter1 = make_counter()<br>counter2 = make_counter()<br><br><span class="hljs-built_in">print</span>(counter1())  <span class="hljs-comment"># 输出 1</span><br><span class="hljs-built_in">print</span>(counter1())  <span class="hljs-comment"># 输出 2</span><br><span class="hljs-built_in">print</span>(counter2())  <span class="hljs-comment"># 输出 1</span><br><span class="hljs-built_in">print</span>(counter1())  <span class="hljs-comment"># 输出 3</span><br><span class="hljs-built_in">print</span>(counter2())  <span class="hljs-comment"># 输出 2</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>make_counter</code> 函数，它返回了一个内层函数 <code>counter</code>。在 <code>counter</code> 函数中，我们定义了一个变量 <code>count</code>，并将其初始化为 0。每次调用 <code>counter</code> 函数时，它都会将 <code>count</code> 的值加 1，并返回新的值。</p><p>我们用 <code>make_counter</code> 函数分别创建了两个计数器 <code>counter1</code> 和 <code>counter2</code>，它们是两个独立的函数对象，它们各自维护着自己的 <code>count</code> 变量，彼此之间互不干扰。这正是闭包的特点所在。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python的迭代器和生成器</title>
    <link href="/2020/03/16/Python%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2020/03/16/Python%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Python的迭代器和生成器"><a href="#Python的迭代器和生成器" class="headerlink" title="Python的迭代器和生成器"></a>Python的迭代器和生成器</h1><h3 id="1、可迭代对象"><a href="#1、可迭代对象" class="headerlink" title="1、可迭代对象"></a>1、可迭代对象</h3><p>能够进行迭代逐一返回其成员项的对象称为可迭代对象。可迭代对象的例子包括<br>•所有序列类型：如 1ist、 str 和 tuple，range<br>•非序列类型： dict、set、文件对象:f &#x3D; open(xx，）<br>•实现了_iter_()方法的任意对象（可迭代协议)<br>•实现了序列语义的_getitem_()方法的任意对象。</p><p>1.1、迭代协议：<br>    对象定义了一个 <code>__iter__</code> 方法的，那么这个对象就实现了迭代协议，<code>__iter__</code>方法的返回值必须是一个迭代器</p><p>迭代器(Iterator)：<br>    1.2、迭代器协议<br>        迭代器协议由一个 <code>__iter__</code> 方法和<code>__next__</code>方法共同构成。实现了这两个方法的对象就实现了迭代器协议。<br>    1、对象实现了迭代协议的对象<br>    2、对象实现了<code>__next__</code>方法，<code>__next__</code>方法在迭代完所有数据之后，会抛出<code>StopIteration</code>的错误信息</p><p>迭代器和可迭代对象的操作</p><p>1、实现了迭代器协议的对象，就是一个迭代器<br>2、所有的可迭代对象 都可以通过内置函数iter()转换为迭代器：<br>3、迭代器对象能够使用 内置函数next 进行迭代操作<br>4、所有的迭代器都是可迭代对象，因为迭代器协议包含了迭代协议</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable, Iterator<br><br>st1 = <span class="hljs-string">&#x27;111m22m33&#x27;</span><br>li = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(st1,Iterable))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(li,Iterable))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(st1,Iterator))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(li,Iterator))<br>st1 = <span class="hljs-string">&#x27;abcd&#x27;</span><br>li = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><span class="hljs-comment"># 可迭代对象转换为迭代器:内置函数iter()</span><br>s = <span class="hljs-built_in">iter</span>(st1)   <span class="hljs-comment">#  st1.__iter__()</span><br><span class="hljs-comment"># 迭代器可以使用next进行迭代操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))  <span class="hljs-comment"># st1.__next__()</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(s))<br></code></pre></td></tr></table></figure><h5 id="5-自定义可迭代对象"><a href="#5-自定义可迭代对象" class="headerlink" title="5.自定义可迭代对象"></a>5.自定义可迭代对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass1</span>:<br><br>    <span class="hljs-comment"># 实现迭代协议</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>([<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>])<br><br><br>obj = MyClass1()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> obj:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass2</span>:<br>    value = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><br>    <span class="hljs-comment"># 实现序列语义</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> self.value[item]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">pass</span><br><br>obj = MyClass2()<br><br>res = obj[<span class="hljs-number">0</span>]   <span class="hljs-comment">#  obj.__getitem__(0)</span><br><br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h4 id="1-1创建生成器"><a href="#1-1创建生成器" class="headerlink" title="1.1创建生成器"></a>1.1创建生成器</h4><p>#方式一：生成器表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">g = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))<br><br><span class="hljs-built_in">print</span>(g)<br><span class="hljs-comment"># # 生成器能不能使用next进行迭代操作？？</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-comment"># # 注意点：生成器是一种特殊的迭代器，在使用next进行迭代时，数据迭代完之后，会抛出StopIteration异常</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br></code></pre></td></tr></table></figure><p>*方式二：生成器函数<br>注意点：<br>1、函数内部只要定义yield这个关键字，那么这个函数就是一个生成器函数<br>2、生成器函数调用是不会执行内部代码，而是直接返回一个生成器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----work函数----&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------1--&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">888</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----2------&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">777</span><br><br><br>g = work()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;g:&#x27;</span>, g)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;生成的数据为：&#x27;</span>, <span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;生成的数据为：&#x27;</span>, <span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;生成的数据为：&#x27;</span>, <span class="hljs-built_in">next</span>(g))<br></code></pre></td></tr></table></figure><p>#生成器内部不直接存储数据，只存储生成数据的计算表达式（在保存大规模数据时，可以节约内存消耗）。</p><h5 id="1-1生成器和列表对比"><a href="#1-1生成器和列表对比" class="headerlink" title="1.1生成器和列表对比"></a>1.1生成器和列表对比</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">li = [<span class="hljs-number">111</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br>dic = &#123;<span class="hljs-number">1</span>: <span class="hljs-number">11</span>, <span class="hljs-number">2</span>: <span class="hljs-number">3333</span>&#125;<br><br><span class="hljs-comment"># 生成器内部不直接存储数据，只存储生成数据的计算表达式（在处理大规模的数据时，可以节约内层消耗）</span><br>g1 = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-built_in">print</span>(li)<br><span class="hljs-built_in">print</span>(dic)<br><span class="hljs-built_in">print</span>(g1)<br><br>li = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500000</span>)]<br>res = <span class="hljs-built_in">input</span>()<br><br>li = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000000</span>))<br>res = <span class="hljs-built_in">input</span>()<br></code></pre></td></tr></table></figure><h3 id="2-生成器函数"><a href="#2-生成器函数" class="headerlink" title="2 生成器函数"></a>2 生成器函数</h3><h4 id="2-1-生成器的close方法-关闭生成器"><a href="#2-1-生成器的close方法-关闭生成器" class="headerlink" title="2.1 生成器的close方法:关闭生成器"></a>2.1 生成器的close方法:关闭生成器</h4><p>print(next(g))</p><p>print(next(g))<br>print(next(g))<br>g.close()<br>print(next(g))</p><h4 id="2-2-send方法"><a href="#2-2-send方法" class="headerlink" title="2.2 send方法"></a>2.2 send方法</h4><p>给生成器传递参数(与生成器内部进行数据交互)<br>生成器的send方法必须在使用了一次next之后才能使用。</p><p>print(‘next方法执行的结果:’, next(g))</p><p>res &#x3D; g.send(‘musen’)</p><p>iprint(‘send方法执行的结果:’, res)<br>res &#x3D; g.send(‘999’)<br>print(‘send方法执行的结果:’, res)</p><p>res &#x3D; g.send(‘python’)</p><p>print(‘send方法执行的结果:’, res)</p><h4 id="2-3生成器根据send传递的参数来生成数据"><a href="#2-3生成器根据send传递的参数来生成数据" class="headerlink" title="2.3生成器根据send传递的参数来生成数据"></a>2.3生成器根据send传递的参数来生成数据</h4><p>如果要实现根据参数去生成数据的生成器：<br>1、使用send传递了参数<br>2、直接使用next 没有传参数<br>需求：根擀send方法传递的值类生成参数的2次方<br>def work()：<br>val &#x3D; None<br>for i in range(100):<br>if val:<br>val &#x3D; yield val ** 2<br>else:<br>val&#x3D; yield i+1<br>g&#x3D; work()<br>print(next(g))<br>print(g.send(11))<br>print(g.send(20))<br>print(next(g))<br>print(g.send(11))<br>print(g.send(20))<br>print(next(g))</p><h3 id="3、throw方法：在生成器内部抛出指定的异常"><a href="#3、throw方法：在生成器内部抛出指定的异常" class="headerlink" title="3、throw方法：在生成器内部抛出指定的异常"></a>3、throw方法：在生成器内部抛出指定的异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># raise ValueError</span><br>g.throw(ValueError)<br></code></pre></td></tr></table></figure><h3 id="4-根据参数生成数据的案例"><a href="#4-根据参数生成数据的案例" class="headerlink" title="4.根据参数生成数据的案例"></a>4.根据参数生成数据的案例</h3><p>生成器根据send传递的参数来生成数据:</p><p>如果要实现根据参数去生成数据的生成器,需要考虑下面这两种情况：<br>    1、使用send传递了参数<br>    2、直接使用next 没有传参数</p><p>#需求：根据send方法传递的值类生成 参数的2次方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    val = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        <span class="hljs-keyword">if</span> val:<br>            val = <span class="hljs-keyword">yield</span> val ** <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            val = <span class="hljs-keyword">yield</span> i + <span class="hljs-number">1</span><br><br><br>g = work()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">20</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">20</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">20</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br></code></pre></td></tr></table></figure><h3 id="5-pytest中利用生成器实现测试夹具的执行流程"><a href="#5-pytest中利用生成器实现测试夹具的执行流程" class="headerlink" title="5.pytest中利用生成器实现测试夹具的执行流程"></a>5.pytest中利用生成器实现测试夹具的执行流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-comment"># 用例前置执行</span><br>    <span class="hljs-comment"># 此处登录获取token</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;用例执行的前置脚本&quot;</span>)<br>    token = <span class="hljs-string">&#x27;asfsgyuajioghj&#x27;</span><br>    <span class="hljs-keyword">yield</span> token<br>    <span class="hljs-comment"># 用例后置执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;用例执行的后置脚本&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_01</span>(<span class="hljs-params">login</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---测试用例的执行代码----------&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;token的值：&quot;</span>, login)<br>    expected = <span class="hljs-string">&#x27;OK&#x27;</span><br>    res = <span class="hljs-string">&#x27;OK&#x27;</span><br>    <span class="hljs-keyword">assert</span> expected == res<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1、检查测试用例的是否有指定测试夹具</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 夹具本质是一个生成器函数  </span><br><span class="hljs-string">#  pytest测试夹具执行的流程：</span><br><span class="hljs-string"></span><br><span class="hljs-string">g = login()</span><br><span class="hljs-string">token = next(g)</span><br><span class="hljs-string"></span><br><span class="hljs-string">test_01(token)</span><br><span class="hljs-string"></span><br><span class="hljs-string">try:</span><br><span class="hljs-string">    next(g)</span><br><span class="hljs-string">expect:</span><br><span class="hljs-string">    pass</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>总结</p><p>在Python中，迭代器和生成器都是用来遍历数据序列的工具，但它们的实现方式和作用略有不同。</p><p>迭代器是一种对象，可以通过next()方法依次访问序列中的元素。Python内置的许多数据类型都支持迭代器，比如列表、元组、字符串等。通过迭代器，我们可以遍历整个序列，而无需将整个序列加载到内存中，从而节省内存空间。迭代器可以通过定义一个__iter__()方法来创建，并且通常需要定义一个__next__()方法来遍历序列中的元素。</p><p>生成器是一种特殊的迭代器，可以通过yield语句将结果生成到调用方。生成器函数在执行过程中可以挂起，并且在下次调用时可以从挂起的位置继续执行。与迭代器相比，生成器可以更加灵活地控制数据的生成和消耗，可以有效地处理大规模数据和无限序列的问题。生成器可以通过定义一个包含yield语句的函数来创建。</p><p>迭代器和生成器的作用主要有以下几个方面：</p><ol><li>节省内存空间：通过迭代器和生成器，我们可以逐个访问序列中的元素，而无需将整个序列加载到内存中，从而节省内存空间。</li><li>适用于大规模数据和无限序列：迭代器和生成器可以更加灵活地控制数据的生成和消耗，可以有效地处理大规模数据和无限序列的问题。</li><li>增加程序的可读性和可维护性：使用迭代器和生成器可以使代码更加简洁、清晰，提高代码的可读性和可维护性。</li><li>方便数据处理和转换：通过迭代器和生成器，我们可以方便地对序列进行处理和转换，例如对序列中的元素进行筛选、排序、合并等操作。</li></ol><p>总之，迭代器和生成器是Python中非常重要的语言特性，能够大大提高代码的效率和可读性，是Python程序员必须掌握的基本技能之一。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
      <tag>python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python推导式详解</title>
    <link href="/2020/03/12/Python%E6%8E%A8%E5%AF%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/03/12/Python%E6%8E%A8%E5%AF%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Python推导式详解"><a href="#Python推导式详解" class="headerlink" title="Python推导式详解"></a>Python推导式详解</h1><p>Python推导式（Comprehension）是一种简洁而强大的语言特性，用于快速创建序列、集合和字典等数据结构。它能够简化代码，使代码更加清晰易懂。</p><p>推导式的主要作用是通过一种紧凑的语法形式创建新的数据结构，可以在一个简单的表达式中完成复杂的操作，从而简化了代码的编写和阅读。</p><h4 id="1-推导式语法："><a href="#1-推导式语法：" class="headerlink" title="1.推导式语法："></a>1.推导式语法：</h4><p>作用：根据一些规律 迅速生成列表</p><p>li &#x3D; [ x for i in xxx ]</p><p>1.需求 如何快速生成 一个[data0 ,data1…data99]的列表？</p><p>#for循环 写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">li = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    li.append(<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br><span class="hljs-built_in">print</span>(li)<br></code></pre></td></tr></table></figure><p>#列表推导式实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">li2 = [<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i)   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)]<br><br><span class="hljs-built_in">print</span>(li2)<br></code></pre></td></tr></table></figure><p>#推导式结合if 进行数据过滤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&#x27;data0&#x27;</span>, <span class="hljs-string">&#x27;data1&#x27;</span>, <span class="hljs-string">&#x27;data2&#x27;</span>, <span class="hljs-string">&#x27;data3&#x27;</span>, <span class="hljs-string">&#x27;data4&#x27;</span>, <span class="hljs-string">&#x27;data5&#x27;</span>, <span class="hljs-string">&#x27;data6&#x27;</span>, <span class="hljs-string">&#x27;data7&#x27;</span>, <span class="hljs-string">&#x27;data8&#x27;</span>, <span class="hljs-string">&#x27;data9&#x27;</span>, <span class="hljs-string">&#x27;data10&#x27;</span>, <span class="hljs-string">&#x27;data11&#x27;</span>,<br>       <span class="hljs-string">&#x27;data12&#x27;</span>, <span class="hljs-string">&#x27;data13&#x27;</span>, <span class="hljs-string">&#x27;data14&#x27;</span>, <span class="hljs-string">&#x27;data15&#x27;</span>, <span class="hljs-string">&#x27;data16&#x27;</span>, <span class="hljs-string">&#x27;data17&#x27;</span>, <span class="hljs-string">&#x27;data18&#x27;</span>, <span class="hljs-string">&#x27;data19&#x27;</span>, <span class="hljs-string">&#x27;data20&#x27;</span>, <span class="hljs-string">&#x27;data21&#x27;</span>, <span class="hljs-string">&#x27;data22&#x27;</span>,<br>       <span class="hljs-string">&#x27;data23&#x27;</span>, <span class="hljs-string">&#x27;data24&#x27;</span>, <span class="hljs-string">&#x27;data25&#x27;</span>, <span class="hljs-string">&#x27;data26&#x27;</span>, <span class="hljs-string">&#x27;data27&#x27;</span>, <span class="hljs-string">&#x27;data28&#x27;</span>, <span class="hljs-string">&#x27;data29&#x27;</span>, <span class="hljs-string">&#x27;data30&#x27;</span>, <span class="hljs-string">&#x27;data31&#x27;</span>, <span class="hljs-string">&#x27;data32&#x27;</span>, <span class="hljs-string">&#x27;data33&#x27;</span>,<br>       <span class="hljs-string">&#x27;data34&#x27;</span>, <span class="hljs-string">&#x27;data35&#x27;</span>, <span class="hljs-string">&#x27;data36&#x27;</span>, <span class="hljs-string">&#x27;data37&#x27;</span>, <span class="hljs-string">&#x27;data38&#x27;</span>, <span class="hljs-string">&#x27;data39&#x27;</span>, <span class="hljs-string">&#x27;data40&#x27;</span>, <span class="hljs-string">&#x27;data41&#x27;</span>, <span class="hljs-string">&#x27;data42&#x27;</span>, <span class="hljs-string">&#x27;data43&#x27;</span>, <span class="hljs-string">&#x27;data44&#x27;</span>,<br>       <span class="hljs-string">&#x27;data45&#x27;</span>, <span class="hljs-string">&#x27;data46&#x27;</span>, <span class="hljs-string">&#x27;data47&#x27;</span>, <span class="hljs-string">&#x27;data48&#x27;</span>, <span class="hljs-string">&#x27;data49&#x27;</span>, <span class="hljs-string">&#x27;data50&#x27;</span>, <span class="hljs-string">&#x27;data51&#x27;</span>, <span class="hljs-string">&#x27;data52&#x27;</span>, <span class="hljs-string">&#x27;data53&#x27;</span>, <span class="hljs-string">&#x27;data54&#x27;</span>, <span class="hljs-string">&#x27;data55&#x27;</span>,<br>       <span class="hljs-string">&#x27;data56&#x27;</span>, <span class="hljs-string">&#x27;data57&#x27;</span>, <span class="hljs-string">&#x27;data58&#x27;</span>, <span class="hljs-string">&#x27;data59&#x27;</span>, <span class="hljs-string">&#x27;data60&#x27;</span>, <span class="hljs-string">&#x27;data61&#x27;</span>, <span class="hljs-string">&#x27;data62&#x27;</span>, <span class="hljs-string">&#x27;data63&#x27;</span>, <span class="hljs-string">&#x27;data64&#x27;</span>, <span class="hljs-string">&#x27;data65&#x27;</span>, <span class="hljs-string">&#x27;data66&#x27;</span>,<br>       <span class="hljs-string">&#x27;data67&#x27;</span>, <span class="hljs-string">&#x27;data68&#x27;</span>, <span class="hljs-string">&#x27;data69&#x27;</span>, <span class="hljs-string">&#x27;data70&#x27;</span>, <span class="hljs-string">&#x27;data71&#x27;</span>, <span class="hljs-string">&#x27;data72&#x27;</span>, <span class="hljs-string">&#x27;data73&#x27;</span>, <span class="hljs-string">&#x27;data74&#x27;</span>, <span class="hljs-string">&#x27;data75&#x27;</span>, <span class="hljs-string">&#x27;data76&#x27;</span>, <span class="hljs-string">&#x27;data77&#x27;</span>,<br>       <span class="hljs-string">&#x27;data78&#x27;</span>, <span class="hljs-string">&#x27;data79&#x27;</span>, <span class="hljs-string">&#x27;data80&#x27;</span>, <span class="hljs-string">&#x27;data81&#x27;</span>, <span class="hljs-string">&#x27;data82&#x27;</span>, <span class="hljs-string">&#x27;data83&#x27;</span>, <span class="hljs-string">&#x27;data84&#x27;</span>, <span class="hljs-string">&#x27;data85&#x27;</span>, <span class="hljs-string">&#x27;data86&#x27;</span>, <span class="hljs-string">&#x27;data87&#x27;</span>, <span class="hljs-string">&#x27;data88&#x27;</span>,<br>       <span class="hljs-string">&#x27;data89&#x27;</span>, <span class="hljs-string">&#x27;data90&#x27;</span>, <span class="hljs-string">&#x27;data91&#x27;</span>, <span class="hljs-string">&#x27;data92&#x27;</span>, <span class="hljs-string">&#x27;data93&#x27;</span>, <span class="hljs-string">&#x27;data94&#x27;</span>, <span class="hljs-string">&#x27;data95&#x27;</span>, <span class="hljs-string">&#x27;data96&#x27;</span>, <span class="hljs-string">&#x27;data97&#x27;</span>, <span class="hljs-string">&#x27;data98&#x27;</span>, <span class="hljs-string">&#x27;data99&#x27;</span>]<br></code></pre></td></tr></table></figure><p>#把上述data为偶数的数据过滤掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [ <span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i)   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)  <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span> ]<br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>#需求 ：生成一个[‘data0’,’musen1’,’data1’,’musen2’……’data98’,’musen99’,]</p><p>#常规语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">li = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br><br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        li.append(<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><br>    <span class="hljs-keyword">else</span>:<br>        li.append(<span class="hljs-string">&quot;musen&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br><span class="hljs-built_in">print</span>(li)<br></code></pre></td></tr></table></figure><h4 id="2-三元运算符"><a href="#2-三元运算符" class="headerlink" title="2.三元运算符"></a>2.三元运算符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">n =<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个数字：&quot;</span>))<br><br>number = <span class="hljs-string">&quot;大于10&quot;</span><span class="hljs-keyword">if</span> <span class="hljs-number">10</span> &lt; n <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;小于10&quot;</span><br><br><span class="hljs-built_in">print</span>(number)<br></code></pre></td></tr></table></figure><h5 id="2-1推导式结合：三元运算符使用"><a href="#2-1推导式结合：三元运算符使用" class="headerlink" title="2.1推导式结合：三元运算符使用"></a>2.1推导式结合：三元运算符使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [<span class="hljs-string">&quot;data&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>  <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;musen&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)]<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h4 id="3-字典推导式"><a href="#3-字典推导式" class="headerlink" title="3.字典推导式"></a>3.字典推导式</h4><h5 id="3-1字典推导式语法"><a href="#3-1字典推导式语法" class="headerlink" title="3.1字典推导式语法"></a>3.1字典推导式语法</h5><p>#字典推导式基本语法</p><p><code>dic = &#123;k:v for x in xxx&#125;</code></p><p>#字典推导式结合 if 进行过滤</p><p><code>dic = &#123;k:v for x in xxx if xxx&#125;</code></p><p>#字典推导式结合 三元运算符 进行过滤</p><p><code>dic = &#123;k:v  if xx else xxx  for x in xxx &#125;</code></p><h5 id="3-2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据"><a href="#3-2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据" class="headerlink" title="3.2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据"></a>3.2问题需求：有一个列表li，把他转化为一个元素下标为键，值为元素值的字典数据</h5><p>li &#x3D; [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]</p><p>#之前for循环的做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1= &#123;&#125;<br><br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(li):<br><br>​dict1[i] = j<br><br><span class="hljs-built_in">print</span>(dict1)<br></code></pre></td></tr></table></figure><p>#字典推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;i:j  <span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(li) &#125;<br><br>​<span class="hljs-built_in">print</span>(dic)<br></code></pre></td></tr></table></figure><h5 id="3-3-使用字典推倒式将下面字符串格式的数据，改成字典类型的数据"><a href="#3-3-使用字典推倒式将下面字符串格式的数据，改成字典类型的数据" class="headerlink" title="3.3  使用字典推倒式将下面字符串格式的数据，改成字典类型的数据"></a>3.3  使用字典推倒式将下面字符串格式的数据，改成字典类型的数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">cookie = <span class="hljs-string">&#x27;BIDUPSID=D0727533D7147B7;PSTM=1530348042; BAIDUID=B1005C9BC2EB28; &#x27;</span> \<br>         <span class="hljs-string">&#x27;sugstore=0;__cfduid=d0a13458f8ac2a;BD_UPN=12314353;ispeed_lsm=2;&#x27;</span> \<br>         <span class="hljs-string">&#x27;BDORZ=B490B5EBF6F3CD402&#x27;</span><br><br>res = cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)<br>dic = &#123;&#125;<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> res:<br>     d = item.split(<span class="hljs-string">&#x27;=&#x27;</span>)<br>     key = d[<span class="hljs-number">0</span>]<br>     value = d[<span class="hljs-number">1</span>]<br>     dic[key] =value<br> <span class="hljs-built_in">print</span>(dic)<br></code></pre></td></tr></table></figure><h6 id="3-4-1字典推导式实现"><a href="#3-4-1字典推导式实现" class="headerlink" title="3.4.1字典推导式实现"></a>3.4.1字典推导式实现</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = &#123;item.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>]: item.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)&#125;<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h6 id="3-4-2推导式中双重for嵌套"><a href="#3-4-2推导式中双重for嵌套" class="headerlink" title="3.4.2推导式中双重for嵌套"></a>3.4.2推导式中双重for嵌套</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = &#123;k: v <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> [item.split(<span class="hljs-string">&#x27;=&#x27;</span>)]&#125;<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h6 id="3-4-3列表推导式集合字典推导式"><a href="#3-4-3列表推导式集合字典推导式" class="headerlink" title="3.4.3列表推导式集合字典推导式"></a>3.4.3列表推导式集合字典推导式</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [item.split(<span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)]<br><span class="hljs-comment"># print(res)</span><br>dic = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> res&#125;<br><span class="hljs-built_in">print</span>(dic)<br></code></pre></td></tr></table></figure><p>3.4.4列表推导式集合字典推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dic2 = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> [item.split(<span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie.split(<span class="hljs-string">&#x27;;&#x27;</span>)]&#125;<br><span class="hljs-built_in">print</span>(dic2)<br></code></pre></td></tr></table></figure><h5 id="3-5推导式中多重for嵌套"><a href="#3-5推导式中多重for嵌套" class="headerlink" title="3.5推导式中多重for嵌套"></a>3.5推导式中多重for嵌套</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">li =[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]:<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]:<br>        li.append(<span class="hljs-string">&#x27;&#123;&#125;-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i,v))<br><span class="hljs-built_in">print</span>(li)<br><br><br>li2 = [<span class="hljs-string">&#x27;&#123;&#125;-&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i, v) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>] <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]]<br><span class="hljs-built_in">print</span>(li2)<br><br></code></pre></td></tr></table></figure><h4 id="4-集合推导式和生成器表达式"><a href="#4-集合推导式和生成器表达式" class="headerlink" title="4.集合推导式和生成器表达式"></a>4.集合推导式和生成器表达式</h4><p>列表推导式 : [ x for x in XXX ]<br>字典推导式 : { k:v  for x in XXX }</p><p>集合推导式  : { x for x in XXX }<br>生成器表达式 : ( x for x in XXX ) </p><h5 id="4-1集合推导式"><a href="#4-1集合推导式" class="headerlink" title="4.1集合推导式"></a>4.1集合推导式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">se = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)&#125;<br><span class="hljs-built_in">print</span>(se)<br></code></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python高级语法</tag>
      
      <tag>python测试开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的编码规范</title>
    <link href="/2020/03/10/pep8/"/>
    <url>/2020/03/10/pep8/</url>
    
    <content type="html"><![CDATA[<h1 id="python的编码规范"><a href="#python的编码规范" class="headerlink" title="python的编码规范"></a>python的编码规范</h1><h4 id="1-1-pep8规范"><a href="#1-1-pep8规范" class="headerlink" title="1.1 pep8规范"></a>1.1 pep8规范</h4><h5 id="1-缩进"><a href="#1-缩进" class="headerlink" title="1.缩进"></a>1.缩进</h5><p>*每一级缩进使用4个空格。</p><p>*续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐<a href="https://blog.csdn.net/ratsniper/article/details/78954852#fn:7">3</a>。当使用挂行缩进时，应该考虑到第一行不应该有参数，以及使用缩进以区分自己是续行。</p><h5 id="2-行的最大长度"><a href="#2-行的最大长度" class="headerlink" title="2.行的最大长度"></a>2.行的最大长度</h5><p>Ctrl+Alt+L (格式化代码快捷键 ——&gt;&gt; 代码会自动按照pep8规范格式化)</p><p>*所有行限制的最大字符数为79个.</p><p>*注释的限制最大字符数是72个</p><p>\ 表示隐式换行</p><p>*如果一个字符串过长，可以回车，pycharm会自动补一个\  隐式换行连接符。</p><h5 id="3-空行"><a href="#3-空行" class="headerlink" title="3.空行"></a>3.空行</h5><p>*顶层函数和类的定义，前后用两个空行隔开。</p><p>*类的方法定义用一个空行隔开</p><h5 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h5><p>与代码相矛盾的注释比没有注释还糟，当代码更改时，优先更新对应的注释！<br>注释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！)。<br>如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号。<br>在句尾结束的时候应该使用两个空格。<br>当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格。<br>在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读。</p><h6 id="1-块注释"><a href="#1-块注释" class="headerlink" title="1.块注释"></a>1.块注释</h6><p>块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。<br>块注释内部的段落通过只有一个#的空行分隔。</p><h6 id="2-行内注释"><a href="#2-行内注释" class="headerlink" title="2.行内注释"></a>2.行内注释</h6><p>有节制地使用行内注释。<br>行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始。<br>事实上，如果状态明显的话，行内注释是不必要的，反而会分散注意力。</p><h6 id="3-文档字符串注释"><a href="#3-文档字符串注释" class="headerlink" title="3.文档字符串注释"></a>3.文档字符串注释</h6><p>编写好的文档说明（也叫“docstrings”）的约定在<a href="http://legacy.python.org/dev/peps/pep-0257/">PEP 257</a>中永恒不变。</p><ul><li>要为所有的公共模块，函数，类以及方法编写文档说明。非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后。</li><li><a href="http://legacy.python.org/dev/peps/pep-0257/">PEP 257</a> 描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行</li></ul><p> <code>#__doc__ 属性：获取对象的文档字符串注释</code></p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests`<br><br>`<span class="hljs-built_in">print</span>(requests.__doc__)<br></code></pre></td></tr></table></figure><p>类中的文档字符串注释：</p><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Musen</span>:`<br><br>`<span class="hljs-string">&quot;&quot;&quot;`</span><br><span class="hljs-string"></span><br><span class="hljs-string">`mesen这个类的文档字符串注释`</span><br><span class="hljs-string"></span><br><span class="hljs-string">`详细的功能介绍`</span><br><span class="hljs-string"></span><br><span class="hljs-string">`&quot;&quot;&quot;</span>`<br><br>​<span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>(<span class="hljs-params">self,name :<span class="hljs-built_in">str</span>,age :<span class="hljs-built_in">int</span></span>)  -&gt; <span class="hljs-literal">None</span>:   <span class="hljs-comment">#name str类型 age int类型 方法返回值 为None </span><br><br>​<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">​work1这个方法的文档字符串注释</span><br><span class="hljs-string"></span><br><span class="hljs-string">​该方法功能的整体说明</span><br><span class="hljs-string"></span><br><span class="hljs-string">​param name：名字</span><br><span class="hljs-string"></span><br><span class="hljs-string">​param  age：年龄</span><br><span class="hljs-string"></span><br><span class="hljs-string">​&quot;&quot;&quot;</span><br><br>`<span class="hljs-built_in">print</span>(MuSen.__doc__)<br></code></pre></td></tr></table></figure><h5 id="5-命名的约定"><a href="#5-命名的约定" class="headerlink" title="5.命名的约定"></a>5.命名的约定</h5><h6 id="1-变量命名"><a href="#1-变量命名" class="headerlink" title="1.变量命名"></a>1.变量命名</h6><p>永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名。<br>在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替。</p><h6 id="2-函数命名"><a href="#2-函数命名" class="headerlink" title="2.函数命名"></a>2.函数命名</h6><p>函数名应该小写，如果想提高可读性可以用下划线分隔。<br>大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用（比如 threading.py），保持向后兼容性。</p><h6 id="3-类命名"><a href="#3-类命名" class="headerlink" title="3.类命名"></a>3.类命名</h6><p>类名一般使用首字母大写的约定。<br>在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替。<br>注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量。</p><p>4.类里面的函数和方法参数</p><p>始终要将 self 作为实例方法的的第一个参数。<br>始终要将 cls 作为类静态方法的第一个参数。<br>如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好。（也许最好用同义词来避免这种冲突）</p><p>参考资料:</p><p>pep8编码规范 <a href="https://blog.csdn.net/ratsniper/article/details/78954852">https://blog.csdn.net/ratsniper/article/details/78954852</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>python语法</tag>
      
      <tag>python基础</tag>
      
      <tag>Python编码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
